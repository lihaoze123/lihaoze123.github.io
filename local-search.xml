<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>连通性问题 学习笔记</title>
    <link href="/%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="有向图的强连通分量">有向图的强连通分量</h2><p>在解决有向图问题时，通过求解强连通分量并进行缩点，我们可以将原图转化为一个有向无环图(DAG)。这样就能利用拓扑排序的性质，将原问题转化为在DAG 上求解的问题。</p><h3 id="强连通分量">强连通分量</h3><p>在有向图中，如果两个顶点间存在互相可达的路径，我们称这两个顶点是<strong>强连通</strong> 的。当图中任意两点都强连通时，我们称这个图是一个<strong>强连通图</strong>。而一个有向图中的极大强连通子图，则被称为<strong>强连通分量</strong> (Strongly Connected Component, SCC)。</p><h3 id="dfs-生成树">DFS 生成树</h3><p>在进行深度优先搜索(DFS)时，遍历过程中经过的边和顶点会形成一棵树，这就是DFS 生成树。在这棵树中，边可以分为四类：</p><ul><li>树边：DFS 遍历时实际经过的边</li><li>前向边：从祖先指向后代的非树边</li><li>返祖边：从后代指向祖先的边</li><li>横叉边：连接不同子树中节点的边</li></ul><figure><imgsrc="https://picgo-chumeng.oss-cn-beijing.aliyuncs.com/四种边的示意图.svg"alt="四种边的示意图" /><figcaption aria-hidden="true">四种边的示意图</figcaption></figure><p>考虑一个节点和其祖先节点是否在同一个强连通分量中，分为两种情况：</p><ul><li>通过一条返祖边，到达祖先节点</li><li>通过一条横叉边，然后通过一条返祖边，到达祖先节点</li></ul><p>简单来说，如果从一个节点出发可以到达祖先节点，那么这个节点和祖先节点就在同一个强连通分量中。</p><h3 id="tarjan-算法">Tarjan 算法</h3><p>Tarjan 算法需要用到两个数组：</p><ul><li><code>dfn[u]</code>：在 DFS 过程中，节点 <code>u</code>被访问的时间戳</li><li><code>low[u]</code>：在 DFS 过程中，节点 <code>u</code>所能到达的最小的时间戳</li></ul><p>如果一个节点 <code>u</code> 是一个强连通分量的最高点，也即<code>dfn[u] == low[u]</code>，称这个节点为强连通分量的根节点。</p><p>具体来说，在 Tarjan 算法中，我们通过栈维护<strong>已经遍历过尚未处理的节点</strong>，如果一个节点已经不在栈中，说明这个节点已经属于一个强连通分量。</p><p>在 DFS 过程中，对于节点 <code>u</code> 和其相邻的节点<code>v</code>，其中 <code>v</code> 是 <code>u</code>的子节点，考虑以下情况：</p><ul><li>如果 <code>v</code> 未被访问过，则递归访问 <code>v</code>，然后更新<code>low[u]</code> 为 <code>min(low[u], low[v])</code></li><li>如果 <code>v</code> 已经被访问过，且在栈中，则更新<code>low[u]</code> 为 <code>min(low[u], dfn[v])</code></li><li>如果 <code>v</code> 已经被访问过，且不在栈中，则 <code>v</code>已经属于一个强连通分量，跳过</li></ul><p>当一个节点回溯完毕时，我们检查若<code>dfn[u] == low[u]</code>，则栈中从栈顶到当前节点 <code>u</code>的所有节点构成一个强连通分量。</p><h4 id="和拓扑排序的关系">和拓扑排序的关系</h4><p>考虑上面的算法过程，事实上，子树中的节点会比当前节点先被访问，因此，Tarjan算法实际上是按照 <strong>逆拓扑序</strong> 发现强连通分量的，也即<strong>强连通分量的标号是拓扑序的逆序</strong>。</p><h4 id="算法描述">算法描述</h4><p>该算法的时间复杂度为 <span class="math inline">\(O(V +E)\)</span>，以下伪代码描述了 Tarjan 算法的过程：</p><p><span class="math display">\[\begin{align*}&amp; \text{TARJAN($G$)} \\&amp; 1 \qquad \text{cur} = 1 \text{ // Global timestamp} \\&amp; 2 \qquad \text{cnt} = 0 \text{ // Number of SCCs} \\&amp; 3 \qquad \text{dfn}[] = -1 \text{ // Discovery time array} \\&amp; 4 \qquad \text{low}[] = -1 \text{ // Low link value array} \\&amp; 5 \qquad \text{bel}[] = -1 \text{ // SCC belongings array} \\&amp; 6 \qquad \text{stk} = \text{empty stack} \\&amp; 7 \qquad \textbf{for} \ \text{each vertex } u \in G.V \\&amp; 8 \qquad \qquad \textbf{if} \ \text{dfn}[u] = -1 \\&amp; 9 \qquad \qquad \qquad \text{DFS}(u) \\\\&amp; \text{DFS($u$)} \\&amp; 1 \qquad \text{dfn}[u] = \text{low}[u] = \text{cur++} \\&amp; 2 \qquad \text{stk.push}(u) \\&amp; 3 \qquad \textbf{for} \ \text{each vertex } v \in G.\text{Adj}[u]\\&amp; 4 \qquad \qquad \textbf{if} \ \text{dfn}[v] = -1 \\&amp; 5 \qquad \qquad \qquad \text{DFS}(v) \\&amp; 6 \qquad \qquad \qquad \text{low}[u] = \min(\text{low}[u],\text{low}[v]) \\&amp; 7 \qquad \qquad \textbf{else if} \ \text{bel}[v] = -1 \\&amp; 8 \qquad \qquad \qquad \text{low}[u] = \min(\text{low}[u],\text{dfn}[v]) \\&amp; 9 \qquad \textbf{if} \ \text{dfn}[u] = \text{low}[u] \\&amp; 10 \qquad \qquad \textbf{repeat} \\&amp; 11 \qquad \qquad \qquad v = \text{stk.top()} \\&amp; 12 \qquad \qquad \qquad \text{stk.pop()} \\&amp; 13 \qquad \qquad \qquad \text{bel}[v] = \text{cnt} \\&amp; 14 \qquad \qquad \textbf{until} \ v = u \\&amp; 15 \qquad \qquad \text{cnt++}\end{align*}\]</span></p><h4 id="代码实现">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SCC</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; dfn, low, bel;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; stk;<br>    <span class="hljs-type">int</span> cur, cnt;<br><br>    <span class="hljs-built_in">SCC</span>() &#123;&#125;<br>    <span class="hljs-built_in">SCC</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-built_in">init</span>(n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        adj.<span class="hljs-built_in">assign</span>(n, &#123;&#125;);<br>        dfn.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">-1</span>);<br>        low.<span class="hljs-built_in">resize</span>(n);<br>        bel.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">-1</span>);<br>        stk.<span class="hljs-built_in">clear</span>();<br>        cur = cnt = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        adj[u].<span class="hljs-built_in">push_back</span>(v);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>        dfn[u] = low[u] = cur ++;<br>        stk.<span class="hljs-built_in">push_back</span>(u);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : adj[u]) &#123;<br>            <span class="hljs-keyword">if</span> (dfn[v] == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">dfs</span>(v);<br>                low[u] = std::<span class="hljs-built_in">min</span>(low[u], low[v]);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bel[v] == <span class="hljs-number">-1</span>) &#123;<br>                low[u] = std::<span class="hljs-built_in">min</span>(low[u], dfn[v]);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (dfn[u] == low[u]) &#123;<br>            <span class="hljs-type">int</span> v;<br>            <span class="hljs-keyword">do</span> &#123;<br>                v = stk.<span class="hljs-built_in">back</span>();<br>                bel[v] = cnt;<br>                stk.<span class="hljs-built_in">pop_back</span>();<br>            &#125; <span class="hljs-keyword">while</span> (v != u);<br>            cnt ++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (dfn[i] == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">dfs</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bel;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例题">例题</h4><ol type="1"><li><a href="https://loj.ac/p/10091">LOJ 10091 「一本通 3.5 例 1」受欢迎的牛</a></li></ol><p>把问题简化为DAG，那么如果一个点被所有点可达，那么这个点一定是唯一的出度为 0的点。</p><p>那么对于本题，我们只需求解出度为 0 的强连通分量的大小即可。</p><p><strong>代码实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> N, M;<br>    std::cin &gt;&gt; N &gt;&gt; M;<br><br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(N);<br>    <span class="hljs-function">SCC <span class="hljs-title">scc</span><span class="hljs-params">(N)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M; i ++) &#123;<br>        <span class="hljs-type">int</span> A, B;<br>        std::cin &gt;&gt; A &gt;&gt; B;<br>        A --, B --;<br><br>        adj[A].<span class="hljs-built_in">push_back</span>(B);<br>        scc.<span class="hljs-built_in">addEdge</span>(A, B);<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> bel = scc.<span class="hljs-built_in">work</span>();<br>    <span class="hljs-type">int</span> cnt = scc.cnt;<br>    <br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">out</span><span class="hljs-params">(cnt)</span></span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(N)</span></span>;<br><br>    <span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span>&amp;&amp; self, <span class="hljs-type">int</span> u) -&gt; <span class="hljs-type">void</span> &#123;<br>        <span class="hljs-keyword">if</span> (vis[u]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        vis[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : adj[u]) &#123;<br>            <span class="hljs-keyword">if</span> (bel[u] != bel[v]) &#123;<br>                out[bel[u]] ++;<br>            &#125;<br>            <span class="hljs-built_in">self</span>(self, v);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++) &#123;<br>        <span class="hljs-built_in">dfs</span>(dfs, i);<br>    &#125;<br><br>    <span class="hljs-type">int</span> t, c = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (out[i] == <span class="hljs-number">0</span>) &#123;<br>            t = i;<br>            c ++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++) &#123;<br>        res += bel[i] == t;<br>    &#125;<br><br>    std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><a href="https://vjudge.net/problem/POJ-1236">POJ 1236 Network ofSchools</a></li></ol><p>题中要求两个问题：</p><ul><li>至少需要多少个学校，使得所有学校都能收到软件</li><li>至少需要添加多少条边，整个图变成强连通图</li></ul><p>对于第一个问题，显然求解入度为 0 的强连通分量的大小即可。</p><p>对于第二个问题，有结论：需要连的边数为 <spanclass="math inline">\(\max(p, q)\)</span>，其中 <spanclass="math inline">\(p\)</span> 是入度为 0 的强连通分量的个数，<spanclass="math inline">\(q\)</span> 是出度为 0的强连通分量的个数。当整个图已经是强连通图时，需要连的边数为 0。</p><p>考虑以下证明：</p><p>不失一般性，我们假设 <span class="math inline">\(p \leqq\)</span>。对于入度为 0 的强连通分量，我们称之为起点，出度为 0的强连通分量，我们称之为终点。</p><ol type="1"><li>当 <span class="math inline">\(p = 1\)</span> 时，显然需要连的边数为<spanclass="math inline">\(q\)</span>，也即需要将终点向起点连返租边（图中红色虚线表示添加的边）。</li></ol><p><imgsrc="https://picgo-chumeng.oss-cn-beijing.aliyuncs.com/Network_of_Schools_pic1.svg" /></p><ol start="2" type="1"><li>当 <span class="math inline">\(p &gt; 1\)</span>时，考虑选一个终点，将其与一个不同于其祖先的起点连边，此时该终点的出度变为1，被连的起点入度变为 1，此时 <span class="math inline">\(p\)</span> 和<span class="math inline">\(q\)</span> 都减 1。</li></ol><p><imgsrc="https://picgo-chumeng.oss-cn-beijing.aliyuncs.com/Network_of_Schools_pic2.svg" /></p><p>重复上述过程，直到 <span class="math inline">\(p =1\)</span>，此时已经连的边数为 <span class="math inline">\(p -1\)</span>，剩下的终点数 <span class="math inline">\(q&#39; = q - p +1\)</span>，由 1 可知，需要再连的边数为 <spanclass="math inline">\(q&#39;\)</span>，总共需要连的边数为 <spanclass="math inline">\(p - 1 + q&#39; = q\)</span>。</p><p>综上，需要连的边数为 <span class="math inline">\(\max(p,q)\)</span>。</p><p><strong>代码实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br><br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n);<br>    <span class="hljs-function">SCC <span class="hljs-title">scc</span><span class="hljs-params">(n)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x; std::cin &gt;&gt; x, x;) &#123;<br>            adj[i].<span class="hljs-built_in">push_back</span>(x - <span class="hljs-number">1</span>);<br>            scc.<span class="hljs-built_in">addEdge</span>(i, x - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> bel = scc.<span class="hljs-built_in">work</span>();<br>    <span class="hljs-type">int</span> cnt = scc.cnt;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">in</span><span class="hljs-params">(cnt)</span>, <span class="hljs-title">out</span><span class="hljs-params">(cnt)</span></span>;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (vis[i]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        q.<span class="hljs-built_in">push</span>(i);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span> (vis[x]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            vis[x] = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : adj[x]) &#123;<br>                <span class="hljs-keyword">if</span> (bel[y] != bel[x]) &#123;<br>                    in[bel[y]] ++, out[bel[x]] ++;<br>                    q.<span class="hljs-built_in">push</span>(y);<br>                &#125; <br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>, q = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (in[i] == <span class="hljs-number">0</span>) &#123;<br>            p ++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (out[i] == <span class="hljs-number">0</span>) &#123;<br>            q ++;<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">set</span>(bel.<span class="hljs-built_in">begin</span>(), bel.<span class="hljs-built_in">end</span>()).<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; std::<span class="hljs-built_in">max</span>(p, q) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>河南省第十五届ICPC大学生程序设计竞赛 VP 解题报告</title>
    <link href="/%E6%B2%B3%E5%8D%97%E7%9C%81%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8AICPC%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-VP-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/%E6%B2%B3%E5%8D%97%E7%9C%81%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8AICPC%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-VP-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="a.-分糖果">A. 分糖果</h2><h3 id="大致题意">大致题意</h3><p>一堆一袋中个数分别为 1, 2, 3 的糖果，能不能平均分给两个小朋友。</p><h3 id="分析">分析</h3><h4 id="法一-分类讨论">法一 分类讨论</h4><p>当糖果个数的总和为奇数时，显然不能平分。<br />当糖果个数的总和为偶数时，我们执行这样的策略：优先考虑分个数为 2, 3的糖果，每次优先分给当前糖果最少的小朋友，最后两者糖果个数之差的绝对值不超过3，分完后用个数为 1 的糖果把差值补上。 具体来说，按照 1的数量，进行完上述操作后，我们进行以下的分类讨论：<br />1. 对于 <span class="math inline">\(cnt_1 \ge 2\)</span> 的情况<br />经过上面的分析，我们知道两个小朋友的差值不超过 3。<br />- 若差值恰等于3，说明目前两个小朋友手上的糖果总和为奇数，而大前提是所有糖果个数的总和为偶数，这说明剩下的<span class="math inline">\(cnt_1\)</span> 至少为 3。<br />- 若差值为 1 或 2，则总是能恰好补上。</p><ol start="2" type="1"><li><p>对于 <span class="math inline">\(cnt_1 = 1\)</span> 的情况<br />我们考虑恰分完 3 后的情况，显然在大前提下 3的个数为奇数个，则此时两者差值为 3，开始分 2 后两者之间的差值一定始终为1。换句话说，<span class="math inline">\(cnt_2 \ge 1\)</span>，即能分2，那么总是能用 1 把差值补上。</p></li><li><p>对于 <span class="math inline">\(cnt_1 = 0\)</span> 的情况<br />此时在大前提下 <span class="math inline">\(cnt_3\)</span>一定为偶数。</p></li></ol><ul><li>当 <span class="math inline">\(cnt_2\)</span>为偶数时，能直接平分。</li><li>当 <span class="math inline">\(cnt_2\)</span>为奇数时，经过简单的枚举我们发现只有当 <span class="math inline">\(cnt_2\ge 3, cnt_3 \ge 2\)</span> 时，能够平分。我们考虑最基本的情况 <spanclass="math inline">\(cnt_2 = 3,cnt_3\)</span>，此时的分法是一个小朋友分三个 2，另一个分两个3。对于剩下的情况，我们总是操作到基本情况。</li></ul><h4 id="法二-完全背包">法二 完全背包</h4><p>当谈论是否能平分时，我们实际上在讨论是否存在能 <strong>恰好</strong>填满容量为所有糖果数量一半的背包的方案。由此我们将该问题转化成了多重背包问题的可行性问题。<br />除了使用单调队列优化，事实上在背包问题九讲<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="崔添翼《背包问题九讲》https://github.com/tianyicui/pack">[1]</span></a></sup>中，作者给出了一种较为简单的<span class="math inline">\(O(VN)\)</span>复杂度解多重背包问题可行性的算法：</p><blockquote><p>下面介绍一种实现较为简单的 <span class="math inline">\(O(VN)\)</span>复杂度解多重背包问题的算法。它的基本思想是这样的：设 <spanclass="math inline">\(F[i, j]\)</span> 表示“用了前 <spanclass="math inline">\(i\)</span> 种物品填满容量为 <spanclass="math inline">\(j\)</span> 的背包后，最多还剩下几个第 <spanclass="math inline">\(i\)</span> 种物品可用”，如果 <spanclass="math inline">\(F[i, j] = −1\)</span>则说明这种状态不可行，若可行应满足 <span class="math inline">\(0 \leF[i, j] \le M_i\)</span>。</p></blockquote><p>该算法的状态转移方程为 <span class="math inline">\(F[i, j + C_i]\gets \max\{F[i, j + C_i], F[i, j] - 1\}\)</span>。</p><h3 id="代码">代码</h3><h4 id="法一">法一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-type">int</span> cnt[<span class="hljs-number">5</span>], sum;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br><br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        std::cin &gt;&gt; t; <br>        ++ cnt[t], sum += t;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">2</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>        std::cout &lt;&lt; std::vector&#123; <span class="hljs-string">&quot;NO&quot;</span>, <span class="hljs-string">&quot;YES&quot;</span> &#125;[cnt[<span class="hljs-number">2</span>] &gt;= <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">2</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; cnt[<span class="hljs-number">3</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">2</span>] &gt;= <span class="hljs-number">3</span> &amp;&amp; cnt[<span class="hljs-number">3</span>] &gt;= <span class="hljs-number">2</span>)<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="法二">法二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> cnt[<span class="hljs-number">5</span>], sum;<br><span class="hljs-type">int</span> f[<span class="hljs-number">4</span>][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br><br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        std::cin &gt;&gt; t; <br>        ++ cnt[t], sum += t;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> V = sum / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; ++ i) &#123;<br>        f[<span class="hljs-number">0</span>][i] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; ++ j) &#123;<br>            <span class="hljs-keyword">if</span> (f[i - <span class="hljs-number">1</span>][j] &gt;= <span class="hljs-number">0</span>)<br>                f[i][j] = cnt[i];<br>            <span class="hljs-keyword">else</span><br>                f[i][j] = <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= V - i; ++ j)<br>            <span class="hljs-keyword">if</span> (f[i][j] &gt; <span class="hljs-number">0</span>)<br>                f[i][j + i] = std::<span class="hljs-built_in">max</span>(f[i][j + i], f[i][j] - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    std::cout &lt;&lt; std::vector&#123; <span class="hljs-string">&quot;NO&quot;</span>, <span class="hljs-string">&quot;YES&quot;</span> &#125;[f[<span class="hljs-number">3</span>][V] != <span class="hljs-number">-1</span>] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="b.-表达式求导">B. 表达式求导</h2><h3 id="大致题意-1">大致题意</h3><p>给定一个包括加法，减法和对数操作的表达式，求出在某点的导数值。</p><h3 id="分析-1">分析</h3><p>表达式求值，如果直接用一个极小数模拟导数的定义求 <spanclass="math inline">\(f(a + \Delta x)\)</span> 和 <spanclass="math inline">\(f(a)\)</span>满足不了精度，可以利用导数的运算法则在求值的同时求导数。<br />具体来说，我们使用递归求给定中缀表达式 <span class="math inline">\(S_{l,r}\)</span>的值：如果当前的区间内包括不被任何括号包含的运算符，选第一个分成左右两半递归。否则递归求解子区间<span class="math inline">\(S_{l + 3, r - 1}\)</span> 的值，并带入 <spanclass="math inline">\(\ln(x)\)</span> 函数。<br />对于如何确定一个运算符是否被括号包括：我们使用一个变量存没有匹配完成的括号的数量，从左向右枚举，出现左括号令变量自增，出现右括号令变量自减。如果枚举到一个运算符的时候变量的值为0，说明枚举过的区间没有括号或者均已匹配，此时该运算符没有被任何括号包括。</p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br>std::string s;<br><br><span class="hljs-function">std::pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">double</span> a)</span> </span>&#123;<br>    <span class="hljs-type">int</span> st = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &gt;= l; -- i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) -- st;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) ++ st;<br><br>        <span class="hljs-keyword">if</span> (!st &amp;&amp; std::set&#123; <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span> &#125;.<span class="hljs-built_in">count</span>(s[i])) &#123;<br>            <span class="hljs-keyword">auto</span> [lv, ld] = <span class="hljs-built_in">calc</span>(l, i - <span class="hljs-number">1</span>, a);<br>            <span class="hljs-keyword">auto</span> [rv, rd] = <span class="hljs-built_in">calc</span>(i + <span class="hljs-number">1</span>, r, a);<br><br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;+&#x27;</span>) <span class="hljs-keyword">return</span> &#123; lv + rv, ld + rd &#125;;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> &#123; lv - rv, ld - rd &#125;;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (s[l] == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; s[r] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>        <span class="hljs-keyword">auto</span> [v, d] = <span class="hljs-built_in">calc</span>(l + <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>, a);<br>        <span class="hljs-keyword">return</span> &#123; std::<span class="hljs-built_in">log</span>(v), d / v&#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;a, <span class="hljs-number">1</span>&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> a;<br><br>    std::cin &gt;&gt; s &gt;&gt; a;<br>    std::<span class="hljs-built_in">erase_if</span>(s, [] (<span class="hljs-type">char</span> x) &#123; <span class="hljs-keyword">return</span> x == <span class="hljs-string">&#x27;l&#x27;</span> || x == <span class="hljs-string">&#x27;n&#x27;</span>; &#125;);<br><br>    <span class="hljs-keyword">auto</span> [_, res] = <span class="hljs-built_in">calc</span>(<span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, a);<br><br>    <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-built_in">int</span>(res * <span class="hljs-number">100</span> - <span class="hljs-number">0.5</span>) / <span class="hljs-number">100.0</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-built_in">int</span>(res * <span class="hljs-number">100</span> + <span class="hljs-number">0.5</span>) / <span class="hljs-number">100.0</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-type">int</span> t;<br>    std::cin &gt;&gt; t;<br><br>    <span class="hljs-keyword">while</span> (t --) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c.-置换操作">C. 置换操作</h2><h3 id="大致题意-2">大致题意</h3><p>给定一个长度为 <span class="math inline">\(n\)</span> 的 01字符串，至多可以进行 2 次修改操作将一个 0 替换成1。在所有可能的修改方案中，最多有几个全 1 子串。</p><h3 id="分析-2">分析</h3><h4 id="法一-贪心分类讨论">法一 贪心，分类讨论</h4><p>分类讨论，在最长子串边上操作或者连接已经存在的子串，总共分六种情况。这里引用标准题解的讨论。</p><blockquote><p>第⼀种情况，需要特判下 <span class="math inline">\(0\)</span>的个数为 <span class="math inline">\(0\)</span> 或 <spanclass="math inline">\(1\)</span> 或 <spanclass="math inline">\(n\)</span> 的情况；<br />第⼆种情况，在最⻓ <span class="math inline">\(1\)</span>串边上进⾏两次操作；<br />第三种情况，替换两串 <span class="math inline">\(1\)</span>之间的正好两个 <span class="math inline">\(0\)</span>；<br />第四种情况，替换两串 <span class="math inline">\(1\)</span>之间的正好⼀个 <span class="math inline">\(0\)</span> ⼀次，在最⻓ <spanclass="math inline">\(1\)</span> 串边上补⼀次操作；<br />第五种情况，替换两串 <span class="math inline">\(1\)</span>之间的正好⼀个 <span class="math inline">\(0\)</span> 两次，且将 <spanclass="math inline">\(3\)</span> 个 <spanclass="math inline">\(1\)</span> 串组合并成 <spanclass="math inline">\(1\)</span> 个 <spanclass="math inline">\(1\)</span> 串；<br />第六种情况，替换两串 <span class="math inline">\(1\)</span>之间的正好⼀个 <span class="math inline">\(0\)</span> 两次，且将 <spanclass="math inline">\(4\)</span> 个串组合并成 <spanclass="math inline">\(2\)</span> 个 <spanclass="math inline">\(1\)</span> 串。</p></blockquote><h4 id="法二-动态规划">法二 动态规划</h4><p>我们使用 <span class="math inline">\(f_{i, j, k}\)</span> 表示前<span class="math inline">\(i\)</span> 个字符，进行了 <spanclass="math inline">\(j\)</span> 次操作，当前所在子串的长度为 <spanclass="math inline">\(k\)</span> 时的子串数。</p><p>状态转移的时候按照当前的字符进行分类讨论：</p><ol type="1"><li><p>若当前字符为 <code>1</code>。<br />在这种情况下可以直接扩展，如果截至上一个 <code>1</code>，子串的长度是<span class="math inline">\(k - 1\)</span>，那么扩展一个 <code>1</code>对答案的贡献是 <span class="math inline">\(k\)</span>。 即 <spanclass="math inline">\(f_{i, j, k} \gets f_{i - 1, j, k - 1} +k\)</span>。</p></li><li><p>若当前字符为 <code>0</code>。<br />在这种情况下我们可以选择是否进行修改操作。</p></li></ol><ul><li>若进行修改操作，那么可以当作一个 <code>1</code> 使用，从操作次数少 1的状态转移过来，即 <span class="math inline">\(f_{i, j, k} \gets f_{i -1, j - 1, k - 1} + k\)</span></li><li>若不进行修改操作，那么保持操作次数不变，从前 <spanclass="math inline">\(i - 1\)</span> 个字符 <spanclass="math inline">\(j\)</span> 次操作的一个 <strong>合法</strong>状态决策过来，即 <span class="math inline">\(f_{i, j, 0} \gets \max\{f_{i - 1, j, k} \}\)</span></li></ul><p>事实上，我们发现在枚举 <span class="math inline">\(k\)</span>的时候会枚举到大量不合法的决策，从而浪费大量的时间，为此我们可以反过来枚举上一个阶段的决策集合执行转移。<br />具体来说，如果使用传统的三维数组来进行状态表示，对于上一阶段有哪些合法决策我们无从得知，或者需要维护额外的数组来保存合法决策集合，而如果使用类似<code>map</code> 的容器，在状态转移的同时也就维护了这些信息。</p><h3 id="代码-2">代码</h3><h4 id="法一-1">法一</h4><p>因为我的码风是对 jiangly 拙劣的模仿，而这道题 jiangly做过，笔者很难保证写出更优雅的代码，所以此处贺来 jiangly的代码，并尝试给出拙劣的注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br><br>    std::string s;<br>    std::cin &gt;&gt; s;<br><br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">count</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;0&#x27;</span>) &lt;= <span class="hljs-number">2</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-number">1LL</span> * n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 0 出现的位置</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; p&#123;<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            p.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    &#125;<br>    p.<span class="hljs-built_in">push_back</span>(n);<br><br>    <span class="hljs-comment">// 计算替换单个 0 的贡献的最大值和次大值</span><br>    <span class="hljs-comment">// 例如 1101 替换前子串个数为 4, 替换后子串个数为 4 + 3 * 2 = 10，替换操作的贡献是 6</span><br>    i64 mx[<span class="hljs-number">2</span>] &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; ++ i) &#123;<br>        i64 v = <span class="hljs-number">1LL</span> * (p[i] - p[i - <span class="hljs-number">1</span>]) * (p[i + <span class="hljs-number">1</span>] - p[i]);<br>        <span class="hljs-keyword">if</span> (v &gt; mx[<span class="hljs-number">0</span>]) &#123;<br>            mx[<span class="hljs-number">1</span>] = mx[<span class="hljs-number">0</span>];<br>            mx[<span class="hljs-number">0</span>] = v;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mx[<span class="hljs-number">1</span>] = std::<span class="hljs-built_in">max</span>(mx[<span class="hljs-number">1</span>], v);<br>        &#125;<br>    &#125;<br><br>    i64 ans = mx[<span class="hljs-number">0</span>] + mx[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 计算替换临近的 0 的贡献的最大值</span><br>    <span class="hljs-comment">// 如果两个 0 相邻，那么相当于连接两个间隔为 2 的子串，如果不相邻也不影响答案</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; ++ i) &#123;<br>        i64 v = <span class="hljs-number">1LL</span> * (p[i] - p[i - <span class="hljs-number">1</span>]) * (p[i + <span class="hljs-number">1</span>] - p[i]) + <span class="hljs-number">1LL</span> * (p[i + <span class="hljs-number">1</span>] - p[i - <span class="hljs-number">1</span>]) * (p[i + <span class="hljs-number">2</span>] - p[i + <span class="hljs-number">1</span>]);<br>        ans = std::<span class="hljs-built_in">max</span>(ans, v);<br>    &#125;<br>    <span class="hljs-comment">// 计算本来的子串的个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; p.<span class="hljs-built_in">size</span>(); ++ i) &#123;<br>        ans += <span class="hljs-number">1LL</span> * (p[i] - p[i - <span class="hljs-number">1</span>]) * (p[i] - p[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="法二-1">法二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br>std::map&lt;<span class="hljs-type">int</span>, i64&gt; f[N][<span class="hljs-number">3</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br><br>    std::string s;<br>    std::cin &gt;&gt; s;<br><br>    s = <span class="hljs-string">&#x27; &#x27;</span> + s;<br><br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">2</span>; ++ j) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">2</span>; ++ j)<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[k, _] : f[i - <span class="hljs-number">1</span>][j])<br>                        f[i][j][k + <span class="hljs-number">1</span>] = f[i - <span class="hljs-number">1</span>][j][k] + k + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[k, _]: f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])<br>                        f[i][j][k + <span class="hljs-number">1</span>] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][k] + k + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[k, _]: f[i - <span class="hljs-number">1</span>][j])<br>                    f[i][j][<span class="hljs-number">0</span>] = std::<span class="hljs-built_in">max</span>(f[i][j][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span>][j][k]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    i64 res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">2</span>; ++ j)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[k, v] : f[n][j])<br>            res = std::<span class="hljs-built_in">max</span>(res, v);<br><br>    std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="d.-游戏扑克牌">D. 游戏扑克牌</h2><h3 id="大致题意-3">大致题意</h3><p>给定 n 张牌，其中前 <span class="math inline">\(k_b + k_r\)</span>张牌中有 <span class="math inline">\(k_b\)</span> 张黑色牌，<spanclass="math inline">\(k_r\)</span>张红色牌。黑色牌在整个牌组中出现的概率相等。求满足黑色牌的数量区间为某个区间的概率不小于<span class="math inline">\(\frac{p}{100}\)</span>的最短且最靠前区间。</p><h3 id="分析-3">分析</h3><p>我们假设黑色牌的数量为 <span class="math inline">\(i\)</span>的概率为 <span class="math inline">\(w_i\)</span>，则原问题等价于求最小最靠前的 <span class="math inline">\([L,R]\)</span> 满足 <span class="math inline">\(\displaystyle\frac{\sum_L^R w_i}{\sum_1^n w_i} \ge \frac{p}{100}\)</span>。</p><p>由于前 <span class="math inline">\(k_b + k_r\)</span> 张牌中 <spanclass="math inline">\(k_b\)</span>张黑色牌是确定的，于是求黑色牌的数量为 <spanclass="math inline">\(i\)</span> 的方案的个数等价于求在后 <spanclass="math inline">\(n - k_b - k_r\)</span> 张牌中有 <spanclass="math inline">\(i - k_b\)</span>张黑色牌的方案数。又因为黑色牌在整个牌组出现的概率相等，所以概率为方案数除以整个牌组中选<span class="math inline">\(i\)</span> 张牌的方案数，即 <spanclass="math inline">\(\displaystyle w_i = \frac{C_{n - k_b - k_r}^{i -k_b}}{C_n^i}\)</span>。</p><p>我们预处理出 <span class="math inline">\(w_i\)</span>的值，然后用双指针求出答案。</p><h3 id="代码-3">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> f128 = <span class="hljs-type">long</span> <span class="hljs-type">double</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">60</span>;<br><br>i64 C[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, kb, kr, p;<br>    std::cin &gt;&gt; n &gt;&gt; kb &gt;&gt; kr &gt;&gt; p;<br><br>    <span class="hljs-function">std::vector&lt;f128&gt; <span class="hljs-title">w</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    f128 sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= kb &amp;&amp; n - i &gt;= kr) &#123;<br>            w[i] = <span class="hljs-number">1.0L</span> * C[n - kb - kr][i - kb] / C[n][i];<br>            sum += w[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++ i) &#123;<br>        w[i] /= sum;<br>    &#125;<br><br>    <span class="hljs-type">int</span> L = <span class="hljs-number">0</span>, R = n;<br>    f128 res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>; l &lt;= n; ++ l) &#123;<br>        <span class="hljs-keyword">while</span> (r &lt;= n &amp;&amp; (r &lt;= l || res &lt; p / <span class="hljs-number">100.0L</span>)) &#123;<br>            res += w[r ++];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (res &gt;= p / <span class="hljs-number">100.0L</span>) &#123;<br>            <span class="hljs-keyword">if</span> (r - l - <span class="hljs-number">1</span> &lt; R - L) &#123;<br>                L = l, R = r - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        res -= w[l];<br>    &#125;<br><br>    std::cout &lt;&lt; L &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; R &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++ i) &#123;<br>        C[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; ++ j) &#123;<br>            C[i][j] = C[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + C[i - <span class="hljs-number">1</span>][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> t;<br>    std::cin &gt;&gt; t;<br><br>    <span class="hljs-keyword">while</span> (t --) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="e.-公切线">E. 公切线</h2><h3 id="大致题意-4">大致题意</h3><p>给定两个交集面积为零的正方形，求公切线的数量。</p><h3 id="分析-4">分析</h3><p>分类讨论：</p><ol type="1"><li><p>对于一般的情况，即两个正方形没有任何形式的接触，此时切线有 4条。</p></li><li><p>对于两个正方形各自有一条边紧贴于同一条直线或者一个正方形的一个顶点在另一个正方形的一条边上的情况，此时切线有3 条。</p></li><li><p>对于两个正方形有顶点重合的情况，此时切线有无数条。</p></li></ol><h3 id="代码-4">代码</h3><p>由于笔者没有写过几道计算几何题，无法给出足够优雅的代码，而本题其本身除了有分类讨论的思维难度外，即使提供代码也无法提供建设性的帮助，所以此处代码略去。</p><h2 id="f.-factorial">F. Factorial</h2><h3 id="大致题意-5">大致题意</h3><p>求一个最小的正整数 <span class="math inline">\(N\)</span> 使得 <spanclass="math inline">\(N! \equiv 0 \pmod{M}\)</span>，其中 <spanclass="math inline">\(\displaystyle M = \prod_{i = 1}^{K}p_i^{e_i}\)</span>，数据给定每一个 <spanclass="math inline">\(e_i\)</span>。</p><h3 id="分析-5">分析</h3><p><strong>引理</strong>勒让德定理<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="勒让德定理 https://en.wikipedia.org/wiki/Legendre%27s_formula">[2]</span></a></sup>在计算阶乘中质数的指数时，我们使用勒让德定理 <spanclass="math inline">\(\displaystyle v_{p}(n!) = \sum_{k \ge 1}\left\lfloor \frac{n}{p^k} \right\rfloor\)</span> 其中，<spanclass="math inline">\(v_{p}(n!)\)</span> 表示 <spanclass="math inline">\(n!\)</span> 中质数 <spanclass="math inline">\(p\)</span> 的指数。</p><p>我们先单独考虑对于每一个因子 <spanclass="math inline">\(p_i^{e_i}\)</span>，求出一个最小的正整数 <spanclass="math inline">\(N_i\)</span> 使得 <span class="math inline">\(N_i! \equiv 0 \pmod{p_i^{e_i}}\)</span>，则最终的答案为 <spanclass="math inline">\(N = \max \{N_i\}\)</span>。</p><p>先证 <span class="math inline">\(N_i\)</span> 一定是 <spanclass="math inline">\(p_i\)</span> 的倍数，由于 <spanclass="math inline">\(p_i\)</span> 是质数所以除了它的倍数其余的数都与<span class="math inline">\(p_i\)</span> 互质，所以 <spanclass="math inline">\(N_i!\)</span> 的所有因数中只有 <spanclass="math inline">\(p_i\)</span>的倍数能够对勒让德定理的结果产生贡献。</p><p>而为了产生指数 <span class="math inline">\(e_i\)</span>，容易想到<span class="math inline">\(e_i p_i\)</span>，在代入公式后 <spanclass="math inline">\(\displaystyle \sum_{k \ge 1} \left\lfloor\frac{e_i p_i}{p^k} \right\rfloor\)</span> 展开式的第一项就是 <spanclass="math inline">\(e_i\)</span>，我们把冗余项减去，得到 <spanclass="math inline">\(\displaystyle \sum_{k \ge 1} \left\lfloor\frac{e_i p_i}{p^k} \right\rfloor - \sum_{k \ge 1} \left\lfloor\frac{e_i}{p^k} \right\rfloor\)</span>。</p><p>在得到上面的式子后我们很容易联想到将两个和式合并得到 <spanclass="math inline">\(\displaystyle\sum_{k \ge 1} \left\lfloor\frac{e_i(p_i - 1)}{p}\right\rfloor\)</span>，然后我们确定其与原式之间的关系：</p><p><span class="math display">\[\begin{aligned}\sum_{k \ge 1} \left\lfloor \frac{e_i(p_i - 1)}{p_i} \right\rfloor&amp;= \left\lfloor \frac{e_i(p_i - 1)}{p_i} \right\rfloor +\left\lfloor \frac{e_i(p_i - 1)}{p_i^2} \right\rfloor + \left\lfloor\frac{e_i(p_i - 1)}{p_i^3} \right\rfloor + \dots \\&amp;&lt; e_i(p_i - 1) \left( \frac{1}{p_i} + \frac{1}{p_i^2} +\frac{1}{p_i^3}+ \dots \right) \\&amp;= e_i \left( 1 - \frac{1}{p^k} \right) \\&amp;&lt; e_i\end{aligned}\]</span></p><p>根据上面的证明我们先令 <span class="math inline">\(N_i \gets e_i (p_i- 1)\)</span>，同时为了保证为 <span class="math inline">\(p_i\)</span>的倍数我们使用模运算 <span class="math inline">\(N_i \gets N_i + (p_i -N_i \ \mathrm{mod} \ p_i) \ \mathrm{mod} \p_i\)</span>。此时我们得到了一个足够大，但是又不足以产生 <spanclass="math inline">\(e_i\)</span> 的数，我们继续每次对 <spanclass="math inline">\(N_i\)</span> 增加 <spanclass="math inline">\(p_i\)</span>，然后朴素地计算对指数的增量，直到指数至少为<span class="math inline">\(e_i\)</span>。</p><h3 id="代码-5">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; prime;<br><br><span class="hljs-function">i64 <span class="hljs-title">get</span><span class="hljs-params">(i64 n, i64 p)</span> </span>&#123;<br>    i64 res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        n /= p, res += n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> K;<br>    std::cin &gt;&gt; K;<br><br>    <span class="hljs-function">std::vector&lt;i64&gt; <span class="hljs-title">e</span><span class="hljs-params">(K)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : e) &#123;<br>        std::cin &gt;&gt; x;<br>    &#125;<br><br>    i64 ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; K; ++ i) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;p = prime[i];<br><br>        i64 n = e[i] * (p - <span class="hljs-number">1</span>);<br>        n += (p - n % p) % p;<br><br>        i64 res = <span class="hljs-built_in">get</span>(n, p);<br>        <span class="hljs-keyword">while</span> (res &lt; e[i]) &#123;<br>            n += p;<br>            <span class="hljs-keyword">for</span> (i64 x = n; x % p == <span class="hljs-number">0</span>; x /= p) &#123;<br>                ++ res;<br>            &#125;<br>        &#125;<br><br>        ans = std::<span class="hljs-built_in">max</span>(ans, n);<br>    &#125;<br><br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    std::bitset&lt;1010&gt; st;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">1000</span>; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>            prime.<span class="hljs-built_in">push_back</span>(i);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;p : prime) &#123;<br>            <span class="hljs-keyword">if</span> (i * p &gt; <span class="hljs-number">1000</span>) <span class="hljs-keyword">break</span>;<br>            st[i * p] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % p == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> t;<br>    std::cin &gt;&gt; t;<br><br>    <span class="hljs-keyword">while</span> (t --) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="g.-三元组">G. 三元组</h2><h3 id="大致题意-6">大致题意</h3><p>求所有元素和为 <span class="math inline">\(X\)</span> 的序列中，满足<span class="math inline">\(i \le i &lt; j &lt; k \le n, A_i + A_j =A_k\)</span> 的三元组 <span class="math inline">\((i, j, k)\)</span>的数量的最大值。</p><h3 id="分析-6">分析</h3><p>要使三元组的数量尽量多，我们会希望序列的长度尽量长，因此最优的构造一定是一个只含<span class="math inline">\(1\)</span> 或 <spanclass="math inline">\(2\)</span> 的序列。</p><p>假设 <span class="math inline">\(2\)</span> 的数量为 <spanclass="math inline">\(a\)</span>，则三元组的方案数为 <spanclass="math inline">\(\displaystyle a \cdot C_{X - 2 a}^{2} = \frac{a(X- 2a)(X - 2a - 1)}{2}\)</span>，</p><p>经过打表观察方案数最大时 <span class="math inline">\(a\)</span> 和<span class="math inline">\(X\)</span> 的数量关系：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs makefile">X = 1, a = 0 <br>X = 2, a = 0 <br>X = 3, a = 0 <br>X = 4, a = 1 <br>X = 5, a = 1 <br>X = 6, a = 1 <br>X = 7, a = 1 <br>X = 8, a = 1 <br>X = 9, a = 1 <br>X = 10, a = 2 <br>X = 11, a = 2 <br>X = 12, a = 2 <br>X = 13, a = 2 <br>X = 14, a = 2 <br>X = 15, a = 2 <br>X = 16, a = 3 <br>X = 17, a = 3 <br>X = 18, a = 3 <br>X = 19, a = 3 <br>X = 20, a = 3 <br>X = 21, a = 3 <br>X = 22, a = 4 <br>X = 23, a = 4 <br>X = 24, a = 4 <br>X = 25, a = 4 <br>X = 26, a = 4 <br>X = 27, a = 4 <br>X = 28, a = 5 <br>X = 29, a = 5 <br>...<br></code></pre></td></tr></table></figure><p>我们发现 <span class="math inline">\(a = \left\lfloor \frac{X + 2}{6}\right\rfloor\)</span>，此处我们不加证明地利用这个规律，笔者才疏学浅没有找到合适的办法证明。</p><h3 id="代码-6">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> u64 = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    u64 X;<br>    std::cin &gt;&gt; X;<br><br>    u64 a = (X + <span class="hljs-number">2</span>) / <span class="hljs-number">6</span>;<br>    std::cout &lt;&lt; a * (X - <span class="hljs-number">2</span> * a) * (X - <span class="hljs-number">2</span> * a - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> t;<br>    std::cin &gt;&gt; t;<br><br>    <span class="hljs-keyword">while</span> (t --) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="h.-二十四点">H. 二十四点</h2><h3 id="大致题意-7">大致题意</h3><p>求仅由数字 <span class="math inline">\(k\)</span> 组成，所有值为<span class="math inline">\(n\)</span> 的包括 <code>+</code>,<code>*</code>, <code>()</code> 等操作的表达式中数字 <spanclass="math inline">\(k\)</span> 的最小出现次数</p><h3 id="分析-7">分析</h3><p>考虑使用动态规划，<span class="math inline">\(f_{i, j}\)</span>表示值为 <span class="math inline">\(j\)</span> 的表达式中 <spanclass="math inline">\(i\)</span> 的最小出现次数。</p><p>动态规划的边界为 <span class="math inline">\(f_{1, 1} = 1, f_{1, 11}= 2, f_{1, 111} = 3, \dots, f_{i, \underbrace{ii \dots iii}_{\text{共 }k \text{ 个 } i}} = k\)</span>。</p><p>状态转移方程为</p><p><span class="math display">\[f_{i, j} = \min_{1 &lt; k &lt; j}\begin{cases}    f_{i, j - k} + f_{i, k} &amp;, \ j \ \mathrm{mod} \ k \neq  0 \\    \min \{ f_{i, j - k} + f_{i, k}, f_{i, \frac{j}{k}} + f_{i, k} \}&amp;, \ j \ \mathrm{mod} \ k = 0\end{cases}\]</span></p><p>我们预处理出所有状态，然后对于每个询问可以 <spanclass="math inline">\(O(1)\)</span> 查询答案。</p><h3 id="代码-7">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>;<br><br><span class="hljs-type">int</span> f[<span class="hljs-number">10</span>][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> k, n;<br>    std::cin &gt;&gt; k &gt;&gt; n;<br><br>    <span class="hljs-keyword">if</span> (f[k][n] == <span class="hljs-number">0x3f3f3f3f</span>)<br>        std::cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">else</span><br>        std::cout &lt;&lt; f[k][n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; ++ i) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">4</span>; j *= <span class="hljs-number">10</span>, ++ k) &#123;<br>            t += i * j;<br>            <span class="hljs-keyword">if</span> (t &gt;= N) <span class="hljs-keyword">break</span>;<br><br>            f[i][t] = k;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; ++ i) &#123;<br>        <span class="hljs-keyword">auto</span> g = f[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; N; ++ j) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt; j; ++ k) &#123;<br>                g[j] = std::<span class="hljs-built_in">min</span>(g[j], g[j - k] + g[k]);<br>                <span class="hljs-keyword">if</span> (j % k == <span class="hljs-number">0</span>)<br>                    g[j] = std::<span class="hljs-built_in">min</span>(g[j], g[j / k] + g[k]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> t;<br>    std::cin &gt;&gt; t;<br><br>    <span class="hljs-keyword">while</span> (t --) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="i.-字符串大师">I. 字符串大师</h2><h3 id="大致题意-8">大致题意</h3><p>给定一个字符串 <span class="math inline">\(s\)</span> 和一个长为<span class="math inline">\(2\)</span> 的字符串 <spanclass="math inline">\(t\)</span>，求最少的修改次数，使得 <spanclass="math inline">\(s\)</span> 中等于 <spanclass="math inline">\(t\)</span> 的子序列个数最大。</p><h3 id="分析-8">分析</h3><p>分类讨论：</p><ol type="1"><li><p>若 <span class="math inline">\(t\)</span>中两个字符相等，则最大值为 <span class="math inline">\(C_n^{2} = \frac{n(n - 1)}{2}\)</span>，修改次数为 <spanclass="math inline">\(\displaystyle\sum_{c \in s} [c \neqt_0]\)</span>。</p></li><li><p>若 <span class="math inline">\(t\)</span>中两个字符不等，则最大值为 <span class="math inline">\(\left\lfloor\frac{n}{2} \right\rfloor \left\lceil \frac{n}{2}\right\rceil\)</span>，修改次数为 <spanclass="math inline">\(\displaystyle\sum_{c \in s.l}[c \neq t_0] +\sum_{c \in s.r}[c \neq t_1] + [s.length \in odds \textbf{ and } s.mid\notin \{t_0, t_1\}]\)</span>，其中 <span class="math inline">\(s.l,s.r\)</span> 代表 <span class="math inline">\(s\)</span>的左右区间，在奇数长的 <span class="math inline">\(s\)</span>中均不包括中间字符 <span class="math inline">\(s.mid\)</span>。</p></li></ol><h3 id="代码-8">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    i64 n;<br>    std::cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    std::string s, t;<br>    std::cin &gt;&gt; s &gt;&gt; t;<br><br>    i64 l = std::<span class="hljs-built_in">count_if</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + n / <span class="hljs-number">2</span>, [&amp;] (<span class="hljs-type">char</span> x) &#123; <span class="hljs-keyword">return</span> x != t[<span class="hljs-number">0</span>]; &#125;);<br>    i64 r = std::<span class="hljs-built_in">count_if</span>(s.<span class="hljs-built_in">rbegin</span>(), s.<span class="hljs-built_in">rbegin</span>() + n / <span class="hljs-number">2</span>, [&amp;] (<span class="hljs-type">char</span> x) &#123; <span class="hljs-keyword">return</span> x != t[<span class="hljs-number">1</span>]; &#125;);<br><br>    <span class="hljs-keyword">if</span> (t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>]) &#123;<br>        i64 cnt = std::<span class="hljs-built_in">count_if</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), [&amp;] (<span class="hljs-type">char</span> x) &#123; <span class="hljs-keyword">return</span> x != t[<span class="hljs-number">0</span>]; &#125;);<br>        std::cout &lt;&lt; n * (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        i64 mid = n &amp; <span class="hljs-number">1</span> &amp;&amp; s[n / <span class="hljs-number">2</span>] != t[<span class="hljs-number">0</span>] &amp;&amp; s[n / <span class="hljs-number">2</span>] != t[<span class="hljs-number">1</span>];<br>        std::cout &lt;&lt; (n / <span class="hljs-number">2</span>) * ((n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; l + mid + r &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>崔添翼《背包问题九讲》https://github.com/tianyicui/pack<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>勒让德定理https://en.wikipedia.org/wiki/Legendre%27s_formula<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>题解</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用算法 &amp; 数据结构模板</title>
    <link href="/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF/"/>
    <url>/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>大部分参考 Acwing 提供的模板，细节处有修改。</p><span id="more"></span><h2 id="快速排序">快速排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = a[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i ++; <span class="hljs-keyword">while</span> (a[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j --; <span class="hljs-keyword">while</span> (a[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) std::<span class="hljs-built_in">swap</span>(a[i], a[j]);<br>    &#125;<br><br>    <span class="hljs-built_in">qsort</span>(a, l, j), <span class="hljs-built_in">qsort</span>(a, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序">归并排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(l, mid), <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &lt;= a[j]) tmp[k ++] = a[i ++];<br>        <span class="hljs-keyword">else</span> tmp[k ++] = a[j ++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++] = a[i ++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++] = a[j ++];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; ++ i)<br>        a[i] = tmp[i - l];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="整数二分">整数二分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (a[mid] &lt;= x) l = mid;<br>    <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (a[mid] &gt;= x) r = mid;<br>    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度加法">高精度加法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || i &lt; B.<span class="hljs-built_in">size</span>(); ++ i) &#123;<br>        t += (i &lt; A.<span class="hljs-built_in">size</span>() ? A[i] : <span class="hljs-number">0</span>) + (i &lt; B.<span class="hljs-built_in">size</span>() ? B[i] : <span class="hljs-number">0</span>);<br>        res.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (t) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; res.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) &#123;<br>        res.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// e.g.</span><br><span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">add</span>(A, B);<br><br>std::<span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : C) &#123;<br>    std::cout &lt;&lt; x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度减法">高精度减法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; B)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || i &lt; B.<span class="hljs-built_in">size</span>(); ++ i) &#123;<br>        t = (i &lt; A.<span class="hljs-built_in">size</span>() ? A[i] : <span class="hljs-number">0</span>) - (i &lt; B.<span class="hljs-built_in">size</span>() ? B[i] : <span class="hljs-number">0</span>) - t;<br>        res.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        t = t &lt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; res.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) &#123;<br>        res.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; B)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; -- i)<br>            <span class="hljs-keyword">if</span> (A[i] != B[i])<br>                <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// e.g.</span><br><span class="hljs-type">bool</span> flag = <span class="hljs-built_in">cmp</span>(A, B);<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br><span class="hljs-keyword">if</span> (flag) C = <span class="hljs-built_in">sub</span>(A, B);<br><span class="hljs-keyword">else</span> C = <span class="hljs-built_in">sub</span>(B, A);<br><br>std::<span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-keyword">if</span> (!flag) std::cout &lt;&lt; <span class="hljs-string">&#x27;-&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : C) &#123;<br>    std::cout &lt;&lt; x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度乘法">高精度乘法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : A) &#123;<br>        t += x * b;<br>        res.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (t) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; res.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) &#123;<br>        res.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// e.g.</span><br><span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A, b);<br><br>std::<span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : C) &#123;<br>    std::cout &lt;&lt; x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度除法">高精度除法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">PVI <span class="hljs-title">div</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; -- i) &#123;<br>        t = t * <span class="hljs-number">10</span> + A[i];<br>        res.<span class="hljs-built_in">push_back</span>(t / b);<br>        t %= b;<br>    &#125;<br><br>    std::<span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">while</span> (res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; res.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) &#123;<br>        res.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(res, t);<br>&#125;<br><br><span class="hljs-comment">// e.g.</span><br><span class="hljs-keyword">auto</span> [C, r] = <span class="hljs-built_in">div</span>(A, b);<br><br>std::<span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : C) &#123;<br>    std::cout &lt;&lt; x;<br>&#125;<br>std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="离散化">离散化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; all;<br>std::<span class="hljs-built_in">sort</span>(all.<span class="hljs-built_in">begin</span>(), all.<span class="hljs-built_in">end</span>());<br>all.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">unique</span>(all.<span class="hljs-built_in">begin</span>(), all.<span class="hljs-built_in">end</span>()), all.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><h2 id="模拟链表">模拟链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> h = <span class="hljs-number">-1</span>, e[N], ne[N], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    e[idx] = a, ne[idx] = h, h = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    h = ne[h];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模拟栈">模拟栈</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// insert</span><br>stk[++ tt] = x;<br><br><span class="hljs-comment">// pop</span><br>-- tt<br>    <br><span class="hljs-comment">// if empty then ...</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br>    <br><span class="hljs-comment">// pop and query</span><br>std::cout &lt;&lt; stk[tt --] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="模拟队列">模拟队列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// insert to front</span><br>q[++ tt] = x;<br><br><span class="hljs-comment">// pop front</span><br>++ hh;<br><br><span class="hljs-comment">// query front</span><br>std::cout &lt;&lt; q[hh] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br><span class="hljs-comment">// if empty then ...</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调栈">单调栈</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::stack&lt;<span class="hljs-type">int</span>&gt; stack;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>    <span class="hljs-keyword">while</span> (stack.<span class="hljs-built_in">size</span>() &amp;&amp; stack.<span class="hljs-built_in">top</span>() &gt;= a[i]) &#123;<br>        stack.<span class="hljs-built_in">pop</span>();        <br>    &#125;<br><br>    std::cout &lt;&lt; (stack.<span class="hljs-built_in">size</span>() ? stack.<span class="hljs-built_in">top</span>() : <span class="hljs-number">-1</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>    stack.<span class="hljs-built_in">push</span>(a[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列">单调队列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::deque&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>    <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>() &amp;&amp; q.<span class="hljs-built_in">front</span>() + len - <span class="hljs-number">1</span> &lt; i)<br>        q.<span class="hljs-built_in">pop_front</span>();<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] &gt;= a[i])<br>        q.<span class="hljs-built_in">pop_back</span>();<br><br>    q.<span class="hljs-built_in">push_back</span>(i);<br><br>    <span class="hljs-keyword">if</span> (i &gt;= len - <span class="hljs-number">1</span>)<br>        std::cout &lt;&lt; a[q.<span class="hljs-built_in">front</span>()] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="kmp-算法">KMP 算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= m) &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || s[i] == s[j])<br>            next[++ i] = ++ j;<br>        <span class="hljs-keyword">else</span><br>            j = next[j];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// usage:</span><br><span class="hljs-comment">// 此处假设字符串的下标从 1 开始。当在待查文本的第 i 位，模式串的第 j 位失配时，令 j = next[j]，即将模式串中下一个要比较的字符对齐 i。</span><br><br><span class="hljs-comment">// e.g.</span><br>i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt;= n &amp;&amp; j &lt;= m) &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || p[i] == s[j]) &#123;<br>        ++ i, ++ j;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        i = next[i];<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (i == n + <span class="hljs-number">1</span>) &#123;<br>        std::cout &lt;&lt; j - i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        i = next[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="trie-树">Trie 树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> son[<span class="hljs-number">26</span>][N], cnt[N], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : s) &#123;<br>        <span class="hljs-keyword">if</span> (son[c - <span class="hljs-string">&#x27;a&#x27;</span>][p])<br>            p = son[c - <span class="hljs-string">&#x27;a&#x27;</span>][p];<br>        <span class="hljs-keyword">else</span> <br>            p = son[c - <span class="hljs-string">&#x27;a&#x27;</span>][p] = ++ idx;<br>    &#125;<br>    ++ cnt[p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : s) &#123;<br>        <span class="hljs-keyword">if</span> (son[c - <span class="hljs-string">&#x27;a&#x27;</span>][p])<br>            p = son[c - <span class="hljs-string">&#x27;a&#x27;</span>][p];<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并查集">并查集</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> p[x] == x ? p[x] : p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>&#125;<br><br><span class="hljs-comment">// init</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>    p[i] = i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="hash">Hash</h2><h3 id="一般-hash">一般 Hash</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// N \in primes</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = (x % N + N) % N;<br>    <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)<br>    &#123;<br>        t ++ ;<br>        <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串-hash">字符串 Hash</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> u64 N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, P = <span class="hljs-number">13331</span>;<br><br>u64 h[N], p[N] = &#123; <span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">// usage</span><br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>    std::cin &gt;&gt; c;<br><br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + c;<br>    p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链式前向星">链式前向星</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// init</span><br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h)<br>    <br><span class="hljs-comment">// usage</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (st[u]) <span class="hljs-keyword">return</span>;<br>    st[u] = <span class="hljs-literal">true</span>;<br>    <br>    std::cout &lt;&lt; u &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> v = e[i];<br>     <br>        <span class="hljs-built_in">dfs</span>(v);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拓扑排序">拓扑排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; topo;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>    <span class="hljs-keyword">if</span> (in[i] == <span class="hljs-number">0</span>) &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>    <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br><br>    topo.<span class="hljs-built_in">push_back</span>(t);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br><br>        <span class="hljs-keyword">if</span> (-- in[j] == <span class="hljs-number">0</span>) &#123;<br>            q.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (topo.<span class="hljs-built_in">size</span>() == n) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : topo) &#123;<br>        std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单源最短路经算法">单源最短路经算法</h2><p>正确性的证明可参考 <ahref="https://chumeng.xyz/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E8%AF%81%E6%98%8E/">单源最短路径算法正确性的证明</a>。</p><h3 id="dijkstra-算法">Dijkstra 算法</h3><p>此处给出堆优化版的 Dijkstra 算法</p><h4 id="伪代码">伪代码</h4><p><span class="math display">\[\begin{align}&amp; \text{DIJKSTRA($G$, $w$, $s$)} \\&amp; 1 \qquad \operatorname{INITIALIZE\_SINGLE\_SOURCE}(G, s) \\&amp; 2 \qquad S = \varnothing \\&amp; 3 \qquad Q = G.V \\&amp; 4 \qquad \textbf{while} \ Q \neq \varnothing \\&amp; 5 \qquad \qquad u = \operatorname{EXTRACT\_MIN}(Q) \\&amp; 6 \qquad \qquad S = S \ \cup \ \{u\} \\&amp; 7 \qquad \qquad \textbf{for} \ \text{each vertex } v \ \in \G.\text{Adj}[u] \\&amp; 8 \qquad \qquad \qquad \text{RELAX}(u, v, w)\end{align}\]</span> #### 代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> dijkstra = [&amp;] () &#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <br><br>    std::priority_queue&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>    q.<span class="hljs-built_in">push</span>(&#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;);<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [_, t] = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span> (st[t]) <br>            <span class="hljs-keyword">continue</span>;<br><br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br><br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;<br>                dist[j] = dist[t] + w[i];<br><br>                q.<span class="hljs-built_in">push</span>(&#123; -dist[j], j &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="bellman-ford-算法以及-spfa-算法">Bellman-Ford 算法以及 SPFA算法</h3><h4 id="伪代码-1">伪代码</h4><p><span class="math display">\[\begin{align}&amp; \text{BELLMAN-FORD($G$, $w$, $s$)} \\&amp; 1 \qquad \operatorname{INITIALIZE\_SINGLE\_SOURCE}(G, s) \\&amp; 2 \qquad \textbf{for} \ i = 1 \ \textbf{to} \ |G.V| - 1 \\&amp; 3 \qquad \qquad \textbf{for} \ \text{each } \operatorname{edge}(u,v) \ \in \ G.E \\&amp; 4 \qquad \qquad \qquad \operatorname{RELAX}(u, v, w) \\&amp; 5 \qquad \textbf{for} \ \text{each } \operatorname{edge}(u, v) \\in \ G.E \\&amp; 6 \qquad \qquad \textbf{if} \ v.d &gt; u.d + w(u, v) \\&amp; 7 \qquad \qquad \qquad \textbf{return } \text{FALSE} \\&amp; 8 \qquad \textbf{return } \text{TRUE}\end{align}\]</span></p><p><span class="math display">\[\begin{align}&amp; \text{SHORTEST-PATH-FAST-ALGORITHM($G$, $w$, $s$)} \\&amp; 1 \qquad \operatorname{INITIALIZE\_SINGLE\_SOURCE}(G, s) \\&amp; 2 \qquad Q = \langle v_1, v_2, \cdots, v_k \rangle \text{ // } v_i\in G.V, \ k = |G.V| \\&amp; 3 \qquad \text{COUNT} = [] \\&amp; 4 \qquad \text{// COUNT is an array used to store the number ofnodes on a certain shortest path} \\&amp; 5 \qquad \text{// to determine whether the graph has a negativecycle.} \\&amp; 6 \qquad \textbf{while} \ Q \neq \varnothing \\&amp; 7 \qquad \qquad u = \operatorname{EXTRACT\_FRONT}(Q) \\&amp; 8 \qquad \qquad \textbf{for} \ \text{each vertex } v \inG.\operatorname{Adj}[u] \\&amp; 9 \qquad \qquad \qquad \textbf{if} \ \operatorname{RELAX}(u, v, w)= \text{TRUE} \\&amp; 10 \qquad \qquad \qquad \qquad \text{COUNT}[v] = \text{COUNT}[u] +1 \\&amp; 11 \qquad \qquad \qquad \qquad \textbf{if} \ \text{COUNT}[v] \geq|G.V| \\&amp; 12 \qquad \qquad \qquad \qquad \qquad \textbf{return} \\text{FALSE} \\&amp; 13 \qquad \qquad \qquad \qquad \textbf{if} \ v \notin Q \\&amp; 14 \qquad \qquad \qquad \qquad \qquad Q = Q \text{ push } v \\&amp; 15 \qquad \textbf{return} \ \text{TRUE}\end{align}\]</span></p><h4 id="代码实现">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> bellman_ford = [&amp;] () &#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[a, b, w] : edge) &#123;<br>            <span class="hljs-keyword">if</span> (dist[b] &gt; bak[a] + w) &#123;<br>                dist[b] = bak[a] + w;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> spfa = [&amp;] () &#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        q.<span class="hljs-built_in">push</span>(i), st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>(), st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br><br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;<br>                dist[j] = dist[t] + w[i];<br><br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(j), st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最小生成树">最小生成树</h2><h3 id="prim-算法">Prim 算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> prim = [&amp;] () &#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j)<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))<br>                t = j;<br><br>        <span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">1</span> &amp;&amp; dist[t] == INF)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">1</span>)<br>            res += dist[t];<br><br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j)<br>            dist[j] = std::<span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="kruskal-算法">Kruskal 算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> Edge = std::array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt;;<br><span class="hljs-function">std::vector&lt;Edge&gt; <span class="hljs-title">edge</span><span class="hljs-params">(m)</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[a, b, w] : edge) &#123;<br>    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>&#125;<br><br>std::<span class="hljs-built_in">sort</span>(edge.<span class="hljs-built_in">begin</span>(), edge.<span class="hljs-built_in">end</span>(), [] (Edge a, Edge b) &#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>) &lt; b.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>);<br>&#125;);<br><br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[a, b, w] : edge) &#123;<br>    a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br><br>    <span class="hljs-keyword">if</span> (a != b) &#123;<br>        res += w, ++ cnt;<br>        p[a] = b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="筛质数">筛质数</h2><h3 id="试除法-osqrtn">试除法 <spanclass="math inline">\(O(\sqrt{n})\)</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="埃氏筛法-on-loglog-n">埃氏筛法 <span class="math inline">\(O(n\log\log n)\)</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>    <span class="hljs-keyword">if</span> (!st[i]) &#123;<br>        primes.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n / i; ++ j) &#123;<br>            st[i * j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线性筛法-on">线性筛法 <spanclass="math inline">\(O(n)\)</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; primes;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>    <span class="hljs-keyword">if</span> (!st[i]) <br>        primes.<span class="hljs-built_in">push_back</span>(i);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;p : primes) &#123;<br>        <span class="hljs-keyword">if</span> (p * i &gt; n) <span class="hljs-keyword">break</span>;<br>        st[p * i] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (i % p == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="欧几里得算法">欧几里得算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="欧拉函数">欧拉函数</h2><h3 id="性质">性质</h3><p><strong>积性函数</strong>：若 <span class="math inline">\(\gcd(a, b)= 1\)</span> 则有 <span class="math inline">\(\varphi(a b) = \varphi(a)\varphi(b)\)</span>。</p><p>对 <span class="math inline">\(p \mid n\)</span> 有 <spanclass="math inline">\(\varphi(n \cdot p) = p \cdot\varphi(n)\)</span>。</p><p>对 <span class="math inline">\(p \nmid n\)</span> 有 <spanclass="math inline">\(\varphi(n \cdot p) = (p - 1) \cdot\varphi(n)\)</span>。</p><h3 id="证明">证明</h3><p>对于 <span class="math inline">\(p \in primes\)</span> 易有 <spanclass="math inline">\(\varphi(p) = p - 1\)</span>。</p><p>又有对于 <span class="math inline">\(p^k\)</span>，除了 <spanclass="math inline">\(p\)</span> 的倍数的所有数都与 <spanclass="math inline">\(p^k\)</span> 互质，而 <spanclass="math inline">\(p\)</span> 的倍数有 <spanclass="math inline">\(p^{k - 1}\)</span> 个，所以有 <spanclass="math inline">\(\varphi(p^k) = p^k -  p^{k - 1} = p^{k - 1} (p -1)\)</span>。</p><p>对于一般的自然数，有 <span class="math display">\[\begin{aligned}\varphi(n) &amp;= \prod \varphi(p_i^{k_i}) \\&amp;= \prod p_i^{k_i - 1} (p - 1) \\&amp;= \prod p_i^{k_i} (1 - \frac{1}{p}) \\&amp;= \prod p_i^{k_i} \prod \frac{p - 1}{p} \\&amp;= n \prod \frac{p - 1}{p}\end{aligned}\]</span></p><h3 id="推广">推广</h3><p><strong>欧拉定理</strong>：对 <span class="math inline">\(\gcd(n, m)= 1\)</span> 有 <span class="math inline">\(n^{\varphi(m)} \equiv 1\pmod{m}\)</span>。</p><p>特殊情况下有 <strong>费马小定理</strong>：<spanclass="math inline">\(p \in primes, \ n^{p - 1} \equiv 1\pmod{p}\)</span>。常用于求乘法逆元。</p><h4 id="证明-1">证明</h4><p>对于 <span class="math inline">\(m\)</span> 的一个简化剩余系 <spanclass="math inline">\(r_1 ,r_2, \dots, r_{\varphi(m)}\)</span>，由于<span class="math inline">\(\gcd(n, m) = 1\)</span>，容易想到其与 <spanclass="math inline">\(nr_1, nr_2, \dots, nr_{\varphi(m)}\)</span>等价。</p><p>所以有 <span class="math inline">\(n^{\varphi(m)} \cdot r_1 \cdot r_2\cdot \cdots \cdot r_{\varphi(m)} \equiv r_1 \cdot r_2 \cdot \cdots\cdot r_{\varphi(m)} \pmod{m}\)</span>。</p><p>化简有 <span class="math inline">\(^{\varphi(m)} \equiv 1\pmod{m}\)</span>。</p><h2 id="快速幂">快速幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">i64 <span class="hljs-title">pmod</span><span class="hljs-params">(i64 a, i64 b, i64 p)</span> </span>&#123;<br>    i64 res = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = (res * a) % p;<br>        a = (a * a) % p;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩展欧几里得算法">扩展欧几里得算法</h2><h3 id="bézout-定理">Bézout 定理</h3><p>存在 <span class="math inline">\(a x + b y = \gcd(a,b)\)</span>。</p><h4 id="证明-2"><strong>证明</strong></h4><ol type="1"><li><p>对于 <span class="math inline">\(\gcd(a, 0)\)</span>，存在 <spanclass="math inline">\(x = 1, y = 0\)</span>。</p></li><li><p>对于 <span class="math inline">\(\gcd(a, b)\)</span>，假设对<span class="math inline">\(\gcd(b, a \ \mathrm{mod} \ b)\)</span>，有<span class="math inline">\(b \cdot x&#39; + (a - \lfloor \frac{a}{b}\rfloor b) \cdot y&#39; = \gcd(b, a \ \mathrm{mod} \ b)\)</span>。</p><p>则有 <span class="math display">\[\begin{aligned}b \cdot x&#39; + (a - \lfloor \frac{a}{b} \rfloor b) \cdot y&#39; &amp;=a \cdot y&#39; + b \cdot (x&#39; - \lfloor \frac{a}{b} \rfloor y&#39;)\\&amp;= \gcd(b, a \ \mathrm{mod} \ b) \\&amp;= \gcd(a, b)\end{aligned}\]</span> 其中 <span class="math inline">\(x = y&#39;, y = x&#39; -\lfloor \frac{a}{b} \rfloor y&#39;\)</span>。</p></li></ol><h3 id="代码">代码</h3><p>用于求解 <span class="math inline">\(a x + b y = \gcd(a,b)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-type">int</span> gcd = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br><br>    y -= (a / b) * x;<br><br>    <span class="hljs-keyword">return</span> gcd;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高斯消元">高斯消元</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; ++ j)<br>            std::cin &gt;&gt; g[i][j];<br><br>    <span class="hljs-keyword">auto</span> gauss = [&amp;] () &#123;<br>        <span class="hljs-type">int</span> col = <span class="hljs-number">0</span>, row = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (; col &lt; n; ++ col) &#123;<br>            <span class="hljs-type">int</span> t = row;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = t + <span class="hljs-number">1</span>; i &lt; n; ++ i) <br>                <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">abs</span>(g[i][col]) &gt; std::<span class="hljs-built_in">abs</span>(g[t][col])) <br>                    t = i;<br><br>            <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">abs</span>(g[t][col]) &lt; eps)<br>                <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = col; i &lt;= n; ++ i) <br>                std::<span class="hljs-built_in">swap</span>(g[t][i], g[row][i]);<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= col; -- i)<br>                g[row][i] /= g[row][col];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row + <span class="hljs-number">1</span>; i &lt; n; ++ i) <br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= col; -- j) <br>                    g[i][j] -= g[row][j] * g[i][col];<br><br>            ++ row;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (row &lt; n) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row; i &lt; n; ++ i) <br>                <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">abs</span>(g[i][n]) &gt; eps) <br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; -- i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>; j &gt; i; -- j) <br>                g[i][n] -= g[i][j] * g[j][n];<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;;<br><br>    <span class="hljs-type">int</span> flag = <span class="hljs-built_in">gauss</span>();<br><br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No solution&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">2</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Infinite group solutions&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) <br>            std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; g[i][n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="lucas-定理">Lucas 定理</h2><p>对 <span class="math inline">\(p \in primes\)</span>，<spanclass="math inline">\(C_n^m = C_{n \ \mathrm{mod} \ p}^{m \ \mathrm{mod}\ p} \cdot C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{m}{p} \rfloor}\pmod p\)</span>。</p><h3 id="证明-3"><strong>证明</strong></h3><p>将 <span class="math inline">\(m, n\)</span> 看作 <spanclass="math inline">\(p\)</span> 进制数，有 <spanclass="math inline">\(m = m_k p^k + m_{k - 1} p^{k - 1} + \dots + m_0p_o\)</span> ，<span class="math inline">\(n = n_k p^k + n_{k - 1} p^{k- 1} + \dots + n_0 p_o\)</span> 。</p><p>我们使用类似生成函数的思想，对 <span class="math inline">\((1 + x) ^p\)</span> 二项式展开，有 <span class="math display">\[\begin{aligned}(1 + x) ^ p &amp;= C_p^0 x^0 + C_p^1 x^1 + \dots + C_p^p x^p \\&amp;\equiv 1 + x^p \pmod{p}\end{aligned}\]</span></p><p>所以对 <span class="math inline">\((1 + x) ^ n\)</span> ，有 <spanclass="math display">\[\begin{aligned}(1 + x) ^ n &amp;\equiv (1 + x)^{n_0p^0} \cdot (1 + x)^{n_1p^1} \cdot\cdots \cdot (1 + x)^{n_kp^k} \pmod{p} \\&amp;\equiv (1 + x^{p_0})^{n_0} \cdot (1 + x^{p_1})^{n_1} \cdot \cdots\cdot (1 + x^{p_k})^{n_k} \pmod{p}\end{aligned}\]</span> 由二项式和组合数的性质，要构造出 <spanclass="math inline">\((1 + x)^m\)</span> 的展开式，需要从 <spanclass="math inline">\((1 + x^{p_0})^{n_0}\)</span> 中选出 <spanclass="math inline">\(x^{p_0}\)</span> 项的 <spanclass="math inline">\(m_0\)</span> 次方，从 <spanclass="math inline">\((1 + x^{p_1})^{n_1}\)</span> 中选出 <spanclass="math inline">\(x^{p_1}\)</span> 项的 <spanclass="math inline">\(m_1\)</span> 次方......其中系数分别为 <spanclass="math inline">\(C_{n_0}^{m_0}, C_{n_1}^{m_1}, \dots,C_{n_k}^{m_k}\)</span>。</p><p>由此我们得出 <span class="math inline">\(C_n^m \equiv C_{n_0}^{m_0}\cdot C_{n_1}^{m_1} \cdot \cdots \cdot C_{n_k}^{m_k}\pmod{p}\)</span>。由进制转换的性质表示成递归形式也即 <spanclass="math display">\[C_n^m = C_{n \ \mathrm{mod} \ p}^{m \ \mathrm{mod} \ p} \cdot C_{\lfloor\frac{n}{p} \rfloor}^{\lfloor \frac{m}{p} \rfloor} \pmod p\]</span></p><h2 id="线性同余方程组的求解">线性同余方程组的求解</h2><h3 id="中国剩余定理">中国剩余定理</h3><p><span class="math display">\[\begin{cases}  x &amp;\equiv a_1 \pmod{m_1} \\  x &amp;\equiv a_2 \pmod{m_2} \\  &amp;\vdots \\  x &amp;\equiv a_n \pmod{m_n}\end{cases}\]</span></p><h4 id="证明-4"><strong>证明</strong></h4><p>对于 <span class="math inline">\(m_i\)</span> 两两互质的情况，令<span class="math display">\[m = \prod_{i = 1}^{n} m_i \\M_i = \frac{m}{m_i} \\M_i t_i \equiv 1 \pmod{m_i}\]</span> <span class="math inline">\(a_iM_it_i\)</span> 是 <spanclass="math inline">\(\forall k \neq i, \ m_k\)</span> 的倍数。</p><p><span class="math display">\[\begin{cases}    a_iM_it_i &amp;\equiv 0 \pmod{m_k} \\    a_iM_it_i &amp;\equiv a_i \pmod{m_i}\end{cases}\]</span></p><p>有</p><p><span class="math display">\[x = \sum_{i = 1}^{n} a_iM_it_i\]</span></p><h3id="对于一般的线性同余方程组的求解">对于一般的线性同余方程组的求解</h3><p>对于 <span class="math inline">\(m_i\)</span>不两两互质的情况，我们考虑分别求解单个线性同余方程，并将各个线性同余方程的解联系起来。</p><p>假设已求出前 <span class="math inline">\(k - 1\)</span> 项的一个解<span class="math inline">\(x\)</span>，我们令 <spanclass="math inline">\(m = \operatorname{lcm}_{i = 1}^{k - 1}m_i\)</span>，则前 <span class="math inline">\(k - 1\)</span> 项的通解为<span class="math inline">\(x + m \cdot i \quad (i \in\mathbb{Z})\)</span>。</p><p>对式 <span class="math inline">\(k\)</span>，我们需要找到一个正整数<span class="math inline">\(t\)</span>，使得 <spanclass="math inline">\(x + m t \equiv a_k \pmod{m_k}\)</span>，也即 <spanclass="math inline">\(m \cdot t \equiv a_k - x\pmod{m_k}\)</span>，则对前 <span class="math inline">\(k\)</span> 项有<span class="math inline">\(x&#39; = x + mt\)</span>，在代码实现中需注意右式 <span class="math inline">\(a_k -x\)</span> 需大于零，且在 C 语言 中随时使用 <code>(x % p + p) % p</code>来保证为最小整数解。</p><p>具体来说，原式可以化为 <span class="math inline">\(m \cdot t + m_k\cdot y = a_k - x\)</span>，我们用扩展欧几里得算法可以求出 <spanclass="math inline">\(m \cdot t + m_k \cdot y = \gcd(m, m_k)\)</span>的解，我们知道原式存在解当且仅当 <span class="math inline">\(\gcd(m,m_k) \mid (a_k - x)\)</span>。</p><h2 id="nim-博弈">Nim 博弈</h2><p>对于 <span class="math inline">\(a_1, a_2, \dots,a_n\)</span>，若</p><ol type="1"><li><span class="math inline">\(a_1 \oplus a_2 \oplus \dots \oplus a_n =0\)</span> ，则先手必败。</li><li><span class="math inline">\(a_1 \oplus a_2 \oplus \dots \oplus a_n\neq 0\)</span>，则先手必胜</li></ol><h3 id="证明-5">证明</h3><ol type="1"><li><p><span class="math inline">\(0 \oplus 0 \oplus \dots \oplus 0 =0\)</span></p></li><li><p>当 <span class="math inline">\(a_1 \oplus a_2 \oplus \dots \oplusa_n = x \neq 0\)</span> 时，一定能操作到等于零：</p><p>一定存在一个 <span class="math inline">\(a_i\)</span> 的第 <spanclass="math inline">\(k\)</span> 位为 <spanclass="math inline">\(1\)</span>，我们知道 <spanclass="math inline">\(a_i \oplus x &lt; a_i\)</span>，若令 <spanclass="math inline">\(a_i\)</span> 减少 <span class="math inline">\(a_i- a_i \oplus x\)</span>，则 <span class="math inline">\(a_i\)</span>变为 <span class="math inline">\(a_i \oplus x\)</span>： <spanclass="math display">\[a_1 \oplus a_2 \oplus \dots \oplus a_i \oplus x \oplus \dots \oplus a_n= x \oplus x = 0\]</span></p></li><li><p>当 <span class="math inline">\(a_1 \oplus a_2 \oplus \dots \oplusa_n = x = 0\)</span> 时，无论怎么操作都不能令新的式子保持为 <spanclass="math inline">\(0\)</span>：</p><p>若原式变为 <span class="math inline">\(a_1 \oplus a_2 \oplus \dots\oplus a_i&#39; \oplus \dots \oplus a_n = 0\)</span>，而原式 <spanclass="math inline">\(a_1 \oplus a_2 \oplus \dots \oplus a_i \oplus\dots \oplus a_n = 0\)</span>，则 <span class="math inline">\(a_i \oplusa_i&#39; = 0\)</span>，有 <span class="math inline">\(a_i =a_i&#39;\)</span>，矛盾。</p></li></ol><p>换句话说，若先手面对的情况为 <span class="math inline">\(a_1 \oplusa_2 \oplus \dots \oplus a_n = x \neq0\)</span>，那么后面面对的情况一定是先手不等于零而后手等于零的状态，即先手必胜。</p><h3 id="sg-函数">SG 函数</h3><p>在一个有向无环图中，终点为 <spanclass="math inline">\(0\)</span>，函数 <spanclass="math inline">\(\operatorname{SG}(x)\)</span> 表示不在节点 <spanclass="math inline">\(x\)</span> 的后继集合中的最小非负整数。</p><p><strong>性质</strong> 若 <spanclass="math inline">\(\operatorname{SG}(x) =0\)</span>，则必败，反之必胜。</p><p>由于 <span class="math inline">\(\operatorname{SG}(x)\)</span>能操作成任何小于 <spanclass="math inline">\(\operatorname{SG}(x)\)</span>的非负整数，类比前面的证明，容易得出 <span class="math display">\[\operatorname{SG}(x_1) \oplus \operatorname{SG}(x_2) \oplus \dots \oplus\operatorname{SG}(x_n) = 0\]</span> 时，先手必败，反之必胜。</p><h2 id="st-算法">ST 算法</h2><p>用于解决区间最值问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SparseTable</span> &#123;<br>    std::vector&lt;std::vector&lt;T&gt;&gt; ST;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SparseTable</span> (<span class="hljs-type">const</span> std::vector&lt;T&gt; &amp;v) &#123;<br>        <span class="hljs-type">int</span> n = v.<span class="hljs-built_in">size</span>(), t = std::<span class="hljs-built_in">log</span>(n) / std::<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<br>        ST.<span class="hljs-built_in">assign</span>(n, std::<span class="hljs-built_in">vector</span>&lt;T&gt;(t, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            ST[i][<span class="hljs-number">0</span>] = v[i];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; t; ++ j)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>)) &lt; n; ++ i)<br>                ST[i][j] = std::<span class="hljs-built_in">max</span>(ST[i][j - <span class="hljs-number">1</span>], ST[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r)<br>            <span class="hljs-keyword">return</span> ST[l][<span class="hljs-number">0</span>];<br><br>        <span class="hljs-type">int</span> k = std::<span class="hljs-built_in">log</span>(r - l + <span class="hljs-number">1</span>) / std::<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">max</span>(ST[l][k], ST[r - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="树状数组">树状数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;T&gt; bit; <br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> x &amp; -x; <br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BIT</span> (<span class="hljs-type">int</span> n) : <span class="hljs-built_in">n</span>(n) &#123;<br>        bit.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">0</span>); <br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span> </span>&#123; <br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span> (; r &gt; <span class="hljs-number">0</span>; r -= <span class="hljs-built_in">lowbit</span>(r)) <br>            res += bit[r]; <br>        <span class="hljs-keyword">return</span> res; <br>    &#125; <br><br>    <span class="hljs-function">T <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (l &gt; r) <br>            std::<span class="hljs-built_in">swap</span>(l, r); <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(r) - <span class="hljs-built_in">ask</span>(l - <span class="hljs-number">1</span>); <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> v)</span> </span>&#123; <br>        <span class="hljs-keyword">for</span> (; i &lt; n; i += <span class="hljs-built_in">lowbit</span>(i)) <br>            bit[i] += v; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="线段树">线段树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Seg</span> &#123;<br>    i64 l, r, dat, sum, add;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sum(x) tree[x].sum</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> add(x) tree[x].add</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> l(x) tree[x].l</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> r(x) tree[x].r</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br>Seg tree[N * <span class="hljs-number">4</span>];<br>i64 a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-built_in">l</span>(p) = l, <span class="hljs-built_in">r</span>(p) = r;<br><br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        <span class="hljs-built_in">sum</span>(p) = a[l];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p * <span class="hljs-number">2</span>, l, mid), <span class="hljs-built_in">build</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">sum</span>(p) = <span class="hljs-built_in">sum</span>(p * <span class="hljs-number">2</span>) + <span class="hljs-built_in">sum</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spread</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">add</span>(p)) &#123;<br>        <span class="hljs-built_in">sum</span>(p * <span class="hljs-number">2</span>) += <span class="hljs-built_in">add</span>(p) * (<span class="hljs-built_in">r</span>(p * <span class="hljs-number">2</span>) - <span class="hljs-built_in">l</span>(p * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">sum</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) += <span class="hljs-built_in">add</span>(p) * (<span class="hljs-built_in">r</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) - <span class="hljs-built_in">l</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">add</span>(p * <span class="hljs-number">2</span>) += <span class="hljs-built_in">add</span>(p);<br>        <span class="hljs-built_in">add</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) += <span class="hljs-built_in">add</span>(p);<br>        <span class="hljs-built_in">add</span>(p) = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, i64 v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt;= <span class="hljs-built_in">l</span>(p) &amp;&amp; r &gt;= <span class="hljs-built_in">r</span>(p)) &#123;<br>        <span class="hljs-built_in">sum</span>(p) += v * (<span class="hljs-built_in">r</span>(p) - <span class="hljs-built_in">l</span>(p) + <span class="hljs-number">1</span>), <span class="hljs-built_in">add</span>(p) += v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">spread</span>(p);<br><br>    <span class="hljs-type">int</span> mid = <span class="hljs-built_in">l</span>(p) + <span class="hljs-built_in">r</span>(p) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid) <span class="hljs-built_in">change</span>(p * <span class="hljs-number">2</span>, l, r, v);<br>    <span class="hljs-keyword">if</span> (r &gt; mid) <span class="hljs-built_in">change</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, l, r, v);<br>    <span class="hljs-built_in">sum</span>(p) = <span class="hljs-built_in">sum</span>(p * <span class="hljs-number">2</span>) + <span class="hljs-built_in">sum</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function">i64 <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt;= <span class="hljs-built_in">l</span>(p) &amp;&amp; r &gt;= <span class="hljs-built_in">r</span>(p)) <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(p);<br><br>    <span class="hljs-built_in">spread</span>(p);<br><br>    <span class="hljs-type">int</span> mid = <span class="hljs-built_in">l</span>(p) + <span class="hljs-built_in">r</span>(p) &gt;&gt; <span class="hljs-number">1</span>;<br><br>    i64 res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid) res += <span class="hljs-built_in">ask</span>(p * <span class="hljs-number">2</span>, l, r);<br>    <span class="hljs-keyword">if</span> (r &gt; mid) res += <span class="hljs-built_in">ask</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="treap-树">Treap 树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">item</span> &#123;<br><span class="hljs-type">int</span> key, prior, cnt, size;<br>item *l, *r;<br><span class="hljs-built_in">item</span> () &#123; &#125;<br><span class="hljs-built_in">item</span> (<span class="hljs-type">int</span> key) : <span class="hljs-built_in">key</span>(key), <span class="hljs-built_in">prior</span>(std::<span class="hljs-built_in">rand</span>()), <span class="hljs-built_in">l</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">r</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">cnt</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">size</span>(<span class="hljs-number">1</span>) &#123; &#125;<br>&#125;;<br><br><span class="hljs-keyword">using</span> pitem = item*;<br><br>pitem root = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(pitem&amp; x)</span> </span>&#123;<br>x-&gt;size = x-&gt;cnt + (x-&gt;l ? x-&gt;l-&gt;size : <span class="hljs-number">0</span>) + (x-&gt;r ? x-&gt;r-&gt;size : <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zig</span><span class="hljs-params">(pitem&amp; x)</span> </span>&#123;<br>pitem y = x-&gt;l;<br>x-&gt;l = y-&gt;r, y-&gt;r = x, x = y;<br><span class="hljs-built_in">update</span>(x), <span class="hljs-built_in">update</span>(x-&gt;r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zag</span><span class="hljs-params">(pitem&amp; x)</span> </span>&#123;<br>pitem y = x-&gt;r;<br>x-&gt;r = y-&gt;l, y-&gt;l = x, x = y;<br><span class="hljs-built_in">update</span>(x), <span class="hljs-built_in">update</span>(x-&gt;l);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(pitem&amp; x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!x) <br><span class="hljs-keyword">return</span> x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">item</span>(y), <span class="hljs-built_in">void</span>();<br><span class="hljs-keyword">if</span> (x-&gt;key == y) <br><span class="hljs-keyword">return</span> ++ x-&gt;cnt, <span class="hljs-built_in">update</span>(x), <span class="hljs-built_in">void</span>();<br><span class="hljs-keyword">if</span> (y &lt; x-&gt;key) &#123;<br><span class="hljs-built_in">insert</span>(x-&gt;l, y);<br><span class="hljs-keyword">if</span> (x-&gt;l-&gt;prior &gt; x-&gt;prior) <span class="hljs-built_in">zig</span>(x);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">insert</span>(x-&gt;r, y);<br><span class="hljs-keyword">if</span> (x-&gt;r-&gt;prior &gt; x-&gt;prior) <span class="hljs-built_in">zag</span>(x);<br>&#125;<br><span class="hljs-built_in">update</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(pitem&amp; x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (y &lt; x-&gt;key) <span class="hljs-built_in">remove</span>(x-&gt;l, y);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y &gt; x-&gt;key) <span class="hljs-built_in">remove</span>(x-&gt;r, y);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (x-&gt;cnt &gt; <span class="hljs-number">1</span>) -- x-&gt;cnt;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!x-&gt;l) x = x-&gt;r;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!x-&gt;r) x = x-&gt;l;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">zag</span>(x);<br><span class="hljs-built_in">remove</span>(x-&gt;l, y);<br><span class="hljs-keyword">if</span> (x-&gt;l &amp;&amp; x-&gt;l-&gt;prior &gt; x-&gt;prior)<br><span class="hljs-built_in">zig</span>(x);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (x) <span class="hljs-built_in">update</span>(x);<br>&#125;<br><br><span class="hljs-function">pitem <span class="hljs-title">getPre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>pitem x = root, ans = <span class="hljs-keyword">new</span> <span class="hljs-built_in">item</span>(<span class="hljs-number">-1e9</span>);<br><span class="hljs-keyword">while</span> (x) &#123;<br><span class="hljs-keyword">if</span> (v == x-&gt;key) <br><span class="hljs-keyword">if</span> (x-&gt;l) &#123;<br>x = x-&gt;l;<br><span class="hljs-keyword">while</span> (x-&gt;r) x = x-&gt;r;<br>ans = x;<br>&#125;<br><span class="hljs-keyword">if</span> (x-&gt;key &lt; v &amp;&amp; x-&gt;key &gt; ans-&gt;key) <br>ans = x;<br>x = v &lt; x-&gt;key ? x-&gt;l : x-&gt;r;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">pitem <span class="hljs-title">getNxt</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>pitem x = root, ans = <span class="hljs-keyword">new</span> <span class="hljs-built_in">item</span>(<span class="hljs-number">1e9</span>);<br><span class="hljs-keyword">while</span> (x) &#123;<br><span class="hljs-keyword">if</span> (v == x-&gt;key) <br><span class="hljs-keyword">if</span> (x-&gt;r) &#123;<br>x = x-&gt;r;<br><span class="hljs-keyword">while</span> (x-&gt;l) x = x-&gt;l;<br>&#125;<br><span class="hljs-keyword">if</span> (x-&gt;key &gt; v &amp;&amp; x-&gt;key &lt; ans-&gt;key)<br>ans = x;<br>x = v &gt; x-&gt;key ? x-&gt;r : x-&gt;l;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValByRank</span><span class="hljs-params">(pitem&amp; x, <span class="hljs-type">int</span> rank)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!x) <span class="hljs-keyword">return</span> <span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">if</span> ((x-&gt;l ? x-&gt;l-&gt;size : <span class="hljs-number">0</span>) &gt;= rank)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">getValByRank</span>(x-&gt;l, rank);<br><span class="hljs-keyword">if</span> ((x-&gt;l ? x-&gt;l-&gt;size : <span class="hljs-number">0</span>) + x-&gt;cnt &gt;= rank) <br><span class="hljs-keyword">return</span> x-&gt;key;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">getValByRank</span>(x-&gt;r, rank - (x-&gt;l ? x-&gt;l-&gt;size : <span class="hljs-number">0</span>) - x-&gt;cnt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRankByVal</span><span class="hljs-params">(pitem&amp; x, <span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!x) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (v == x-&gt;key) <span class="hljs-keyword">return</span> (x-&gt;l ? x-&gt;l-&gt;size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (v &lt; x-&gt;key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">getRankByVal</span>(x-&gt;l, v);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">getRankByVal</span>(x-&gt;r, v) + (x-&gt;l ? x-&gt;l-&gt;size : <span class="hljs-number">0</span>) + x-&gt;cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快读快输">快读快输</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> IO &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>        T ret = <span class="hljs-number">0</span>, sig = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123; <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) sig = <span class="hljs-number">-1</span>; ch = <span class="hljs-built_in">getchar</span>(); &#125;<br>        <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) ret *= <span class="hljs-number">10</span>, ret += ch - <span class="hljs-number">48</span>, ch = <span class="hljs-built_in">getchar</span>();<br>        <span class="hljs-keyword">return</span> ret * sig;<br>    &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(T out)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!out) &#123; <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>), <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-keyword">return</span>; &#125;<br>        <span class="hljs-type">int</span> stk[<span class="hljs-number">100</span>], tt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(out &lt; <span class="hljs-number">0</span>) out = -out, <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        <span class="hljs-keyword">while</span>(out) stk[tt++] = out % <span class="hljs-number">10</span>, out /= <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = --tt; i&gt;=<span class="hljs-number">0</span>; --i) <span class="hljs-built_in">putchar</span>(stk[i] + <span class="hljs-number">48</span>);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T&amp; ret)</span> </span>&#123; ret = IO::<span class="hljs-built_in">read</span>&lt;T&gt;(); &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x, Args&amp;... args)</span> </span>&#123; IO::<span class="hljs-built_in">read</span>(x), IO::<span class="hljs-built_in">read</span>(args...); &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(T x, Args... args)</span>  </span>&#123; IO::<span class="hljs-built_in">write</span>(x), IO::<span class="hljs-built_in">write</span>(args...); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="封装的高精度">封装的高精度</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bigint</span> &#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; num;<br>    <br>    <span class="hljs-built_in">Bigint</span>() &#123;&#125;<br>    <br>    <span class="hljs-built_in">Bigint</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* x) &#123;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(x);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; -- i) &#123;<br>            num.<span class="hljs-built_in">push_back</span>(x[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-built_in">Bigint</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-type">char</span> tmp[<span class="hljs-number">100</span>];<br>        <span class="hljs-built_in">sprintf</span>(tmp, <span class="hljs-string">&quot;%d&quot;</span>, x);<br>        *<span class="hljs-keyword">this</span> = tmp;<br>    &#125;<br> <br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="hljs-type">const</span> Bigint x) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (<span class="hljs-type">int</span>) x.num.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; -- i) &#123;<br>            os &lt;&lt; x.num[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> os;<br>    &#125;<br> <br>    <span class="hljs-keyword">friend</span> std::istream&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (std::istream&amp; is, Bigint&amp; x) &#123;<br>        std::string str;<br>        is &gt;&gt; str;<br><br>        x = str.<span class="hljs-built_in">c_str</span>();<br><br>        <span class="hljs-keyword">return</span> is;<br>    &#125;<br>    <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    Bigint <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> T rst) &#123;<br>        Bigint res, x = rst;<br><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num.<span class="hljs-built_in">size</span>() || i &lt; x.num.<span class="hljs-built_in">size</span>(); ++ i) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; num.<span class="hljs-built_in">size</span>()) t += num[i];<br>            <span class="hljs-keyword">if</span> (i &lt; x.num.<span class="hljs-built_in">size</span>()) t += x.num[i];<br><br>            res.num.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (t) &#123;<br>            res.num.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (res.num.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; res.num.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) &#123;<br>            res.num.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    Bigint <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> <span class="hljs-type">int</span> rst) &#123;<br>        Bigint res, x = rst;<br><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : num) &#123;<br>            t += x * rst;<br>            res.num.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (t) &#123;<br>            res.num.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (res.num.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; res.num.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) &#123;<br>            res.num.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    Bigint <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> T rst) &#123;<br>        Bigint res = <span class="hljs-number">0</span>, x = rst;<br><br>        std::<span class="hljs-built_in">reverse</span>(x.num.<span class="hljs-built_in">begin</span>(), x.num.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : x.num) &#123;<br>            res = res * <span class="hljs-number">10</span> + *<span class="hljs-keyword">this</span> * i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br> <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    Bigint&amp; <span class="hljs-keyword">operator</span> *= (<span class="hljs-type">const</span> T rst) &#123;<br>        *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> * rst;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <br>    Bigint&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> T rst) &#123;<br>        *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> + rst;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (T rst) &#123;<br>        Bigint x = rst;<br><br>        <span class="hljs-keyword">if</span> (num.<span class="hljs-built_in">size</span>() != x.num.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> num.<span class="hljs-built_in">size</span>() &lt; x.num.<span class="hljs-built_in">size</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = num.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; -- i)<br>                <span class="hljs-keyword">if</span> (num[i] != x.num[i])<br>                    <span class="hljs-keyword">return</span> num[i] &lt; x.num[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (T rst) &#123;<br>        Bigint x = rst;<br>        <span class="hljs-keyword">return</span> num == x.num;<br>    &#125;<br> <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt; (T rst) &#123;<br>        Bigint x = rst;<br>        <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == x || *<span class="hljs-keyword">this</span> &lt; x);<br>    &#125;<br> <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;= (T rst) &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> == rst || *<span class="hljs-keyword">this</span> &lt; rst;<br>    &#125;<br> <br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt;= (T rst) &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> == rst || !(*<span class="hljs-keyword">this</span> &lt; rst);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>莫比乌斯反演 &amp; 数论函数 学习笔记</title>
    <link href="/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这是以前学信息学奥林匹克竞赛时候的博客文章(2022-05-05)，现在重新学习并勘误。</p><p>这部分的内容也许是数论里面比较有意思的？看 vflreaking 大佬的《炫酷反演魔术》，觉得反演很有趣，就浅浅地学了一下。</p><span id="more"></span><p>下文中 <span class="math inline">\((a, b)\)</span> 用来表示 <spanclass="math inline">\(\gcd(a,b)\)</span>，或者表示开区间，视情况而定</p><h1 id="莫比乌斯反演">莫比乌斯反演</h1><blockquote><p>莫比乌斯反演是数论中的重要内容。对于一些函数 <spanclass="math inline">\(f(n)\)</span>，如果很难直接求出它的值，而容易求出其倍数或约数和<spanclass="math inline">\(g(n)\)</span>，那么就可以通过莫比乌斯反演简化运算，求得<span class="math inline">\(f(n)\)</span> 的值。 —— OI Wiki</p></blockquote><h2 id="前置知识">前置知识</h2><h3 id="整除分块">整除分块</h3><p><strong>整除分块</strong> 用来快速求解形如 <spanclass="math inline">\(\sum_{i = 1}^n \lfloor \frac{n}{i}\rfloor\)</span> 的式子。</p><p>显然，我们可以直接暴力枚举，<span class="math inline">\(O(n)\)</span>地求解，已经不算慢了，但是有些毒瘤题的数据规模太大，这就推动我们想出来更加优秀的算法，利用整除分块求解的时间复杂度是<span class="math inline">\(O(\sqrt n)\)</span>。</p><p>我们首先暴力枚举一个比较小的数，比如 <spanclass="math inline">\(25\)</span>，研究 <spanclass="math inline">\(\lfloor \frac{n}{i} \rfloor\)</span> 的取值。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tap">i = 1,<span class="hljs-number"> 25 </span>/<span class="hljs-number"> 1 </span>= 25<br>i = 2,<span class="hljs-number"> 25 </span>/<span class="hljs-number"> 2 </span>= 12<br>i = 3,<span class="hljs-number"> 25 </span>/<span class="hljs-number"> 3 </span>= 8<br>i = 4,<span class="hljs-number"> 25 </span>/<span class="hljs-number"> 4 </span>= 6<br>i = 5,<span class="hljs-number"> 25 </span>/<span class="hljs-number"> 5 </span>= 5<br>i = 6,<span class="hljs-number"> 25 </span>/<span class="hljs-number"> 6 </span>= 4<br>i = 7,<span class="hljs-number"> 25 </span>/<span class="hljs-number"> 7 </span>= 3<br>i = 8,<span class="hljs-number"> 25 </span>/<span class="hljs-number"> 8 </span>= 3<br>i = 9,<span class="hljs-number"> 25 </span>/<span class="hljs-number"> 9 </span>= 2<br>...<br>i = 12,<span class="hljs-number"> 25 </span>/<span class="hljs-number"> 12 </span>= 2<br>i = 13,<span class="hljs-number"> 25 </span>/<span class="hljs-number"> 13 </span>= 1<br>...<br>i = 25,<span class="hljs-number"> 25 </span>/<span class="hljs-number"> 25 </span>= 1<br></code></pre></td></tr></table></figure><p>注意到，<span class="math inline">\(\lfloor \frac{25}{i}\rfloor\)</span> 仅有 <span class="math inline">\(9 \le 2\lfloor\sqrt{25} \rfloor\)</span>种取值。对于其它的情况，取值的数量也都大致小于等于 <spanclass="math inline">\(2 \lfloor \sqrt{n} \rfloor\)</span> 种。</p><p>因为有很多块的取值都相等，因此我们研究每一块取值的界限。</p><h4 id="结论">结论</h4><p>设两个正整数 <span class="math inline">\(i, j \quad (i \le j \len)\)</span>，使得 <span class="math inline">\(\lfloor \frac{n}{i}\rfloor = \lfloor \frac{n}{j} \rfloor\)</span> 成立，我们有 <spanclass="math inline">\(j\)</span> 的最大值为 <spanclass="math inline">\(\left \lfloor \frac{n}{\left \lfloor \frac{n}{i}\right \rfloor} \right \rfloor\)</span>。</p><p><strong>证明</strong>：</p><p>设 <span class="math inline">\(k = \left \lfloor \frac{n}{i} \right\rfloor\)</span>，有 <span class="math inline">\(k \le\frac{n}{i}\)</span>。</p><p>所以， <span class="math inline">\(\left \lfloor \frac{n}{k} \right\rfloor \ge \left \lfloor \frac{n}{\frac{n}{i}} \right \rfloor = \left\lfloor i \right \rfloor = i\)</span>。</p><p>因此，<span class="math inline">\(j = i_\text{max} = \left \lfloor\frac{n}{k} \right \rfloor = \left \lfloor \frac{n}{\left \lfloor\frac{n}{i} \right \rfloor} \right \rfloor\)</span>。</p><p><strong>代码实现</strong> (求解 <span class="math inline">\(\sum_{i =1}^n  \left \lfloor \frac{n}{i} \right \rfloor\)</span>)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">i64 <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    i64 res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r;<br>    <span class="hljs-keyword">while</span> (l &lt;= n) &#123;<br>        r = n / (n / l);<br>        res += (r - l + <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * (n / l);<br>        l = r + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="应用">应用</h4><ol type="1"><li><p>求 <span class="math inline">\(\sum_{i = 1}^n k \bmodi\)</span>。 ([<a href="http://www.luogu.com.cn/problem/P2261">CQOI2007] 余数求和</a>)</p><p>注意到，<span class="math inline">\(k \bmod i = k - i \left \lfloor\frac{k}{i} \right \rfloor\)</span>。</p><p>于是，原式化为 <span class="math inline">\(\sum_{i = 1}^n (k - i\left \lfloor \frac{k}{i} \right \rfloor) = kn - \sum_{i = 1}^n i \left\lfloor \frac{k}{i} \right \rfloor\)</span>。</p><p>注意，和式 <span class="math inline">\(\sum_{i = 1}^n i \left \lfloor\frac{k}{i} \right \rfloor\)</span> 与 <spanclass="math inline">\(\sum_{i = 1}^n \left \lfloor \frac{k}{i} \right\rfloor\)</span> 仅有一个 <span class="math inline">\(i\)</span>之差，而第二个和式利用整除分块很容易得到。</p><p>我们研究 <span class="math inline">\(\left \lfloor \frac{k}{i} \right\rfloor\)</span> 的取值中的某一块区间 <span class="math inline">\([l,r]\)</span>： <span class="math display">\[\begin{align}\sum_{i = l}^r i \left \lfloor \frac{k}{i} \right \rfloor &amp;= l \left\lfloor \frac{k}{l} \right \rfloor + (l + 1) \left \lfloor \frac{k}{l}\right \rfloor + \dots + r \left \lfloor \frac{k}{l} \right \rfloor \\\\&amp;=  \left \lfloor \frac{k}{l} \right \rfloor \sum_{i = l}^r i\end{align}\]</span> 因此，我们只需要求出 <span class="math inline">\(i\)</span>的前缀和，就可以求解了。</p><p>对于更加一般的情况，<span class="math inline">\(\sum_{i = 1}^nf(i)  \left \lfloor \frac{k}{i} \right \rfloor\)</span>，当可以 <spanclass="math inline">\(O(1)\)</span> 或 预处理 出 <spanclass="math inline">\(f(r) - f(l)\)</span> 时，就可以利用整除分块 <spanclass="math inline">\(O(\sqrt n)\)</span> 地求解。</p><p><strong>代码实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br>i64 n, k;<br><br><span class="hljs-function">i64 <span class="hljs-title">sum</span><span class="hljs-params">(i64 l, i64 r)</span> </span>&#123; <span class="hljs-keyword">return</span> r * (r + <span class="hljs-number">1</span>) - l * (l - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>; &#125;<br><br><span class="hljs-function">i64 <span class="hljs-title">calc</span><span class="hljs-params">()</span> </span>&#123;<br>    i64 res = <span class="hljs-number">0</span>;<br>    i64 l = <span class="hljs-number">1</span>, r;<br>    <span class="hljs-keyword">while</span> (l &lt;= n &amp;&amp; k / l) &#123;<br>        r = std::<span class="hljs-built_in">min</span>(k / (k / l), n);<br>        res += (k / l) * <span class="hljs-built_in">sum</span>(l, r);<br>        l = r + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin &gt;&gt; n &gt;&gt; k;<br>    std::cout &lt;&lt; n * k - <span class="hljs-built_in">calc</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>求 <span class="math inline">\(\sum_{i = 1}^n \sum_{j = 1}^m [i\neq j](n \bmod i)(m \bmod j) \quad (n &lt; m)\)</span>。 (<ahref="http://www.luogu.com.cn/problem/P2260">[清华集训 2012]模积和</a>)</p><p>同理，原式化为 <span class="math display">\[\begin{align*}\sum_{i = 1}^n \sum_{j = 1}^m [i \neq j](n - i \lfloor\frac{n}{i}  \rfloor)(m - j \lfloor \frac{m}{j} \rfloor) &amp;= \sum_{i= 1}^n \sum_{j = 1}^m (n - i \lfloor \frac{n}{i}  \rfloor)(m - j \lfloor\frac{m}{j} \rfloor) - \sum_{i = 1}^n(n - i \lfloor\frac{n}{i}  \rfloor)(m - i \lfloor \frac{m}{i} \rfloor) \\\\&amp;= \sum_{i = 1}^n (n - i \lfloor \frac{n}{i}  \rfloor) \sum_{j =1}^m (m - j \lfloor \frac{m}{j} \rfloor) - \sum_{i = 1}^n(n - i \lfloor\frac{n}{i}  \rfloor)(m - i \lfloor \frac{m}{i} \rfloor)\end{align*}\]</span></p><p>设 <span class="math inline">\(f(n) = \sum_{i = 1}^n (n - i \lfloor\frac{n}{i}  \rfloor) = n^2 - \sum_{i = 1}^n i \lfloor \frac{n}{i}\rfloor\)</span>，所以前半部分可以用整除分块求解。</p><p>对于后半部分， <span class="math display">\[\begin{align*}\sum_{i = 1}^n(n - i \lfloor \frac{n}{i}  \rfloor)(m - i \lfloor\frac{m}{i} \rfloor) &amp;= \sum_{i = 1}^n (nm - mi \lfloor \frac{n}{i}\rfloor - ni \lfloor \frac{m}{i} \rfloor + i^2 \lfloor \frac{n}{i}\rfloor \lfloor \frac{m}{i} \rfloor) \\\\&amp;= n^2m - m \sum_{i = 1}^n i \lfloor \frac{n}{i} \rfloor - n\sum_{i= 1}^n i \lfloor \frac{m}{i} \rfloor + \sum_{i = 1}^n i^2 \lfloor\frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor\end{align*}\]</span> 剩下的只有 <span class="math inline">\(\sum_{i = 1}^n i^2\lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor\)</span>求起来比较麻烦了，不难发现这个式子和普通的整除分块长得很像，所以它很有可能有类似<span class="math inline">\(\sum_{i = 1}^n i \lfloor \frac{n}{i}\rfloor\)</span> 的性质。</p><p>同样，我们还是先暴力枚举一个比较小的数，探究其性质，比如 <spanclass="math inline">\(n = 10, m = 15\)</span>。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">i</span> = <span class="hljs-number">1</span>, (<span class="hljs-number">10</span> / <span class="hljs-number">1</span>) * (<span class="hljs-number">15</span> / <span class="hljs-number">1</span>) = <span class="hljs-number">150</span><br><span class="hljs-attribute">i</span> = <span class="hljs-number">2</span>, (<span class="hljs-number">10</span> / <span class="hljs-number">2</span>) * (<span class="hljs-number">15</span> / <span class="hljs-number">2</span>) = <span class="hljs-number">35</span><br><span class="hljs-attribute">i</span> = <span class="hljs-number">3</span>, (<span class="hljs-number">10</span> / <span class="hljs-number">3</span>) * (<span class="hljs-number">15</span> / <span class="hljs-number">3</span>) = <span class="hljs-number">15</span><br><span class="hljs-attribute">i</span> = <span class="hljs-number">4</span>, (<span class="hljs-number">10</span> / <span class="hljs-number">4</span>) * (<span class="hljs-number">15</span> / <span class="hljs-number">4</span>) = <span class="hljs-number">6</span><br><span class="hljs-attribute">i</span> = <span class="hljs-number">5</span>, (<span class="hljs-number">10</span> / <span class="hljs-number">5</span>) * (<span class="hljs-number">15</span> / <span class="hljs-number">5</span>) = <span class="hljs-number">6</span><br><span class="hljs-attribute">i</span> = <span class="hljs-number">6</span>, (<span class="hljs-number">10</span> / <span class="hljs-number">6</span>) * (<span class="hljs-number">15</span> / <span class="hljs-number">6</span>) = <span class="hljs-number">2</span><br><span class="hljs-attribute">i</span> = <span class="hljs-number">7</span>, (<span class="hljs-number">10</span> / <span class="hljs-number">7</span>) * (<span class="hljs-number">15</span> / <span class="hljs-number">7</span>) = <span class="hljs-number">2</span><br><span class="hljs-attribute">i</span> = <span class="hljs-number">8</span>, (<span class="hljs-number">10</span> / <span class="hljs-number">8</span>) * (<span class="hljs-number">15</span> / <span class="hljs-number">8</span>) = <span class="hljs-number">1</span><br><span class="hljs-attribute">i</span> = <span class="hljs-number">9</span>, (<span class="hljs-number">10</span> / <span class="hljs-number">9</span>) * (<span class="hljs-number">15</span> / <span class="hljs-number">9</span>) = <span class="hljs-number">1</span><br><span class="hljs-attribute">i</span> = <span class="hljs-number">10</span>, (<span class="hljs-number">10</span> / <span class="hljs-number">10</span>) * (<span class="hljs-number">15</span> / <span class="hljs-number">10</span>) = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>发现它也是成块的，经过多次的打表，观察，我们不难发现它的右端点是各个一维的块的最小值(形象的说明可以参考OIWiki的讲解)，即它的右端点是 <span class="math inline">\(\min(\left\lfloor \frac{n}{\left \lfloor \frac{n}{i} \right \rfloor} \right\rfloor, \left \lfloor \frac{m}{\left \lfloor \frac{m}{i} \right\rfloor} \right \rfloor)\)</span>。</p><p>一般的，<span class="math inline">\(n\)</span>维数论分块的表达式从一维的 <span class="math inline">\(\left \lfloor\frac{n}{i} \right \rfloor\)</span> 变为了 <spanclass="math inline">\(\displaystyle{\min_{j = 1}^n\{ \left \lfloor\frac{a_j}{i} \right \rfloor \}}\)</span>。</p><p><strong>代码实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-type">const</span> i64 MOD = <span class="hljs-number">19940417</span>;<br><span class="hljs-type">const</span> i64 inv2 = <span class="hljs-number">9970209</span>, inv6 = <span class="hljs-number">3323403</span>;<br><br><span class="hljs-function">i64 <span class="hljs-title">s</span><span class="hljs-params">(i64 l, i64 r)</span> </span>&#123; <span class="hljs-keyword">return</span> (r * (r + <span class="hljs-number">1</span>) % MOD - l * (l - <span class="hljs-number">1</span>) % MOD) % MOD * inv2 % MOD; &#125;<br><span class="hljs-function">i64 <span class="hljs-title">S</span><span class="hljs-params">(i64 n)</span> </span>&#123; <span class="hljs-keyword">return</span> n * (n + <span class="hljs-number">1</span>) % MOD * (n + n + <span class="hljs-number">1</span>) % MOD * inv6 % MOD; &#125;<br><br><span class="hljs-function">i64 <span class="hljs-title">C</span><span class="hljs-params">(i64 n, i64 k)</span> </span>&#123;<br>    i64 res = <span class="hljs-number">0</span>, l = <span class="hljs-number">1</span>, r;<br>    <span class="hljs-keyword">while</span> (l &lt;= n) &#123;<br>        r = std::<span class="hljs-built_in">min</span>(k / (k / l), n);<br>        res = (res + (k / l) * <span class="hljs-built_in">s</span>(l, r) % MOD) % MOD;<br>        l = r + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res % MOD;<br>&#125;<br><br><span class="hljs-function">i64 <span class="hljs-title">C_2</span><span class="hljs-params">(i64 n, i64 k1, i64 k2)</span> </span>&#123;<br>    i64 res = <span class="hljs-number">0</span>, l = <span class="hljs-number">1</span>, r; <br>    <span class="hljs-keyword">while</span> (l &lt;= n) &#123;<br>        r = std::<span class="hljs-built_in">min</span>(k1 / (k1 / l), k2 / (k2 / l));<br>        res = (res + (k1 / l) * (k2 / l) % MOD * (<span class="hljs-built_in">S</span>(r) - <span class="hljs-built_in">S</span>(l - <span class="hljs-number">1</span>))) % MOD;<br>        l = r + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res % MOD;<br>&#125;<br><br><span class="hljs-function">i64 <span class="hljs-title">f</span><span class="hljs-params">(i64 n)</span> </span>&#123; <span class="hljs-keyword">return</span> (n * n - <span class="hljs-built_in">C</span>(n, n)) % MOD; &#125;<br><br>i64 n, m;<br>i64 res;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">if</span> (n &gt; m) std::<span class="hljs-built_in">swap</span>(n, m);<br>    res = <span class="hljs-built_in">f</span>(n) * <span class="hljs-built_in">f</span>(m) % MOD;<br>    res = (res + n * <span class="hljs-built_in">C</span>(n, m) + m * <span class="hljs-built_in">C</span>(n, n)) % MOD;<br>    res = (res - n * n % MOD * m) % MOD;<br>    res = (res - <span class="hljs-built_in">C_2</span>(n, n, m)) % MOD;<br>    std::cout &lt;&lt; (res % MOD + MOD) % MOD &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="数论函数">数论函数</h3><h4 id="定义">定义</h4><p>定义域为整数，陪域为复数的函数，即 <span class="math inline">\(f:\mathbb{Z}^+ \to \mathbb{C}\)</span>。</p><h4 id="常见的数论函数">常见的数论函数</h4><ul><li><span class="math inline">\(I(n)\)</span><strong>恒等函数</strong>，即对于任意整数 <spanclass="math inline">\(n\)</span>，<spanclass="math inline">\(I(n)\)</span> 值为 <spanclass="math inline">\(1\)</span>。(完全积性)</li><li><span class="math inline">\(\varepsilon(n)\)</span><strong>元函数</strong>，当 <span class="math inline">\(n = 1\)</span>时，函数值为 <span class="math inline">\(1\)</span>，否则为 <spanclass="math inline">\(0\)</span>。 (完全积性)</li><li><span class="math inline">\(id(n)\)</span><strong>单位函数</strong>，<span class="math inline">\(id(n) =n\)</span>。(完全积性)</li><li><span class="math inline">\(\varphi(n)\)</span><strong>欧拉函数</strong>，小于等于 <spanclass="math inline">\(n\)</span> 的正整数中，与 <spanclass="math inline">\(n\)</span> 互质的数的个数。</li><li><span class="math inline">\(\mu(n)\)</span><strong>莫比乌斯函数</strong>，与非平方数的质因子数目有关。</li></ul><p>其中这些数论函数均为 <strong>积性函数</strong>，即一个定义域为正整数<span class="math inline">\(n\)</span> 的数论函数 <spanclass="math inline">\(f(n)\)</span>，性质如下: <spanclass="math inline">\(f(1) = 1\)</span>，且 <spanclass="math inline">\((a, b) = 1\)</span> 时，<spanclass="math inline">\(f(ab) = f(a)f(b)\)</span>。若不限 <spanclass="math inline">\((a, b) = 1\)</span> 时，则称此函数为<strong>完全积性函数</strong>。</p><h3 id="狄利克雷卷积">狄利克雷卷积</h3><h4 id="定义-1">定义</h4><p>对于两个数论函数 <span class="math inline">\(f,g\)</span>，定义其狄利克雷卷积 <span class="math inline">\((f*g)(n) =\displaystyle{\sum_{d \mid n}f(d)g(\frac{n}{d})} =\displaystyle{\sum_{ab = n}{f(a)g(b)}}\)</span></p><h4 id="性质">性质</h4><ul><li><strong>交换律</strong> <span class="math inline">\(f * g = g *f\)</span></li><li><strong>结合律</strong> <span class="math inline">\((f * g) * h = f* (g * h)\)</span></li><li><strong>分配律</strong> <span class="math inline">\(f * (g + h) = f* g + f * h = (g + h) * f\)</span></li><li><strong>单位元</strong> 单位函数 <spanclass="math inline">\(\varepsilon\)</span>是狄利克雷卷积运算中的单位元，即对于任意数论函数 <spanclass="math inline">\(f\)</span> ，存在一个单位元 <spanclass="math inline">\(\varepsilon\)</span>，使得 <spanclass="math inline">\(f * \varepsilon = f\)</span>。</li><li><strong>逆元</strong> 对于任何一个满足 <spanclass="math inline">\(f(x) \neq 0\)</span>的数论函数，如果有另一个数论函数 <spanclass="math inline">\(g(x)\)</span> 满足 <span class="math inline">\(f *g = \varepsilon\)</span>，则称 <span class="math inline">\(g(x)\)</span>是 <span class="math inline">\(f(x)\)</span> 的逆元。逆元是唯一的。</li></ul><h4 id="重要结论">重要结论</h4><ul><li><p><strong>两个积性函数的狄利克雷卷积也是积性函数</strong></p><p><strong>证明</strong>：设两个积性函数为 <spanclass="math inline">\(f(x), g(x)\)</span>，记 <spanclass="math inline">\(h = f * g\)</span>。</p><p>设 <span class="math inline">\((a, b) = 1\)</span>，则有： <spanclass="math display">\[\begin{align*}h(a)h(b) &amp;= \sum_{d_1 \mid a} f(d_1)g(\frac{a}{d_1}) \cdot \sum_{d_2\mid b} f(d_2)g(\frac{b}{d_2}) \\\\&amp;=\sum_{d_1 \mid a}\sum_{d_2 \midb}f(d_1)g(\frac{a}{d_1})f(d_2)g(\frac{b}{d_2}) \\\\&amp;= \sum_{d_1 d_2 \mid ab}f(d_1 d_2)g(d_1 d_2)\end{align*}\]</span> 得证。</p></li><li><p><strong>积性函数的逆元也是积性函数</strong></p><p><strong>证明</strong>：设两个积性函数 <span class="math inline">\(f *g = \varepsilon\)</span>。考虑数学归纳法：</p><p>我们要证明 <span class="math inline">\(\forall (a, b) = 1,\quad g(ab)= g(a)g(b)\)</span></p><ol type="1"><li><p><span class="math inline">\(ab = 1\)</span></p><p>当 <span class="math inline">\(a = b = 1\)</span> 时，<spanclass="math inline">\(\varepsilon(1) = 1 = f(1)g(1)\)</span>。</p><p>由于积性，<span class="math inline">\(f(1) = 1\)</span>，所以也有<span class="math inline">\(g(1) = 1\)</span>。</p><p>对于该种情况，显然有 <span class="math inline">\(g(1) =g(1)g(1)\)</span> 成立。</p></li><li><p><span class="math inline">\(ab &gt; 1, (a, b) = 1\)</span></p><p>我们假设已经证明 <span class="math inline">\(a&#39;b&#39; &lt;ab\)</span> 时，结论成立。 <span class="math display">\[\begin{align*}g(ab) &amp;= \sum_{d \mid ab}f(d)g(\frac{ab}{d}) - \sum_{d \mid ab, d\neq 1}f(d)g(\frac{ab}{d}) \\\\&amp;= \varepsilon(ab) - \sum_{d \mid ab, d \neq 1}f(d)g(\frac{ab}{d})\\\\&amp;= - \sum_{d \mid ab, d \neq 1} f(d)g(\frac{ab}{d}) \\\\&amp;= - \sum_{d_1 \mid a, d_2 \mid b, d_1 d_2 \neq1}f(d_1d_2)g(\frac{ab}{d_1d_2}) \\\\\end{align*}\]</span> 根据上文假设 <span class="math inline">\(a&#39;b&#39; &lt;ab\)</span> 时，结论成立，有： <span class="math display">\[\begin{align*}g(ab) &amp;= - \sum_{d_1 \mid a, d_2 \mid b, d_1 d_2 \neq1}f(d_1)g(\frac{ab}{d_1})f(d_2)g(\frac{ab}{d_2}) \\\\&amp;= - \sum_{d_1 \mid a}f(d_1)g(\frac{a}{d_1})\sum_{d_2 \mid b, d_1d_2 \neq 1}f(d_2)g(\frac{b}{d_2}) \\\\&amp;= f(1)f(1)g(a)g(b) - \sum_{d_1 \mida}f(d_1)g(\frac{a}{d_1})\sum_{d_2 \mid b}f(d_2)g(\frac{b}{d_2}) \\\\&amp;= g(a)g(b) - \varepsilon(a)\varepsilon(b) \\\\&amp;= g(a)g(b)\end{align*}\]</span> 得证。</p></li></ol></li></ul><h2 id="正式讲解">正式讲解</h2><h3 id="引入">引入</h3><p><strong>—— 推导莫比乌斯函数</strong></p><p>设两个单变量函数 <span class="math inline">\(f(x), g(x)\)</span>有关系表示为 <span class="math inline">\(f(x) = \sum_{d \midx}g(d)\)</span></p><p>显然，有 <span class="math inline">\(f(x) = \sum_{d \mid x}I \cdotg(d)\)</span>，即函数 <span class="math inline">\(f\)</span> 为 元函数<span class="math inline">\(I\)</span> 和 函数 <spanclass="math inline">\(g\)</span> 的卷积 (<span class="math inline">\(f =I * g\)</span>)</p><p>有上述公式，如果可以求出 <span class="math inline">\(g\)</span>的我们可以很容易推出 <span class="math inline">\(f\)</span>。</p><p>但是，有没有一种方法根据 <span class="math inline">\(f\)</span> 求出<span class="math inline">\(g\)</span> 呢？</p><p>我们把等式两边同时乘以 <spanclass="math inline">\(I^{-1}\)</span>，得 <span class="math display">\[g = I^{-1} * f\]</span> 于是，只要我们有函数 <spanclass="math inline">\(I^{-1}\)</span>，一切就简单明了了。</p><p>这个函数 <span class="math inline">\(I^{-1}\)</span> 即为莫比乌斯函数<span class="math inline">\(\mu\)</span></p><p>显然，<span class="math inline">\(\mu\)</span>为积性函数，我们研究它在 <strong>质数的幂</strong> 时的表现：</p><p>我们假设有一正整数 <span class="math inline">\(p\)</span>，<spanclass="math inline">\(\forall n \in (1, p), (n, p) =1\)</span>，又有一正整数 <span class="math inline">\(k\)</span>。</p><ol type="1"><li><p>当 <span class="math inline">\(k = 0\)</span> 时，显然有 <spanclass="math inline">\(\mu(p^0) = \mu(1) = 1\)</span></p></li><li><p>当 <span class="math inline">\(k = 1\)</span> 时，有 <spanclass="math inline">\(\sum_{d \mid p}I(d) \cdot \mu(\frac{p}{d}) =\varepsilon(p) = 0\)</span></p><p>注意到 <span class="math inline">\(p\)</span>为质数，可以把和式化为： <span class="math display">\[\begin{align}I(p)\mu(1) + I(1)\mu(p)&amp;= \mu(1) + \mu(p) \\\\&amp;= 1 + \mu(p) \\\\&amp;= \varepsilon(p) \\\\&amp;= 0\end{align}\]</span> 因此有 <span class="math inline">\(\mu(p) =-1\)</span></p></li><li><p>当 <span class="math inline">\(k &gt; 1\)</span> 时，有 <spanclass="math inline">\(\sum_{d \mid p^k}I(d)\mu(\frac{p^k}{d}) =\varepsilon(p^k) = 0\)</span></p><p>注意到 <span class="math inline">\(p\)</span>为质数，可以把和式化为： <span class="math display">\[\begin{align}I(p^k)\mu(1) + I(p^{k - 1})\mu(p^1) + \dots + I(1)\mu(p^k)&amp;= \mu(1) + \mu(p^1) + \dots + \mu(p^k) \\\\&amp;= 1 - 1 + \mu(p^2) + \dots + \mu(p^k) \\\\&amp;= \mu(p^2) + \mu(p^3) + \dots + \mu(p^k)\end{align}\]</span> 考虑使用数学归纳法：</p><ol type="1"><li>当 <span class="math inline">\(k = 2\)</span> 时，得 <spanclass="math inline">\(\mu(p^2) = 0\)</span></li><li>当 <span class="math inline">\(k = 3\)</span> 时，得 <spanclass="math inline">\(\mu(p^2) + \mu(p^3) = 0\)</span>，即 <spanclass="math inline">\(\mu(p^3) = 0\)</span></li><li>当 <span class="math inline">\(k &gt; 3\)</span> 时，同理。</li></ol><p>由此，我们证明 <span class="math inline">\(k &gt; 1\)</span>时，<span class="math inline">\(\mu(p^k) = 0\)</span>。</p><p>注意到 <span class="math inline">\(\mu\)</span> 为积性函数，因此有<span class="math inline">\(\mu(p_1^{k_1}p_2^{k_3} \dots p_n^{k_n}) =\mu(p_1^{k_1})\mu(p_2^{k_2}) \dots \mu(p_n^{k_n}) = 0\)</span></p><p>由此，显然有：</p><ol type="1"><li><span class="math inline">\(k &gt; 1\)</span> 时，有 <spanclass="math inline">\(\mu(m) = 0\)</span></li><li><span class="math inline">\(\forall i \in [1, n], k_i = 1\)</span>时，有 <span class="math inline">\(\mu(m) = (-1)^n\)</span></li></ol></li></ol><p>根据上面的推导，我们就得到了 <span class="math inline">\(\mu\)</span>的定义： <span class="math display">\[\mu(n) = \begin{cases}1 \qquad\qquad n\text{=}1 \\\\0 \qquad\qquad n\text{ 含有平方因子} \\\\(-1)^k \qquad k\text{ 为} n \text{的本质不同质因子个数}\end{cases}\]</span></p><h3 id="莫比乌斯变换">莫比乌斯变换</h3><p><strong>形式一</strong> 若有 <span class="math inline">\(f(n) =\sum_{d \mid n}g(d)\)</span>，则 <span class="math inline">\(g(n) =\sum_{d \mid n}\mu(d)f(\frac{n}{d})\)</span>。</p><p>根据上文的引入，<span class="math inline">\(\mu = I^{-1}\)</span>，有<span class="math inline">\(g * I = f\)</span>，所以有<spanclass="math inline">\(f * \mu = g\)</span>。</p><p>或者用和式的形式来证明</p><p><strong>证明</strong>： <span class="math display">\[\begin{align}  \sum_{d \mid n}\mu(d)f(\frac{n}{d}) &amp;= \sum_{d \midn}\mu(d)\sum_{t \mid \frac{n}{d}}g(t) \\\\  &amp;= \sum_{t \mid n}g(t)\sum_{d \mid \frac{n}{t}}\mu(d) \\\\  &amp;= \sum_{t \mid n}g(t) \varepsilon(\frac{n}{t}) \\\\  &amp;= \sum_{t \mid n}g(t)[\frac{n}{t} = 1] \\\\  &amp;= g(t)  \end{align}\]</span> 由此，得证。</p><p><strong>形式二</strong> 若有 <span class="math inline">\(f(n) =\sum_{n \mid d}g(d)\)</span>，则 <span class="math inline">\(g(n) =\sum_{n \mid d}\mu(\frac{d}{n})f(d)\)</span></p><p><strong>证明</strong>： <span class="math display">\[\begin{aligned}\sum_{n \mid d}{\mu(\frac{d}{n})f(d)} &amp;= \sum_{k=1}^{+\infty}{\mu(k)f(kn)} \\\\&amp;= \sum_{k=1}^{+ \infty}{\mu(k) \sum_{nk \mid d}{g(d)}} \\\\&amp;= \sum_{n \mid d}{g(d) \sum_{k|\frac{d}{n}}{\mu(k)}} \\\\&amp;= \sum_{n \mid d}{g(d) \varepsilon(\frac{d}{n})} \\\\&amp;= g(n)\end{aligned}\]</span></p><p>在第一步，我们用 <span class="math inline">\(nk\)</span> 表示了 <spanclass="math inline">\(d\)</span>，<span class="math inline">\(k\)</span>表示 <span class="math inline">\(n\)</span> 和 <spanclass="math inline">\(d\)</span>之间的倍数关系，我们通过枚举这些关系来代替枚举 <spanclass="math inline">\(n \mid d\)</span>。交换了和式之后我们枚举 <spanclass="math inline">\(n \mid d\)</span>，求出 <spanclass="math inline">\(k\)</span>。</p><h3 id="线性筛">线性筛</h3><p>由于积性函数的性质，基本所有的积性函数都可以用线性筛来求。这里我们可以用线性筛莫比乌斯函数。</p><p><strong>代码实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_mu</span><span class="hljs-params">()</span> </span>&#123;<br>    mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[++ cnt] = i, mu[i] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt &amp;&amp; primes[j] &lt;= n / i; ++ j) &#123;<br>            st[i * primes[j]] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) &#123;<br>                mu[i * primes[j]] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            mu[i * primes[j]] = - mu[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用-1">应用</h3><ol type="1"><li><p>求 <span class="math inline">\(\displaystyle{\sum_{i =1}^n\sum_{j = 1}^m[(i, j) = 1]}\)</span>。 (<ahref="http://cogs.pro:8081/cogs/problem/problem.php?pid=pxxmSzgqU">[HAOI2011] 问题B</a>，有简化)</p><p>利用 <strong>莫比乌斯反演 + 整除分块</strong> 我们可以用 <spanclass="math inline">\(O(\sqrt n)\)</span> 的时间复杂度求解。</p><p>注意到，<span class="math inline">\([(i, j) = 1] = \varepsilon((i,j)) = \sum_{d \mid (i, j)}\mu(d)\)</span>。因此该题等价于求 <spanclass="math display">\[\sum_{i = 1}^n \sum_{j = 1}^m \sum_{d \mid (i, j)}\mu(d)\]</span> 交换求和顺序，有 <span class="math display">\[\sum_{d = 1}\mu(d)\sum_{i = 1}^n[d \mid i]\sum_{j = 1}^m[d \mid j]\]</span> 注意到，<span class="math inline">\(1 \sim n\)</span> 中 <spanclass="math inline">\(d\)</span> 的倍数有 <spanclass="math inline">\(\lfloor \frac{n}{d} \rfloor\)</span> 个，因此<span class="math inline">\(\sum_{i = 1}^n[d \mid i] = \lfloor\frac{n}{d} \rfloor\)</span>，因此有 <span class="math display">\[\sum_{d = 1}^{\min(n, m)} \mu(d) \lfloor \frac{n}{d} \rfloor \lfloor\frac{m}{d} \rfloor\]</span> 接下来，就可以用 <strong>整除分块</strong> 来求解了。</p><p><strong>实现代码</strong>(仅保留核心部分)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">i64 <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    i64 res = <span class="hljs-number">0</span>, l = <span class="hljs-number">1</span>, r;<br>    <span class="hljs-keyword">while</span> (l &lt;= std::<span class="hljs-built_in">min</span>(n, m)) &#123;<br>        r = std::<span class="hljs-built_in">min</span>(n / (n / l), m / (m / l));<br>        res += (mu[r] - mu[l - <span class="hljs-number">1</span>]) * (n / l) * (m / l);<br>        l = r + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">get_mu</span>();<br>    <span class="hljs-built_in">rep</span> (i, <span class="hljs-number">2</span>, N) mu[i] += mu[i - <span class="hljs-number">1</span>];<br>    std::cout &lt;&lt; <span class="hljs-built_in">calc</span>(n, m) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>求 <span class="math inline">\(\displaystyle{\sum_{i =1}^{n}\sum_{j = 1}^m[(i, j) \in primes]}\)</span>。 (<ahref="http://cogs.pro:8081/cogs/problem/problem.php?pid=vNizzVkeg">[BZOJ2820] YY的GCD</a>)</p><p>原式可以化为 <span class="math display">\[\sum_{p \in primes}\sum_{i = 1}^n\sum_{j = 1}^m[(i, j) = p]\]</span> 注意到，<span class="math inline">\([(i, j) = p] = [\frac{(i,j)}{p} = 1] = [(\frac{i}{p}, \frac{j}{p}) =1]\)</span>，因此原式进一步化为 <span class="math display">\[\sum_{p \in primes}\sum_{i = 1}^n\sum_{j = 1}^m\sum_{d \mid(\frac{i}{p}, \frac{j}{p})}\mu(d)\]</span> 和 <span class="math inline">\(1\)</span>题类似，我们交换求和顺序，有 <span class="math display">\[\sum_{p \in primes}\sum_{d = 1}\mu(d)\sum_{i = 1}^n[d \mid\frac{i}{p}]\sum_{j = 1}^m[d \mid \frac{j}{p}]\]</span> 注意到，<span class="math inline">\(1 \sim\frac{n}{p}\)</span> 中 <span class="math inline">\(d\)</span> 的倍数有<span class="math inline">\(\left \lfloor \frac{\frac{n}{p}}{d} \right\rfloor = \left \lfloor \frac{n}{dp} \right \rfloor\)</span> 个，因此有<span class="math display">\[\sum_{p \in primes}\sum_{d = 1}^{\min(\frac{n}{p}, \frac{m}{p})}\mu(d)\left \lfloor \frac{n}{dp} \right \rfloor\left \lfloor \frac{m}{dp}\right \rfloor\]</span> 令 <span class="math inline">\(t = dp\)</span>，我们在外层枚举<span class="math inline">\(t\)</span> <span class="math display">\[\sum_{t = 1}^{\min(n, m)} \left \lfloor \frac{n}{t} \right \rfloor\left\lfloor \frac{m}{t} \right \rfloor \sum_{p \in primes, p \mid t}\mu(\frac{t}{p})\]</span> 我们维护一个 <span class="math inline">\(\mu\)</span>的前缀和就可以了，具体来说，我们维护一个数组 <spanclass="math inline">\(S\)</span> ，枚举 <span class="math inline">\(p,t\)</span> ，如果 <span class="math inline">\(p \mid t\)</span> 就令<span class="math inline">\(S_k \gets S_k +\mu(\frac{t}{p})\)</span>，然后接下来就正常的维护前缀和就行了。</p><p>注意该题数据规模很大，需要进行一些优化(比如不该开 long long 的地方用int)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">i64 <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    i64 res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r;<br>    <span class="hljs-keyword">while</span> (l &lt;= std::<span class="hljs-built_in">min</span>(n, m)) &#123;<br>        r = std::<span class="hljs-built_in">min</span>(n / (n / l), m / (m / l));<br>        res += <span class="hljs-number">1LL</span> * (s[r] - s[l - <span class="hljs-number">1</span>]) * (n / l) * (m / l);<br>        l = r + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">get_mu</span>();<br>    <span class="hljs-built_in">rep</span> (i, <span class="hljs-number">1</span>, cnt) <br>        <span class="hljs-built_in">rep1</span>(j, primes[i], N, primes[i]) <br>            s[j] += mu[j / primes[i]]; <br>    <span class="hljs-built_in">rep</span> (i, <span class="hljs-number">2</span>, N) s[i] += s[i - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>(); <br>    t = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">while</span> (t --) &#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(), m = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">calc</span>(n, m));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="参考文献">参考文献</h2><p><ahref="http://oi-wiki.org/math/number-theory/sqrt-decomposition/">数论分块- OI Wiki</a></p><p><a href="http://www.cnblogs.com/henry-1202/p/10121854.html">数论分块- henry_y</a></p><p><a href="http://oi-wiki.org/math/number-theory/mobius/">莫比乌斯反演- OI Wiki</a></p><p><a href="http://oi-wiki.org/math/gen-func/dgf/#dirichlet">Dirichlet卷积 - OI Wiki</a></p><p><a href="http://zh.wikipedia.org/zh/狄利克雷摺積">狄利克雷摺积 -维基百科</a></p><p><ahref="http://zh.wikipedia.org/wiki/默比乌斯反演公式#定義">默比乌斯反演公式- 维基百科</a></p><p><a href="http://vfleaking.blog.uoj.ac/blog/87">炫酷反演魔术 -vfleaking的博客</a></p><p><ahref="http://www.luogu.com.cn/blog/command-block/zheng-chu-fen-kuai-ru-men-xiao-ji">整除分块入门小记- command_block 的博客</a></p><p><ahref="http://www.luogu.com.cn/blog/command-block/mu-bi-wu-si-fan-yan-ji-ji-ying-yong">莫比乌斯反演与数论函数- command_block 的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单源最短路径算法正确性的证明</title>
    <link href="/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E8%AF%81%E6%98%8E/"/>
    <url>/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E8%AF%81%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>最近复习以前学 OI时学习过的算法，发现以前学习的过程中对一些基础的算法只是会默写而不知其所以然，遂决定对一些算法的正确性参照《算法导论》进行证明。</p><span id="more"></span><h2 id="dijkstra-算法">Dijkstra 算法</h2><p>对于一个非负有向图 <span class="math inline">\(G = (V,E)\)</span>，有伪代码：</p><p><span class="math display">\[\begin{align}&amp; \text{DIJKSTRA($G$, $w$, $s$)} \\&amp; 1 \qquad \operatorname{INITIALIZE\_SINGLE\_SOURCE}(G, s) \\&amp; 2 \qquad S = \varnothing \\&amp; 3 \qquad Q = G.V \\&amp; 4 \qquad \textbf{while} \ Q \neq \varnothing \\&amp; 5 \qquad \qquad u = \operatorname{EXTRACT\_MIN}(Q) \\&amp; 6 \qquad \qquad S = S \ \cup \ \{u\} \\&amp; 7 \qquad \qquad \textbf{for} \ \text{each vertex } v \ \in \G.\text{Adj}[u] \\&amp; 8 \qquad \qquad \qquad \text{RELAX}(u, v, w)\end{align}\]</span></p><h3 id="证明">证明</h3><p><strong>循环不变式</strong> 在算法中 <spanclass="math inline">\(\textbf{while}\)</span>语句的每次迭代开始前，对于加入 <span class="math inline">\(S\)</span>的顶点 <span class="math inline">\(u\)</span>，有 <spanclass="math inline">\(u.d = \delta(s, u)\)</span>。其中 <spanclass="math inline">\(\delta(s, u)\)</span> 表示从源点 <spanclass="math inline">\(s\)</span> 到顶点 <spanclass="math inline">\(u\)</span> 的最短路径长度。</p><ol type="1"><li>初始时，<span class="math inline">\(S =\varnothing\)</span>，所以循环不变式直接成立。</li><li>利用反证法证明：<ol type="1"><li>假设结点 <span class="math inline">\(u\)</span> 是第一个满足 <spanclass="math inline">\(u.d \neq \delta(s, u)\)</span> 的结点，假设在<span class="math inline">\(s\)</span> 到 <spanclass="math inline">\(u\)</span> 的最短路径上存在一个结点 <spanclass="math inline">\(y \in V-S\)</span>，它的前驱中有 <spanclass="math inline">\(x \in S\)</span>，由于 <spanclass="math inline">\(x.d = \delta(s, x)\)</span>，边 <spanclass="math inline">\((x, y)\)</span> 会被松弛，所以 <spanclass="math inline">\(y.d\)</span> 会收敛为 <spanclass="math inline">\(y.d = \delta(s, y)\)</span>。<img src="https://cdn.jsdelivr.net/gh/lihaoze123/pic/IMG_20240820_173127.jpg" style="zoom:33%;" /></li><li>由于所有边权都是非负的，所以 <span class="math inline">\(y.d =\delta(s, y) \le \delta(s, u) \le u.d\)</span>。</li><li>由于在算法的第 <span class="math inline">\(5\)</span> 行中，<spanclass="math inline">\(u\)</span> 是 <span class="math inline">\(Q = V -S\)</span> 中 <span class="math inline">\(d\)</span> 值最小的结点，所以<span class="math inline">\(y.d \ge u.d\)</span>，所以 <spanclass="math inline">\(y.d = \delta(s, y) = \delta (s, u) =u.d\)</span>。</li><li>这与第一步的假设矛盾，所以不存在这样的结点 <spanclass="math inline">\(u\)</span>，所以循环不变式成立。</li></ol></li></ol><h3 id="c-实现">C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<br>    std::priority_queue&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, std::greater&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; q;<br><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [distance, t] = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span> (st[t]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        st[t] = <span class="hljs-literal">true</span>; <br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br><br>            <span class="hljs-keyword">if</span> (distance + w[i] &lt; dist[j]) &#123;<br>                dist[j] = distance + w[i];<br>                q.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="bellman-ford-算法">Bellman-Ford 算法</h2><p>对于一个有向图 <span class="math inline">\(G = (V,E)\)</span>，有伪代码： <span class="math display">\[\begin{align}&amp; \text{BELLMAN-FORD($G$, $w$, $s$)} \\&amp; 1 \qquad \operatorname{INITIALIZE\_SINGLE\_SOURCE}(G, s) \\&amp; 2 \qquad \textbf{for} \ i = 1 \ \textbf{to} \ |G.V| - 1 \\&amp; 3 \qquad \qquad \textbf{for} \ \text{each } \operatorname{edge}(u,v) \ \in \ G.E \\&amp; 4 \qquad \qquad \qquad \operatorname{RELAX}(u, v, w) \\&amp; 5 \qquad \textbf{for} \ \text{each } \operatorname{edge}(u, v) \\in \ G.E \\&amp; 6 \qquad \qquad \textbf{if} \ v.d &gt; u.d + w(u, v) \\&amp; 7 \qquad \qquad \qquad \textbf{return } \text{FALSE} \\&amp; 8 \qquad \textbf{return } \text{TRUE}\end{align}\]</span></p><h3 id="证明-1">证明</h3><p><strong>路径松弛性质</strong> 如果 <span class="math inline">\(p =\langle v_0, v_1, \cdots, v_k \rangle\)</span> 是从 <spanclass="math inline">\(v_0\)</span> 到 <spanclass="math inline">\(v_k\)</span> 的一条最短路径，并且我们对 <spanclass="math inline">\(p\)</span> 中的边进行松弛的次序为 <spanclass="math inline">\((v_0, v_1), (v_1, v_2), \cdots, (v_{k-1},v_k)\)</span>，则 <span class="math inline">\(v_k.d = \delta(v_0,v_k)\)</span>。</p><p>我们利用路径松弛性质来证明 Bellman-Ford 算法的正确性：<spanclass="math inline">\(p\)</span> 最多包含 <spanclass="math inline">\(|V| - 1\)</span> 条边，因此 <spanclass="math inline">\(k \le |V| - 1\)</span>，算法第 <spanclass="math inline">\(2 \sim 4\)</span> 行的循环每次松弛所有的边，在第<span class="math inline">\(i\)</span> 次松弛时一定包含边 <spanclass="math inline">\((v_{i - 1}, v_i)\)</span>。</p><h3 id="spfa-算法队列优化的-bellman-ford-算法">SPFA 算法（队列优化的Bellman-Ford 算法）</h3><p>在算法的第 <span class="math inline">\(2 \sim 4\)</span>行中，因为循环的是所有的边，考虑一条最短路径 <spanclass="math inline">\(p = \langle v_0, v_1, \cdots, v_k\rangle\)</span>，在第 <span class="math inline">\(i\)</span>次循环时，已经松弛过的边 <span class="math inline">\((v_1, v_2), (v_2,v_3), \cdots, (v_{i - 2}, v_{i - 1})\)</span> 会再次被松弛，而由于边<span class="math inline">\((v_{i - 1}, v_i)\)</span>还未被松弛，它以后的边的松弛操作没有贡献。</p><p>所以我们可以使用队列优化的 Bellman-Ford 算法，即 SPFA算法，来避免冗余操作。</p><p>具体来说，我们维护一个队列，在任意时刻，队列中只保存被松弛过且需要扩展的结点。并且当一个被松弛结点入队前，我们检查它是否已经在队列中。</p><p>伪代码如下： <span class="math display">\[\begin{align}&amp; \text{SHORTEST-PATH-FAST-ALGORITHM($G$, $w$, $s$)} \\&amp; 1 \qquad \operatorname{INITIALIZE\_SINGLE\_SOURCE}(G, s) \\&amp; 2 \qquad Q = \langle v_1, v_2, \cdots, v_k \rangle \text{ // } v_i\in G.V, \ k = |G.V| \\&amp; 3 \qquad \text{COUNT} = [] \\&amp; 4 \qquad \text{// COUNT is an array used to store the number ofnodes on a certain shortest path} \\&amp; 5 \qquad \text{// to determine whether the graph has a negativecycle.} \\&amp; 6 \qquad \textbf{while} \ Q \neq \varnothing \\&amp; 7 \qquad \qquad u = \operatorname{EXTRACT\_FRONT}(Q) \\&amp; 8 \qquad \qquad \textbf{for} \ \text{each vertex } v \inG.\operatorname{Adj}[u] \\&amp; 9 \qquad \qquad \qquad \textbf{if} \ \operatorname{RELAX}(u, v, w)= \text{TRUE} \\&amp; 10 \qquad \qquad \qquad \qquad \text{COUNT}[v] = \text{COUNT}[u] +1 \\&amp; 11 \qquad \qquad \qquad \qquad \textbf{if} \ \text{COUNT}[v] \geq|G.V| \\&amp; 12 \qquad \qquad \qquad \qquad \qquad \textbf{return} \\text{FALSE} \\&amp; 13 \qquad \qquad \qquad \qquad \textbf{if} \ v \notin Q \\&amp; 14 \qquad \qquad \qquad \qquad \qquad Q = Q \text{ push } v \\&amp; 15 \qquad \textbf{return} \ \text{TRUE}\end{align}\]</span></p><h3 id="c-实现-1">C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        q.<span class="hljs-built_in">push</span>(i), st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>(), st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br><br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;<br>                dist[j] = dist[t] + w[i];<br><br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(j), st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT18.06 Lec9 线性相关性、基、维数 学习笔记</title>
    <link href="/MIT18-06-Lec9-%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E3%80%81%E5%9F%BA%E3%80%81%E7%BB%B4%E6%95%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/MIT18-06-Lec9-%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E3%80%81%E5%9F%BA%E3%80%81%E7%BB%B4%E6%95%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这一节讲线性相关性。</p><span id="more"></span><h2 id="线性无关">线性无关</h2><p>考虑一个 <span class="math inline">\(m \times n\)</span> 的矩阵 <spanclass="math inline">\(A\)</span>，它的列向量分别是 <spanclass="math inline">\(\boldsymbol{v}_1, \boldsymbol{v}_2, \ldots,\boldsymbol{v}_n\)</span>：</p><ul><li>如果存在一个它们的线性组合，其中各项系数不为零，使得结果为 <spanclass="math inline">\(\boldsymbol{0}\)</span>，那么这些列向量是<strong>线性相关</strong> 的。</li><li>如果不存在这样的线性组合，那么这些列向量是 <strong>线性无关</strong>的。</li></ul><p>换句话说，如果 <span class="math inline">\(N(A)\)</span>中有且仅有零向量，那么这些向量 <strong>线性无关</strong>。</p><p>从 <strong>秩</strong> 的角度来看，线性无关时，<spanclass="math inline">\(r = n\)</span>；线性相关时，<spanclass="math inline">\(r &lt; n\)</span>。</p><h2 id="生成">生成</h2><p>若一个向量集合的线性组合填满一个空间，则向量集合<strong>生成</strong> 该空间。例如，矩阵 <spanclass="math inline">\(A\)</span> 的列向量生成的空间就是 <spanclass="math inline">\(C(A)\)</span>。</p><h2 id="基">基</h2><p>空间的 <strong>基</strong> 指的是一个向量集合 <spanclass="math inline">\(\boldsymbol{v}_1, \boldsymbol{v}_2, \ldots,\boldsymbol{v}_n\)</span>，包含如下性质：</p><ol type="1"><li><p>它们是线性无关的。</p></li><li><p>它们生成整个空间。</p></li></ol><p><span class="math inline">\(\mathbb{R}^{n}\)</span> 中 <spanclass="math inline">\(n\)</span> 个向量要构成基，以这 <spanclass="math inline">\(n\)</span> 个向量为列的矩阵要是<strong>可逆的</strong>。</p><p>空间内任意一个基的个向量个数相等，这个数目称为空间的<strong>维数</strong>。</p><p>举例：</p><p><span class="math display">\[A = \begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 1 \\ 1 &amp; 1 &amp; 2 &amp;1 \\ 1 &amp; 2 &amp; 3 &amp; 1 \end{bmatrix}\]</span></p><p>这个矩阵的列向量线性相关，有两个主列，它们组成了 <spanclass="math inline">\(C(A)\)</span> 的基，所以有：</p><p><span class="math display">\[\operatorname{rank}(A) = \text{ 主列个数 } = \text{ $C(A)$ 的维数 } = 2\]</span></p><p>我们很容易求出 <span class="math inline">\(A \boldsymbol{x} =\boldsymbol{0}\)</span> 的特解 <spanclass="math inline">\(\begin{bmatrix} -1 \\ -1 \\ 1 \\ 0\end{bmatrix}\)</span> 和 <span class="math inline">\(\begin{bmatrix} -1\\ 0 \\ 0 \\ 1\end{bmatrix}\)</span>，它们形成的零空间的一组基，我们知道，特解的个数就是自由变量的个数，所以有：</p><p><span class="math display">\[n - \operatorname{rank}(A) = \text{ 自由列个数 } = \text{ $N(A)$ 的维数} = 2\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT18.06 Lec8 求解 Ax=b 可解性和解的结构 学习笔记</title>
    <link href="/MIT18-06-Lec8-%E6%B1%82%E8%A7%A3-Ax-b-%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/MIT18-06-Lec8-%E6%B1%82%E8%A7%A3-Ax-b-%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这一节讲如何完整解出线性方程组。</p><span id="more"></span><p>依旧以上一节的矩阵 <span class="math inline">\(A = \begin{bmatrix} 1&amp; 2 &amp; 2 &amp; 2 \\ 2 &amp; 4 &amp; 6 &amp; 8 \\ 3 &amp; 6 &amp;8 &amp; 10 \end{bmatrix}\)</span> 为例，求解方程 <spanclass="math inline">\(A \boldsymbol{x} = \boldsymbol{b}\)</span>。</p><p>表示成增广矩阵，有：</p>$$<span class="math display">\[\begin{aligned}    \left[    \begin{array}{cccc|c}    1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1 \\    2 &amp; 4 &amp; 6 &amp; 8 &amp; b_2 \\    3 &amp; 6 &amp; 8 &amp; 10 &amp; b_3    \end{array}    \right]    &amp;\xrightarrow{消元}    \left[    \begin{array}{cccc|c}    \fbox{1} &amp; 2 &amp; 2 &amp; 2 &amp; b_1 \\    0 &amp; 0 &amp; \fbox{2} &amp; 4 &amp; b_2 - 2b_1 \\    0 &amp; 0 &amp; 2 &amp; 4 &amp; b_3 - 3b_1    \end{array}    \right] \\    &amp;\xrightarrow{消元}    \left[    \begin{array}{cccc|c}    \fbox{1} &amp; 2 &amp; 2 &amp; 2 &amp; b_1 \\    0 &amp; 0 &amp; \fbox{2} &amp; 4 &amp; b_2 - 2b_1 \\    0 &amp; 0 &amp; 0 &amp; 0 &amp; b_3 - b_2 - b_1    \end{array}    \right]\end{aligned}\]</span><p>$$</p><h2 id="可解性">可解性</h2><p>经过前面的学习，我们知道方程 <span class="math inline">\(A\boldsymbol{x} = \boldsymbol{b}\)</span> 有解的条件是 <spanclass="math inline">\(b\)</span> 在 <spanclass="math inline">\(A\)</span> 的列空间中。</p><p>观察第三行，显然有解的条件是 <span class="math inline">\(b_3 - b_2 -b_1 = 0\)</span>。</p><h2 id="求解">求解</h2><p>我们取 <span class="math inline">\(\boldsymbol{b} = \begin{bmatrix} 1\\ 5 \\ 6 \end{bmatrix}\)</span> 为例，下面求解</p><p><span class="math display">\[\left[\begin{array}{cccc|c}    \fbox{1} &amp; 2 &amp; 2 &amp; 2 &amp; 1 \\    0 &amp; 0 &amp; \fbox{2} &amp; 4 &amp; 3 \\    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\end{array}\right]\]</span></p><h3 id="特解">特解</h3><p>完整地求解方程组的第一步是找到特解。</p><p>具体来说，将所有自由变量设为 <spanclass="math inline">\(0\)</span>，我们得到：</p><p><span class="math display">\[\begin{cases}    x_1 + &amp;2 x_3 &amp;= 1 \\    &amp;2 x_3 &amp;= 3\end{cases}\]</span></p><p>进而解得特解</p><p><span class="math display">\[\boldsymbol{x_p} = \begin{bmatrix} -2 \\ 0 \\ \frac{3}{2} \\ 0\end{bmatrix}\]</span></p><h3 id="结合零空间">结合零空间</h3><p>方程 <span class="math inline">\(A \boldsymbol{x} =\boldsymbol{b}\)</span> 的解是 <spanclass="math inline">\(\boldsymbol{x_{complete}} = \boldsymbol{x_p} +\boldsymbol{x_n}\)</span>，其中 <spanclass="math inline">\(\boldsymbol{x_n}\)</span> 是零空间的特解：</p>$$<span class="math display">\[\begin{cases}    A \boldsymbol{x_p} &amp;= \boldsymbol{b} \\    A \boldsymbol{x_n} &amp;= \boldsymbol{0}\end{cases}\]</span><p>A ( + ) = $$</p><p>对本例有：</p><p><span class="math display">\[\boldsymbol{x_{complete}} = \begin{bmatrix} -2 \\ 0 \\ \frac{3}{2} \\ 0\end{bmatrix} + c_1 \begin{bmatrix} -2 \\ 1 \\ 0 \\ 0 \end{bmatrix} +c_2 \begin{bmatrix} 2 \\ 0 \\ -2 \\ 1 \end{bmatrix}\]</span></p><h2 id="秩">秩</h2><p>以下考虑秩 <span class="math inline">\(r\)</span> 的 <spanclass="math inline">\(m \times n\)</span> 矩阵 <spanclass="math inline">\(A\)</span>，有 <span class="math inline">\(r \le\min(m, n)\)</span>。</p><h3 id="列满秩">列满秩</h3><p>这种情况下，没有自由变量，所以零空间只包含 <spanclass="math inline">\(\boldsymbol{0}\)</span>，方程只有唯一解 <spanclass="math inline">\(\boldsymbol{x_{complete}} =\boldsymbol{x_p}\)</span>。</p><h3 id="行满秩">行满秩</h3><p>这种情况下，方程对于任意 <spanclass="math inline">\(\boldsymbol{b}\)</span> 都有解，因为 <spanclass="math inline">\(C(A)\)</span> 的维数是 <spanclass="math inline">\(m\)</span>，即 <spanclass="math inline">\(C(A)\)</span> 是向量空间 <spanclass="math inline">\(\mathbb{R}^m\)</span> 本身。</p><h3 id="行列满秩">行列满秩</h3><p>这种情况下，方程对于任意 <spanclass="math inline">\(\boldsymbol{b}\)</span> 都有唯一解。</p><h3 id="总结">总结</h3><p>用 <span class="math inline">\(R\)</span>表示简化行阶梯形式矩阵，有：</p><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(r = m =n\)</span></th><th style="text-align: center;"><span class="math inline">\(r = n &lt;m\)</span></th><th style="text-align: center;"><span class="math inline">\(r = m &lt;n\)</span></th><th style="text-align: center;"><span class="math inline">\(r &lt; m, r&lt; n\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(R\)</span></td><td style="text-align: center;"><spanclass="math inline">\(I\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\begin{bmatrix} I \\ 0 \end{bmatrix}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\begin{bmatrix} I &amp; F\end{bmatrix}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\begin{bmatrix} I &amp; F \\ 0 &amp; 0\end{bmatrix}\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(\text{Solutions to } A \boldsymbol{x} =\boldsymbol{b}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(0 \text{ or} 1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(0 \text{ or} \infty\)</span></td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT18.06 Lec7 求解 Ax=0 主变量 特解 学习笔记</title>
    <link href="/MIT18-06-Lec7-%E6%B1%82%E8%A7%A3-Ax-0-%E4%B8%BB%E5%8F%98%E9%87%8F-%E7%89%B9%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/MIT18-06-Lec7-%E6%B1%82%E8%A7%A3-Ax-0-%E4%B8%BB%E5%8F%98%E9%87%8F-%E7%89%B9%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这节课主要讲如何求零空间。</p><span id="more"></span><h2 id="求零空间">求零空间</h2><p>对于一个 <span class="math inline">\(3 \times 4\)</span> 的矩阵</p><p><span class="math display">\[A =\begin{bmatrix} 1 &amp; 2 &amp; 2 &amp; 2 \\ 2 &amp; 4 &amp; 6 &amp; 8\\ 3 &amp; 6 &amp; 8 &amp; 10 \end{bmatrix}\]</span></p><p>我们要求解 <span class="math inline">\(A \boldsymbol{x} =\boldsymbol{0}\)</span>。</p><p><span class="math display">\[\begin{aligned}    A =    \begin{bmatrix} \ \fbox{1} &amp; 2 &amp; 2 &amp; 2 \\ 2 &amp; 4&amp; 6 &amp; 8 \\ 3 &amp; 6 &amp; 8 &amp; 10 \end{bmatrix}    &amp;\xrightarrow{消元}    \begin{bmatrix} \ \fbox{1} &amp; 2 &amp; 2 &amp; 2 \\ 0 &amp; 0&amp; \fbox{2} &amp; 4 \\ 0 &amp; 0 &amp; 2 &amp; 4 \end{bmatrix}\\    &amp;\xrightarrow{消元}    \begin{bmatrix} \ \fbox{1} &amp; 2 &amp; 2 &amp; 2 \\ 0 &amp; 0&amp; \fbox{2} &amp; 4 \\ 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix} = U\end{aligned}\]</span></p><p>主元的数量被称为 <strong>矩阵的秩</strong>。本例中秩是 <spanclass="math inline">\(r = 2\)</span>。</p><p>主元所在的列称为 <strong>主列</strong>，其他列称为<strong>自由列</strong>。自由列可以任意分配数值，在本例中 <spanclass="math inline">\(x_2\)</span> 和 <spanclass="math inline">\(x_4\)</span> 是<strong>自由变量</strong>，可以任取。</p><h3 id="特解">特解</h3><p>我们取 <span class="math inline">\(x_2 = 1\)</span> 和 <spanclass="math inline">\(x_4 = 0\)</span>，得到特解 <spanclass="math inline">\(\begin{bmatrix} -2 \\ 1 \\ 0 \\ 0\end{bmatrix}\)</span>。这个解的任意倍数都是方程组的解。取 <spanclass="math inline">\(x_2 = 0, x_4 = 1\)</span>，我们得到特解 <spanclass="math inline">\(\begin{bmatrix} 2 \\ 0 \\ -2 \\ 1\end{bmatrix}\)</span>。</p><p>自由变量的个数等于零空间的维数，所以零空间中包含的正好是特解的线性组合。</p><h2 id="简化行阶梯形式矩阵">简化行阶梯形式矩阵</h2><p>在简化行阶梯形式（<em>reduced row echelonform</em>）中，主元上下都是零。</p><p>在本例中：</p><p><span class="math display">\[\begin{aligned}    \begin{bmatrix} \ \fbox{1} &amp; 2 &amp; 2 &amp; 2 \\ 0 &amp; 0&amp; \fbox{2} &amp; 4 \\ 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}&amp;\xrightarrow{消元}    \begin{bmatrix} \ \fbox{1} &amp; 2 &amp; 0 &amp; -2 \\ 0 &amp; 0&amp; \fbox{2} &amp; 4 \\ 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix} \\&amp;\xrightarrow{化简}    \begin{bmatrix} \ \fbox{1} &amp; 2 &amp; 0 &amp; -2 \\ 0 &amp; 0&amp; \fbox{1} &amp; 2 \\ 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix} = R =\operatorname{rref}(A)\end{aligned}\]</span></p><p>我们进行列交换：</p><p><span class="math display">\[\begin{aligned}    \begin{bmatrix} \ \fbox{1} &amp; 2 &amp; 0 &amp; -2 \\ 0 &amp; 0&amp; \fbox{1} &amp; 2 \\ 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}\xrightarrow{列交换}    \left[ \begin{array}{cc|cc} \ \fbox{1} &amp; 0 &amp; 2 &amp; 2 \\ 0&amp; \fbox{1} &amp; 0 &amp; -2 \\ \hline 0 &amp; 0 &amp; 0 &amp; 0\end{array} \right]    = \begin{bmatrix} I &amp; F \\ 0 &amp; 0 \end{bmatrix}    = R\end{aligned}\]</span></p><p>可以得到一个单位矩阵 <span class="math inline">\(I = \begin{bmatrix}1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}\)</span>，和一个自由变量组成的矩阵<span class="math inline">\(F = \begin{bmatrix} 2 &amp; -2 \\ 0 &amp; 2\end{bmatrix}\)</span>。</p><p>将 <span class="math inline">\(N\)</span> 记作<strong>零空间矩阵</strong>，使得 <span class="math inline">\(R N =\boldsymbol{0}\)</span>，则 <span class="math inline">\(N =\begin{bmatrix} -F \\ I \end{bmatrix}\)</span>，在本例中零空间矩阵是<span class="math inline">\(\begin{bmatrix} -2 &amp; 2 \\ 0 &amp; -2 \\1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}\)</span>，它的两个列向量就是特解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT18.06 Lec6 列空间和零空间 学习笔记</title>
    <link href="/MIT18-06-Lec6-%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/MIT18-06-Lec6-%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="列空间">列空间</h2><p>列空间是矩阵 <span class="math inline">\(A\)</span>中所有列的线性组合的集合，记作 <spanclass="math inline">\(C(A)\)</span>。</p><h3 id="求解-a-boldsymbolx-boldsymbolb">求解 <spanclass="math inline">\(A \boldsymbol{x} = \boldsymbol{b}\)</span></h3><p>以一个矩阵 <span class="math inline">\(A = \begin{bmatrix} 1 &amp; 1&amp; 2 \\ 2 &amp; 1 &amp; 3 \\ 3 &amp; 1 &amp; 4 \\ 4 &amp; 1 &amp; 5\end{bmatrix}\)</span> 为例，它只有三个列向量，所以对于任意给定的向量<spanclass="math inline">\(\boldsymbol{b}\)</span>，方程并不总是有解的。只有<span class="math inline">\(\boldsymbol{b}\)</span>是各列的线性组合时，方程才有解。</p><p>换句话说，方程 <span class="math inline">\(A \boldsymbol{x} =\boldsymbol{b}\)</span> 有解当且仅当 <spanclass="math inline">\(\boldsymbol{b}\)</span> 在 <spanclass="math inline">\(C(A)\)</span> 中。</p><p>对于上面的矩阵 <spanclass="math inline">\(A\)</span>，列三在前两列的平面上，对于子空间没有贡献，即线性相关，所以可以去掉，<spanclass="math inline">\(C(A)\)</span> 是向量空间 <spanclass="math inline">\(\mathbb{R}^4\)</span> 的一个二维子空间。</p><h2 id="零空间">零空间</h2><p>零空间是所有 <span class="math inline">\(A \boldsymbol{x} =\boldsymbol{0}\)</span> 的解的集合，记作 <spanclass="math inline">\(N(A)\)</span>。</p><p>依旧以上面的矩阵 <span class="math inline">\(A\)</span> 为例：</p><p><span class="math display">\[A \boldsymbol{x} =\begin{bmatrix} 1 &amp; 1 &amp; 2 \\ 2 &amp; 1 &amp; 3 \\ 3 &amp; 1&amp; 4 \\ 4 &amp; 1 &amp; 5 \end{bmatrix}\begin{bmatrix} x_1 \\ x_2 \\ x_3 \end{bmatrix}=\begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}\]</span></p><p>所有的解可以形成子空间：假设 <spanclass="math inline">\(\boldsymbol{v}\)</span> 和 <spanclass="math inline">\(\boldsymbol{w}\)</span> 在零空间中，<spanclass="math inline">\(A(\boldsymbol{v} + \boldsymbol{w})\)</span>必然为零，而且 <span class="math inline">\(A(c \boldsymbol{x}) = c\boldsymbol{0}\)</span>，因此 <span class="math inline">\(\boldsymbol{v}+ \boldsymbol{w}\)</span> 和 <span class="math inline">\(c\boldsymbol{x}\)</span> 都在零空间 <spanclass="math inline">\(N(A)\)</span> 中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT18.06 Lec5 转置、置换、向量空间R 学习笔记</title>
    <link href="/MIT18-06-Lec5-%E8%BD%AC%E7%BD%AE%E3%80%81%E7%BD%AE%E6%8D%A2%E3%80%81%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/MIT18-06-Lec5-%E8%BD%AC%E7%BD%AE%E3%80%81%E7%BD%AE%E6%8D%A2%E3%80%81%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="置换">置换</h2><p>乘以一个置换矩阵可以交换矩阵的行和列。在消元遇到主元是 0的情况时，可以通过引入一个置换矩阵 <spanclass="math inline">\(P\)</span> 交换行来解决。</p><p><span class="math inline">\(n\)</span> 阶的置换矩阵有 <spanclass="math inline">\(n!\)</span> 个。</p><p>置换矩阵的逆矩阵与其转置矩阵相等，即 <spanclass="math inline">\(P^{-1} = P^T\)</span>。</p><h2 id="转置">转置</h2><p>矩阵的转置是将矩阵的行和列互换得到的新矩阵。即 <spanclass="math inline">\(A^T_{ij} = A_{ji}\)</span>。</p><p><span class="math display">\[\begin{bmatrix} 1 &amp; 3 \\ 2 &amp; 3 \\ 4 &amp; 1 \end{bmatrix} ^{T}=\begin{bmatrix} 1 &amp; 2 &amp; 4 \\ 3 &amp; 3 &amp; 1 \end{bmatrix}\]</span></p><h3 id="对称矩阵">对称矩阵</h3><p>对称矩阵是指 <span class="math inline">\(A^T = A\)</span>的矩阵。</p><p>给定一个矩阵 <span class="math inline">\(R\)</span>，<spanclass="math inline">\(R^T R\)</span> 就是一个对称矩阵：<spanclass="math inline">\((R^T R)^T = R^T (R^T)^T = R^T R\)</span>。</p><p>以上面的矩阵为例：</p><p><span class="math display">\[\begin{bmatrix} 1 &amp; 3 \\ 2 &amp; 3 \\ 4 &amp; 1 \end{bmatrix}\begin{bmatrix} 1 &amp; 2 &amp; 4 \\ 3 &amp; 3 &amp; 1 \end{bmatrix}=\begin{bmatrix} 10 &amp; 11 &amp; 7 \\ 11 &amp; 18 &amp; 11 \\ 7 &amp;11 &amp; 17 \end{bmatrix}\]</span></p><h2 id="向量空间">向量空间</h2><p>向量空间标示成 <spanclass="math inline">\(\mathbb{R}^n\)</span>，每个空间 <spanclass="math inline">\(\mathbb{R}^n\)</span> 包含一整个向量的集合。</p><p>空间 <span class="math inline">\(\mathbb{R}^n\)</span> 包含全部具有<span class="math inline">\(n\)</span> 个分量的列向量 <spanclass="math inline">\(\boldsymbol{v}\)</span>。</p><h3 id="子空间">子空间</h3><p>向量空间的子空间是一个向量的集合（包括零向量），满足以下条件：假设<span class="math inline">\(\boldsymbol{v}\)</span> 和 <spanclass="math inline">\(\boldsymbol{w}\)</span> 在子空间中，则</p><ol type="1"><li><span class="math inline">\(\boldsymbol{v} + \boldsymbol{w}\)</span>在子空间中</li><li><span class="math inline">\(c \boldsymbol{v}\)</span>在子空间中</li></ol><p>以二维空间 <span class="math inline">\(\mathbb{R}^2\)</span>为例，子空间可以是：</p><ol type="1"><li>一整个二维空间 <span class="math inline">\(\mathbb{R}^2\)</span>本身</li><li>一条过原点的直线</li><li>零向量</li></ol><h3 id="列空间">列空间</h3><p>矩阵 <span class="math inline">\(A\)</span> 的列空间是 <spanclass="math inline">\(A\)</span>的列向量的所有线性组合，这些组合就是所有可能的 <spanclass="math inline">\(A \boldsymbol{x}\)</span>，它们构成了列空间 <spanclass="math inline">\(C(A)\)</span>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT18.06 Lec4 A 的 LU 分解 学习笔记</title>
    <link href="/MIT18-06-Lec4-A-%E7%9A%84-LU-%E5%88%86%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/MIT18-06-Lec4-A-%E7%9A%84-LU-%E5%88%86%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这节课的主要目的是利用矩阵理解高斯消元，即找到一个矩阵 <spanclass="math inline">\(L\)</span>，使得 <span class="math inline">\(L U =A\)</span>，其中 <span class="math inline">\(U\)</span>是上三角矩阵。</p><h2 id="a-b-的逆"><span class="math inline">\(A B\)</span> 的逆</h2><p>矩阵乘积 <span class="math inline">\(A B\)</span> 的逆是 <spanclass="math inline">\(B^{-1} A^{-1}\)</span>。</p><h2 id="at-的逆"><span class="math inline">\(A^{T}\)</span> 的逆</h2><p>一个矩阵 <span class="math inline">\(A\)</span> 的转置 <spanclass="math inline">\(A^{T}\)</span> 就是交换它的行和列。换句话说，<spanclass="math inline">\(A_{ij} = A_{ji}^T\)</span>。</p><p>矩阵乘积的转置是 <span class="math inline">\((A B)^T = B^TA^T\)</span>，对于一个可逆的矩阵 <spanclass="math inline">\(A\)</span>，<spanclass="math inline">\(A^{T}\)</span> 的逆是 <spanclass="math inline">\((A^{-1})^{T}\)</span>。</p><h2 id="a-lu"><span class="math inline">\(A = LU\)</span></h2><p>经过之前的学习，我们知道对于一个矩阵 <spanclass="math inline">\(A\)</span>，为了消元得到上三角矩阵 <spanclass="math inline">\(U\)</span>，我们可以引入一个初等矩阵 <spanclass="math inline">\(E\)</span> 来表示消元操作，即 <spanclass="math inline">\(E A = U\)</span>。</p><p>那么对于分解矩阵 <span class="math inline">\(A\)</span> 的等式 <spanclass="math inline">\(A = LU\)</span>，比较两式可以发现 <spanclass="math inline">\(L\)</span> 就是 <spanclass="math inline">\(E\)</span> 的逆，因为如果对于式 <spanclass="math inline">\(E A = U\)</span>，两边同时乘以 <spanclass="math inline">\(E\)</span> 的逆，就会得到 <spanclass="math inline">\(A = E^{-1} U\)</span>，而这恰好对应式 <spanclass="math inline">\(A = LU\)</span>。</p><p>以一个二维矩阵举例来说，对于一个矩阵 <span class="math inline">\(A =\begin{bmatrix} 2 &amp; 1 \\ 8 &amp; 7\end{bmatrix}\)</span>，分解后我们会得到 <span class="math inline">\(L =\begin{bmatrix} 1 &amp; 0 \\ 4 &amp; 1 \end{bmatrix}\)</span>，<spanclass="math inline">\(U = \begin{bmatrix} 2 &amp; 1 \\ 0 &amp; 3\end{bmatrix}\)</span>，可以看到 <span class="math inline">\(L\)</span>是一个下三角矩阵，字母 L 表示 <em>lower triangular</em>。</p><p>对于一个三维矩阵 <spanclass="math inline">\(A\)</span>，假设没有行交换，那么消元的过程可以表示为<span class="math inline">\(E_{32} E_{31} E_{21} A =U\)</span>。我们知道矩阵乘积的逆就是把各项的逆倒过来相乘，所以 <spanclass="math inline">\(A\)</span> 可以分解为 <spanclass="math inline">\(A = E^{-1}_{21} E^{-1}_{31} E^{-1}_{32}U\)</span>，<span class="math inline">\(L\)</span> 就是这些逆之积。</p><h2 id="消元需要的计算量">消元需要的计算量</h2><p>考虑对于一个 <span class="math inline">\(n \times n\)</span> 的矩阵<span class="math inline">\(A\)</span>，把一次乘法 +减法称为一次操作，消元需要多少次操作：</p><p>取 <span class="math inline">\(A_{11}\)</span>为主元，不考虑第一行，剩下的元素都需要经过一次操作，所以需要约 <spanclass="math inline">\(n^2\)</span> 次操作。</p><p>以此类推，对于剩下的行，需要约为 <span class="math inline">\((n -1)^{2}\)</span>、<span class="math inline">\((n - 2)^{2}\)</span>、<spanclass="math inline">\(\cdots\)</span>、<spanclass="math inline">\(1^2\)</span> 次操作。那么总运算量 <spanclass="math inline">\(\sum_{i = 1}^{n} i^2 \approx \int_{0}^{n} x^{2} dx= \frac{1}{3} n^{3}\)</span>。</p><h2 id="行交换">行交换</h2><p>如果需要行交换，那么我们需要左乘一个 <em>置换矩阵</em> <spanclass="math inline">\(P\)</span>，<span class="math inline">\(P\)</span>的逆就是它的转置 <span class="math inline">\(P^{T}\)</span>。</p><p><span class="math inline">\(3 \times 3\)</span> 的置换矩阵有 6种，<span class="math inline">\(4 \times 4\)</span> 的置换矩阵有 24种，<span class="math inline">\(n \times n\)</span> 的置换矩阵有 <spanclass="math inline">\(n!\)</span> 种。</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT18.06 Lec3 矩阵乘法和逆矩阵 学习笔记</title>
    <link href="/MIT18-06-Lec3-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/MIT18-06-Lec3-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵乘法">矩阵乘法</h2><p>设 <span class="math inline">\(A\)</span> 是一个 <spanclass="math inline">\(m \times n\)</span> 的矩阵，<spanclass="math inline">\(B\)</span> 是一个 <span class="math inline">\(n\times p\)</span> 的矩阵，那么 <span class="math inline">\(A\)</span> 与<span class="math inline">\(B\)</span> 的乘积 <spanclass="math inline">\(C\)</span> 是一个 <span class="math inline">\(m\times p\)</span> 的矩阵，记作 <span class="math inline">\(C =AB\)</span>，其中 <span class="math inline">\(C\)</span> 的第 <spanclass="math inline">\(i\)</span> 行第 <spanclass="math inline">\(j\)</span> 列的元素为 <spanclass="math inline">\(C_{ij} = \sum_{k=1}^{n}A_{ik}B_{kj}\)</span>。</p><h3 id="求矩阵乘法的其他方法">求矩阵乘法的其他方法</h3><h4 id="a-乘-b-的每一列"><span class="math inline">\(A\)</span> 乘(<span class="math inline">\(B\)</span> 的每一列)</h4><p><span class="math inline">\(B\)</span> 可以考虑成 <spanclass="math inline">\(p\)</span> 个单独的列向量，用 <spanclass="math inline">\(A\)</span> 乘以每个列向量，相应的可以得到 <spanclass="math inline">\(p\)</span> 列答案，<spanclass="math inline">\(C\)</span> 中的每一列就是 <spanclass="math inline">\(A\)</span> 各列的线性组合。</p><p><span class="math display">\[A \begin{bmatrix} \boldsymbol{b_1} &amp; \boldsymbol{b_2} &amp; \cdots&amp; \boldsymbol{b_p} \end{bmatrix} = \begin{bmatrix} A\boldsymbol{b_1} &amp; A \boldsymbol{b_2} &amp; \cdots &amp; A\boldsymbol{b_p} \end{bmatrix}\]</span></p><h4 id="a-的每一行-乘矩阵-b">(<span class="math inline">\(A\)</span>的每一行) 乘矩阵 <span class="math inline">\(B\)</span></h4><p><span class="math inline">\(A\)</span> 可以考虑成 <spanclass="math inline">\(m\)</span> 个单独的行向量，用每个行向量乘以 <spanclass="math inline">\(B\)</span>，相应的可以得到 <spanclass="math inline">\(m\)</span> 行答案，<spanclass="math inline">\(C\)</span> 中的每一行就是 <spanclass="math inline">\(B\)</span> 各行的线性组合。</p><p><span class="math display">\[\begin{bmatrix} \text{$A$ 的行 $i$} \end{bmatrix} B = \begin{bmatrix}\text{$C$ 的行 $i$} \end{bmatrix}\]</span></p><h4 id="行列相乘">行列相乘</h4><p><span class="math inline">\(A\)</span> 的列 <spanclass="math inline">\(1\)</span> 至 <spanclass="math inline">\(n\)</span> 与 <spanclass="math inline">\(B\)</span> 的行 <spanclass="math inline">\(1\)</span> 至 <spanclass="math inline">\(n\)</span> 相乘，然后相加。</p><p><span class="math display">\[\begin{bmatrix} 2 &amp; 7 \\ 3 &amp; 8 \\ 4 &amp; 9 \end{bmatrix}\begin{bmatrix} 1 &amp; 6 \\ 0 &amp; 0 \end{bmatrix} = \begin{bmatrix} 2\\ 3 \\ 4 \end{bmatrix} \begin{bmatrix} 1 &amp; 6 \end{bmatrix} +\begin{bmatrix} 7 \\ 8 \\ 9 \end{bmatrix} \begin{bmatrix} 0 &amp; 0\end{bmatrix}\]</span></p><h4 id="方块乘法">方块乘法</h4><p>当形状合适时，可以利用方块乘法简化计算。</p><p><span class="math display">\[\left[\begin{array}{c|c}A_1&amp;A_2\\\hlineA_3&amp;A_4\end{array}\right]\left[\begin{array}{c|c}B_1&amp;B_2\\\hlineB_3&amp;B_4\end{array}\right]=\left[\begin{array}{c|c}A_1B_1+A_2B_3&amp;A_1B_2+A_2B_4\\\hlineA_3B_1+A_4B_3&amp;A_3B_2+A_4B_4\end{array}\right]\]</span></p><h2 id="逆矩阵">逆矩阵</h2><p>如果一个矩阵 <span class="math inline">\(A\)</span>有逆矩阵，那就存在一个矩阵 <spanclass="math inline">\(A^{-1}\)</span>，使得 <spanclass="math inline">\(AA^{-1} = A^{-1}A = I\)</span>，其中 <spanclass="math inline">\(I\)</span> 是单位矩阵。</p><p>如果一个矩阵没有逆矩阵，那么这个矩阵就是奇异矩阵。</p><h3 id="测试可逆性">测试可逆性</h3><h4 id="利用方程式">利用方程式</h4><p>用来测试可逆性质的方程式是 <span class="math inline">\(A\boldsymbol{x} = \boldsymbol{0}\)</span>，如果 <spanclass="math inline">\(\boldsymbol{x} = \boldsymbol{0}\)</span>是唯一解，那么 <span class="math inline">\(A\)</span> 可逆。</p><p>假设 <span class="math inline">\(A\)</span> 可逆且有 <spanclass="math inline">\(\boldsymbol{x}\)</span> 不等于 <spanclass="math inline">\(\boldsymbol{0}\)</span> 的解，那么两边同时乘以<span class="math inline">\(A^{-1}\)</span> 会得到 <spanclass="math inline">\(A^{-1} A \boldsymbol{x} = \boldsymbol{x} = A^{-1}\boldsymbol{0} = \boldsymbol{0}\)</span>，而 <spanclass="math inline">\(\boldsymbol{x}\)</span> 不等于 <spanclass="math inline">\(\boldsymbol{0}\)</span>，等式前后矛盾。</p><h4 id="利用行列式">利用行列式</h4><p>如果 <span class="math inline">\(A\)</span> 可逆，那么 <spanclass="math inline">\(\det(A) \neq 0\)</span> 。</p><h3 id="gauss-jordan-法计算逆矩阵">Gauss-Jordan 法计算逆矩阵</h3><p>对于矩阵 <span class="math inline">\(A = \begin{bmatrix} 1 &amp; 3 \\2 &amp; 7 \end{bmatrix}\)</span>，设 <span class="math inline">\(A^{-1}= \begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix}\)</span>，那么<span class="math inline">\(\begin{bmatrix} 1 &amp; 3 \\ 2 &amp; 7\end{bmatrix} \begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix} =\begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}\)</span>。</p><p>表示成增广矩阵：</p><p><span class="math display">\[\left[\begin{array}{cc|cc}    1 &amp; 3 &amp; 1 &amp; 0 \\    2 &amp; 7 &amp; 0 &amp; 1\end{array}\right]\]</span></p><p>采用消元法，将左边的矩阵变成单位矩阵，右边的矩阵就是 <spanclass="math inline">\(A^{-1}\)</span>。</p><p>具体来说，利用高斯消元将左边的矩阵变成上三角矩阵以后，从下面开始继续消元，使得主元上面都是零，最后化为单位矩阵。</p><p>$$ </p><p>$$</p><p>本质上，<span class="math inline">\(A^{-1}\)</span>就是一个消元矩阵，<span class="math inline">\(A^{-1}\)</span> 乘 <spanclass="math inline">\(\begin{bmatrix} A &amp; I \end{bmatrix}\)</span>得到 <span class="math inline">\(\begin{bmatrix} I &amp; A^{-1}\end{bmatrix}\)</span>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT18.06 Lec2 矩阵消元 学习笔记</title>
    <link href="/MIT18-06-Lec2-%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/MIT18-06-Lec2-%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="消元法">消元法</h2><p>消元法可以用于求解线性方程组，本节课的例子是一个三元一次方程组：</p><p><span class="math display">\[\begin{cases}    x + 2y + z &amp;= 2 \\    3x + 8y + z &amp;= 12 \\    4y + z &amp;= 2 \\\end{cases}\]</span></p><p>将方程组写成矩阵形式：</p><p><span class="math display">\[A = \begin{bmatrix} 1 &amp; 2 &amp; 1 \\ 3 &amp; 8 &amp; 1 \\ 0 &amp; 4&amp; 1 \end{bmatrix} \qquad b = \begin{bmatrix} 2 \\ 12 \\ 2\end{bmatrix}\]</span></p><p>首先是<strong>消元</strong>，先选左上角的数为主元，然后将下面的系数消为0，接下来对第二行同理：</p><p><span class="math display">\[A = \begin{bmatrix} \ \fbox{1} &amp; 2 &amp; 1 \\ 3 &amp; 8 &amp; 1 \\ 0&amp; 4 &amp; 1 \end{bmatrix}\rightarrow \begin{bmatrix} \ \fbox{1} &amp; 2 &amp; 1 \\ 0 &amp;\fbox{2} &amp; -2 \\ 0 &amp; 4 &amp; 1 \end{bmatrix}\rightarrow u = \begin{bmatrix} \ \fbox{1} &amp; 2 &amp; 1 \\ 0 &amp;\fbox{2} &amp; -2 \\ 0 &amp; 0 &amp; \fbox{5} \ \end{bmatrix}\]</span></p><p>对于向量 <spanclass="math inline">\(b\)</span>，也进行同样的操作，得到向量 <spanclass="math inline">\(c = \begin{bmatrix} 2 \\ 6 \\ -10\end{bmatrix}\)</span>，得到一个新等式 <span class="math inline">\(u\mathbf{x} = c\)</span>。</p><p>对于 <span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(b\)</span> 有相同的操作，可以引入一个增广矩阵，将<span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(b\)</span> 合并：</p><p><span class="math display">\[\left[\begin{array}{ccc|c}    1 &amp; 2 &amp; 1 &amp; 2 \\    3 &amp; 8 &amp; 1 &amp; 12 \\    0 &amp; 4 &amp; 1 &amp; 2\end{array}\right]\]</span></p><p>接下来是 <strong>回代</strong>，从最后一行开始，得到 <spanclass="math inline">\(z = -2\)</span>，然后代入到第二行，得到 <spanclass="math inline">\(y = 3\)</span>，最后代入到第一行，得到 <spanclass="math inline">\(x = 1\)</span>：</p><p><span class="math display">\[\begin{cases}    x + 2y + z &amp;= 2 &amp;\rightarrow x = 2 \\    3x + 8y + z &amp;= 12 &amp;\rightarrow y = 3 \\    4y + z &amp;= 2 &amp;\rightarrow z = -2\end{cases}\]</span></p><h2 id="利用矩阵消元">利用矩阵消元</h2><p>为了利用矩阵消元，我们引入一个初等矩阵 <spanclass="math inline">\(E\)</span>，对于上述消元的第一步操作，我们可以引入：</p><p><span class="math display">\[E = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ -3 &amp; 1 &amp; 0 \\ 0 &amp; 0&amp; 1 \end{bmatrix}\]</span></p><p>利用 <strong>矩阵乘法</strong> ，我们可以得到：</p><p><span class="math display">\[\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ -3 &amp; 1 &amp; 0 \\ 0 &amp; 0&amp; 1 \end{bmatrix} \begin{bmatrix} 1 &amp; 2 &amp; 1 \\ 3 &amp; 8&amp; 1 \\ 0 &amp; 4 &amp; 1 \end{bmatrix} = \begin{bmatrix} 1 &amp; 2&amp; 1 \\ 0 &amp; 2 &amp; -2 \\ 0 &amp; 4 &amp; 1 \end{bmatrix}\]</span></p><p>同理，有：</p><p><span class="math display">\[\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; -2&amp; 1 \end{bmatrix} \begin{bmatrix} 1 &amp; 2 &amp; 1 \\ 0 &amp; 2&amp; -2 \\ 0 &amp; 4 &amp; 1 \end{bmatrix} = \begin{bmatrix} 1 &amp; 2&amp; 1 \\ 0 &amp; 2 &amp; -2 \\ 0 &amp; 0 &amp; 5 \end{bmatrix}\]</span></p><p>用一个等式表示上述操作：</p><p><span class="math display">\[E_{32} (E_{21} A)  = u\]</span></p><p>利用结合率，我们可以得到一个消元矩阵 <spanclass="math inline">\(E\)</span>，通过一步乘法操作，将 <spanclass="math inline">\(A\)</span> 变为 <spanclass="math inline">\(u\)</span>：</p><p><span class="math display">\[E = E_{32} E_{21} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ -3 &amp; 1&amp; 0 \\ 6 &amp; -2 &amp; 1 \end{bmatrix}\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT18.06 Lec1 线性代数的几何表示 学习笔记</title>
    <link href="/MIT18-06-Lec1-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E5%87%A0%E4%BD%95%E8%A1%A8%E7%A4%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/MIT18-06-Lec1-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E5%87%A0%E4%BD%95%E8%A1%A8%E7%A4%BA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>讲座从一个解方程的例子开始： <span class="math display">\[\begin{cases}\begin{aligned}2 x &amp;- y &amp;= 0 \\- x &amp;+ 2 y &amp;= 3\end{aligned}\end{cases}\]</span> 本节课讲了看待这个方程组的三种方式。</p><h2 id="row-picture">Row Picture</h2><p>将每行的方程看作一条直线，两条直线的交点就对应了方程组的解，在<strong>图一</strong> 中可以看出方程组的解是 <spanclass="math inline">\(x = 1, \ y = 2\)</span> 。</p><center><img src="https://cdn.jsdelivr.net/gh/lihaoze123/pic/image-20240807200741607.png" alt="image-20240807200741607" style="zoom:50%;" /></center><center><strong> 图 1：直线 2x - y = 0 与直线 -x + 2y = 3 交于点 (1, 2)</strong></center><h2 id="column-picture">Column Picture</h2><p>把每一列中的系数看作向量，可以将上述方程组写作一个等式： <spanclass="math display">\[x\begin{bmatrix}2 \\-1\end{bmatrix}+ y\begin{bmatrix}-1 \\2\end{bmatrix}=\begin{bmatrix}0 \\3\end{bmatrix}\]</span> 如果给定两个向量 <spanclass="math inline">\(\mathbf{c}\)</span> 和 <spanclass="math inline">\(\mathbf{d}\)</span> 和变量 <spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(y\)</span>，那么 <span class="math inline">\(x\mathbf{c} + y \mathbf{d}\)</span> 称作 <spanclass="math inline">\(\mathbf{c}\)</span> 和 <spanclass="math inline">\(\mathbf{d}\)</span> 的<strong>线性组合</strong>。</p><p>要使得等式成立，可以取 <span class="math inline">\(x = 1, \ y =2\)</span>，<strong>图二</strong> 可以表示这个线性组合：</p><center><img src="https://cdn.jsdelivr.net/gh/lihaoze123/pic/image-20240807202523650.png" alt="image-20240807202523650" style="zoom:50%;" /></center><center><strong> 图 2 </strong></center><h2 id="matrix-picture">Matrix Picture</h2><p>将方程组写成矩阵形式：</p><p><span class="math display">\[\begin{bmatrix}  2 &amp; -1 \\  -1 &amp; 2\end{bmatrix}  \begin{bmatrix} x \\ y \end{bmatrix}  =\begin{bmatrix}  0 \\  3 \end{bmatrix}\]</span></p><p>矩阵 <span class="math inline">\(A = \begin{bmatrix} 2 &amp; -1 \\ -1&amp; 2 \end{bmatrix}\)</span> 称作<strong>系数矩阵</strong>，这个方程组可以写作 <spanclass="math inline">\(A \mathbf{x} = \mathbf{b}\)</span>，其中 <spanclass="math inline">\(\mathbf{x} = \begin{bmatrix} x \\ y\end{bmatrix}\)</span>。</p><h2 id="矩阵乘法">矩阵乘法</h2><p>按照一般的定义，矩阵乘法是将矩阵的行向量与列向量进行内积： <spanclass="math display">\[\begin{bmatrix} 2 &amp; 5 \\ 1 &amp; 3 \end{bmatrix} \begin{bmatrix} 1\\ 2 \end{bmatrix} = \begin{bmatrix} 2 \cdot 1 + 5 \cdot 2 \\ 1 \cdot 1+ 3 \cdot 2 \end{bmatrix} = \begin{bmatrix} 12 \\ 7 \end{bmatrix}\]</span></p><p>按照 <strong>Column Picture</strong>的思路，可以将矩阵乘法理解为将矩阵的列向量进行线性组合。例如，矩阵 <spanclass="math inline">\(A\)</span> 乘以向量 <spanclass="math inline">\(\mathbf{x}\)</span>，可以看作是将 <spanclass="math inline">\(A\)</span> 的列向量进行线性组合，系数为 <spanclass="math inline">\(\mathbf{x}\)</span> 的元素。</p><p><span class="math display">\[\begin{bmatrix} 2 &amp; 5 \\ 1 &amp; 3 \end{bmatrix} \begin{bmatrix} 1\\ 2 \end{bmatrix} = 1 \begin{bmatrix} 2 \\ 1 \end{bmatrix} + 2\begin{bmatrix} 5 \\ 3 \end{bmatrix} = \begin{bmatrix} 12 \\ 7\end{bmatrix}\]</span></p><h2 id="线性无关">线性无关</h2><p>简单的说，对于 <span class="math inline">\(A \mathbf{x} =\mathbf{b}\)</span>，<span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 任取，不能填满整个平面，那么矩阵 <spanclass="math inline">\(A\)</span> 就是一个<strong>奇异矩阵</strong>，这种情况下的两个列向量就是<strong>线性相关</strong> 的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT18.01 Lec27&amp;28 三角函数的积分与三角换元 &amp; 反向变量替换 学习笔记</title>
    <link href="/MIT18-01-Lec27-28-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9A%84%E7%A7%AF%E5%88%86%E4%B8%8E%E4%B8%89%E8%A7%92%E6%9B%BF%E6%8D%A2-%E5%8F%8D%E5%90%91%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/MIT18-01-Lec27-28-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9A%84%E7%A7%AF%E5%88%86%E4%B8%8E%E4%B8%89%E8%A7%92%E6%9B%BF%E6%8D%A2-%E5%8F%8D%E5%90%91%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这两节开始有点技术含量了</p><span id="more"></span><h2 id="一些常见公式">一些常见公式</h2><p><strong>基本公式</strong></p><p><span class="math display">\[\boxed{\begin{aligned}\sin^2 \theta &amp;+ \cos^2 \theta = 1 \\\sec^2 \theta &amp;= 1 + \tan^2 x \\\cos (2 \theta) &amp;= \cos^2 \theta - \sin^2 \theta \\\sin (2 \theta) &amp;= 2 \sin \theta \cos \theta \\\end{aligned}}\]</span></p><p><strong>半角公式</strong></p><p><span class="math display">\[\boxed{\begin{aligned}\cos^2 \theta &amp;= \frac{1 + \cos(2 \theta)}{2} \\\sin^2 \theta &amp;= \frac{1 - \cos(2 \theta)}{2} \\\end{aligned}}\]</span></p><p><strong>微分公式</strong></p><p><span class="math display">\[\boxed{\begin{aligned}&amp;d\sin x = \cos x \ dx \\&amp;d\cos x = -\sin x \ dx \\&amp;d\tan x = \sec^2 x \ dx \\&amp;d\sec x = \sec x \ \tan x \ dx\end{aligned}}\]</span></p><p><strong>积分公式</strong></p><p><span class="math display">\[\boxed{\begin{aligned}\int \tan x \ dx &amp;= - \ln(\cos x) ＋ c \\\int \sec x \ dx &amp;= \int \frac{d (\sec x + \tan x)}{\sec x + \tan x}\\&amp;= \ln (\sec x + \tan x)\end{aligned}}\]</span></p><h2 id="三角函数的积分">三角函数的积分</h2><h3 id="对于形如-int-sinn-x-cosm-x-dx-的积分">对于形如 <spanclass="math inline">\(\int \sin^n x \cos^m x \ dx\)</span> 的积分</h3><h4 id="n-或-m-是奇数的情况"><span class="math inline">\(n\)</span> 或<span class="math inline">\(m\)</span> 是奇数的情况</h4><p>当遇到这种情况时，策略是利用 <span class="math inline">\(\sin^2 x +\cos^2 x = 1\)</span> 来代换原式中的奇数项，以下通过一个典型示例举例</p><h5 id="求-int-sin3-x-cos2-x-dx">求 <span class="math inline">\(\int\sin^3 x \cos^2 x \ dx\)</span></h5><p>对于这个式子，有</p><p><span class="math display">\[\int \sin ^3 x \cos ^2 x d x=\int \sin ^2 x \cos ^2 x \sin x dx=\int\left(1-\cos ^2 x\right) \cos ^2 x \sin x d x\]</span></p><p>设 <span class="math inline">\(u = \cos x\)</span>，有 <spanclass="math inline">\(du = -sinx \ dx\)</span>，代入得</p><p><span class="math display">\[\begin{gathered}\operatorname{ans} = \int (1 - u^2) u^2 \ du\end{gathered}\]</span></p><p>接下来就是简单的多项式积分，把 <span class="math inline">\(u = \cosx\)</span> 代入原式得</p><p><span class="math display">\[\operatorname{ans} = -\frac{1}{3} \cos^3 x + \frac{1}{5} \cos^5 x + c\]</span></p><h4 id="n-和-m-都是偶数的形式"><span class="math inline">\(n\)</span> 和<span class="math inline">\(m\)</span> 都是偶数的形式</h4><p>当遇到这种情况时，策略是利用半角公式，例如：</p><p><span class="math display">\[\begin{aligned}\int \cos ^2 x \ d x &amp;=\int \frac{1+\cos 2 x}{2} dx=\frac{x}{2}+\frac{\sin (2 x)}{4}+c \\\int \sin ^2 x \ d x &amp;=\int \frac{1-\cos (2 x)}{2} dx=\frac{x}{2}-\frac{\sin (2 x)}{4}+c\end{aligned}\]</span></p><h3 id="对于形如-int-secn-x-tanm-x-dx-的积分">对于形如 <spanclass="math inline">\(\int \sec^n x \ \tan^m x \ dx\)</span> 的积分</h3><h4 id="n-是偶数的情况"><span class="math inline">\(n\)</span>是偶数的情况</h4><p>当遇到这种情况时，策略是利用 <span class="math inline">\(\sec^2\theta = 1 + \tan^2 x\)</span> 来代换原式，例如</p><p><span class="math display">\[\int \sec^4 x \ dx = \int (1 + \tan^2 x) \sec^2 x \ dx\]</span></p><p>设 <span class="math inline">\(u = \tan x\)</span>，有 <spanclass="math inline">\(d u = \sec^2 x \ dx\)</span></p><h4 id="m-是奇数的情况"><span class="math inline">\(m\)</span>是奇数的情况</h4><p>同样是利用式子 <span class="math inline">\(\sec^2 \theta = 1 + \tan^2x\)</span> 代换，例如</p><p><span class="math display">\[\int \sec x \tan^3 x \ dx = \int (\sec^2 x - 1) \ \sec x \ \tan x \ dx\]</span></p><p>设 <span class="math inline">\(u = \sec x\)</span>，有 <spanclass="math inline">\(du = \sec x \ \tan x \ dx\)</span></p><h4 id="n-1-m-0-的情况"><span class="math inline">\(n = 1, m =0\)</span> 的情况</h4><p>对于 <span class="math inline">\(\int \sec x \dx\)</span>，需要利用一点点 ”人类智慧“（这门课的教授称之为”高级猜测“）。</p><p>注意到，<span class="math inline">\(\frac{d}{dx} (\sec x + \tan x) =\sec x \ (\sec x + \tan x)\)</span>，于是</p><p><span class="math display">\[\operatorname{ans} = \int \frac{d (\sec x + \tan x)}{\sec x + \tan x} =\ln(\sec x + \tan x) + c\]</span></p><h2 id="三角换元">三角换元</h2><p>对于一个半径为 <span class="math inline">\(a\)</span>的圆，当我们需要求如图阴影部分的面积时</p><p><img title="" src="https://cdn.jsdelivr.net/gh/lihaoze123/pic/Screenshot_2024-08-05-19-49-16-523_com.jideos.jnotes.png" alt="" width="359" data-align="center" style="zoom: 50%;" ></p><p>可以使用积分 <span class="math inline">\(\int_{t = 0}^{t = x}\sqrt{a^2 - t^2} \ dt\)</span>。</p><p>令 <span class="math inline">\(t = a \sin u\)</span>，有 <spanclass="math inline">\(d t = a \cos u \ d u\)</span>，<spanclass="math inline">\(\sqrt{a^2 - t^2} = a \cos u\)</span></p><p>代入，有</p><p><span class="math display">\[\int_0^x \sqrt{a^2 - t^2} \ dt = a^2 \int_{u = 0}^{u =\sin^{-1}(\frac{x}{a})} \cos^2 u \ du = a^2 (\frac{u}{2} + \frac{\sin u\cos u}{2}) |_0^{\sin^{-1}(\frac{x}{a})}\]</span></p><p>对于形如 <span class="math inline">\(\cos \sin^{-1}\frac{x}{a}\)</span>的式子，可以画一个直角三角形，通过画图可以直观地求解：</p><p><img title="" src="https://cdn.jsdelivr.net/gh/lihaoze123/pic/tikz.svg" alt="" width="291" data-align="center" style="zoom:50%;" ></p><p>如图，不难看出 <span class="math inline">\(\cos \sin^{-1} \frac{x}{a}= \frac{\sqrt{a^2 - x^2}}{a}\)</span>。</p><p>代入原式，得</p><p><span class="math display">\[\begin{aligned}\operatorname{ans} &amp;= a^2 (\frac{\sin^{-1}(\frac{x}{a})}{2} +\frac{1}{2} \frac{x}{a} \frac{\sqrt{a^2 - x^2}}{a}) \\&amp;= \frac{a^2}{2} \sin^{-1}(\frac{x}{a}) + \frac{1}{2} x \sqrt{a^2 -x^2}\end{aligned}\]</span></p><h4 id="可以用三角换元计算的积分">可以用三角换元计算的积分</h4><table><thead><tr class="header"><th style="text-align: center;">积分</th><th style="text-align: center;">换元</th><th style="text-align: center;">对应的三角恒等式</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(\displaystyle\int \frac{d x}{\sqrt{x^2 +1}}\)</span></td><td style="text-align: center;"><span class="math inline">\(x = \tanu\)</span></td><td style="text-align: center;"><span class="math inline">\(\tan^2 u + 1= \sec^2 u\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(\displaystyle\int \frac{d x}{\sqrt{x^2 -1}}\)</span></td><td style="text-align: center;"><span class="math inline">\(x = \secu\)</span></td><td style="text-align: center;"><span class="math inline">\(\sec^2 u - 1= \tan^2 u\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(\displaystyle\int \frac{d x}{\sqrt{1 -x^2}}\)</span></td><td style="text-align: center;"><span class="math inline">\(x = \sinu\)</span></td><td style="text-align: center;"><span class="math inline">\(\sin^2 u +\cos^2 u = 1\)</span></td></tr></tbody></table><h3 id="使用配方计算较为复杂的积分">使用配方计算较为复杂的积分</h3><h4 id="求-int-fracd-xsqrtx2-4x">求 <span class="math inline">\(\int\frac{d x}{\sqrt{x^2 + 4x}}\)</span></h4><p>对下面的二次项配方，有</p><p><span class="math display">\[\int \frac{d x}{\sqrt{x^2+4 x}}=\int \frac{d x}{\sqrt{(x+2)^2-4}}=\int\frac{d x}{2 \sqrt{\left(\frac{x}{2}+1\right)^2-1}}\]</span></p><p>设 <span class="math inline">\(u = \frac{x}{2} + 1\)</span>，有 <spanclass="math inline">\(d u = \frac{d x}{2}\)</span>，代入得</p><p><span class="math display">\[\operatorname{ans} = \int \frac{d u}{\sqrt{u^2 - 1}}\]</span></p><p>利用上面表格中的结论，我们设 <span class="math inline">\(\sec v =u\)</span>，有 <span class="math inline">\(\sec v \tan v \ d v = du\)</span>，继续代入，有</p><p><span class="math display">\[\begin{aligned}\operatorname{ans} &amp; =\int \frac{\sec v \tan v \ d v}{\tan v} \\&amp; =\int \sec v \ d v\end{aligned}\]</span></p><p>继续利用前面得到的结论，我们得到最终结果</p><p><span class="math display">\[\operatorname{ans} = \ln(\sec v + \tan v) + c\]</span></p><p>同样利用上面我们用过的绘图的方法，我们知道 <spanclass="math inline">\(\tan v = \sqrt{u^2 - 1}\)</span>，反向替换，得</p><p><span class="math display">\[\begin{aligned}\operatorname{ans} &amp; = \ln(u + \sqrt{u^2 - 1}) + c \\&amp; = \ln \left(\frac{x}{2} + 1 + \sqrt{\frac{x^2}{4} + x} \right) + c\end{aligned}\]</span></p><p>进一步地，我们将 <span class="math inline">\(\ln\)</span> 中的 <spanclass="math inline">\(\frac{1}{2}\)</span> 提出来，得到最终的结果</p><p><span class="math display">\[\fbox{$\ln \left(x + 2 + \sqrt{x^2 + 4 x} \right) + \tilde{c}$}\]</span></p><p>其中 <span class="math inline">\(\tilde{c} = c - \ln 2\)</span>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>微积分</tag>
      
      <tag>高等数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT18.01 Lec6 指数与对数 学习笔记</title>
    <link href="/MIT18-01-Lec6-%E6%8C%87%E6%95%B0%E4%B8%8E%E5%AF%B9%E6%95%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/MIT18-01-Lec6-%E6%8C%87%E6%95%B0%E4%B8%8E%E5%AF%B9%E6%95%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>最近玩的有点过头了，想趁这个暑假把微积分预习一下，省略前面高中学习过的较简单部分，从<strong>Lecture 6</strong> 开始记录笔记，以增强印象。</p><h2 id="section"></h2><h2 id="指数函数求导">指数函数求导</h2><p>这节课的主要任务是求指数函数的导数，即求 <spanclass="math inline">\(\frac{d}{d x} a^x\)</span>，以下是推导过程。</p><h3 id="ma-的推导"><span class="math inline">\(M(a)\)</span> 的推导</h3><p>根据导数的定义，有</p><p><span class="math display">\[\frac{d}{d x} a^x=\lim _{\Delta x \rightarrow 0} \frac{a^{x+\Deltax}-a^x}{\Delta x}\]</span></p><p>化简，有</p><p><span class="math display">\[\lim _{\Delta x \rightarrow 0} \frac{a^{x+\Delta x}-a^x}{\Delta x}=\lim_{\Delta x \rightarrow 0} a^x \frac{a^{\Delta x}-1}{\Delta x}=a^x \lim_{\Delta x \rightarrow 0} \frac{a^{\Delta x}-1}{\Delta x}\]</span></p><p>不妨设多出来那一部分为魔数 <spanclass="math inline">\(M(a)\)</span>（M 即代表 Magic Number）</p><p><span class="math display">\[M(a) \equiv \lim _{\Delta x \rightarrow 0} \frac{a^{\Delta x}-1}{\Deltax}\]</span></p><p>当 <span class="math inline">\(x = 0\)</span> 时，有</p><p><span class="math display">\[M(a)=\lim _{\Delta x \rightarrow 0} \frac{a^{0+\Delta x}-a^0}{\Deltax}=\left.\frac{d}{d x} a^x\right|_{x=0}\]</span></p><p><span class="math inline">\(M(a)\)</span> 的几何意义即 <spanclass="math inline">\(a^x\)</span> 在 <span class="math inline">\(x =0\)</span> 处的斜率。</p><h3 id="引入自然底数-e">引入自然底数 <spanclass="math inline">\(e\)</span></h3><p>注意到，底数 <span class="math inline">\(a\)</span> 越大，函数 <spanclass="math inline">\(a^x\)</span> 的图像越陡，不难证明存在常数 <spanclass="math inline">\(e\)</span>，使得 <span class="math inline">\(M(e)= 1\)</span>。</p><p>经过上面我们的推导，有</p><p><span class="math display">\[\frac{d}{d x}\left(e^x\right)=M(e) e^x\]</span></p><p>又 <span class="math inline">\(M(e) = 1\)</span>，即</p><p><span class="math display">\[\fbox{ $\frac{d}{d x}\left(e^x\right)=e^x$ }\]</span></p><h3 id="引入自然对数-ln-x">引入自然对数 <span class="math inline">\(\ln(x)\)</span></h3><p>为了更好地了解魔数 <spanclass="math inline">\(M(a)\)</span>，我们引入 <spanclass="math inline">\(\ln (x)\)</span>，它是 <spanclass="math inline">\(e^x\)</span> 的反函数，即</p><p><span class="math display">\[\fbox{If $y = e^x$, then $\ln(y) = x$}\]</span></p><p>我们用 <strong>隐函数求导</strong> 求出 <spanclass="math inline">\(\frac{d}{d x} \ln(x)\)</span>，令 <spanclass="math inline">\(w = \ln(x)\)</span>，有</p><p><span class="math display">\[\begin{aligned}e^w &amp; =x \\\frac{d}{d x}\left(e^w\right) &amp; =\frac{d}{d x}(x) \\\frac{d}{d w}\left(e^w\right) \frac{d w}{d x} &amp; =1 \\e^w \frac{d w}{d x} &amp; =1 \\\frac{d w}{d x} &amp; =\frac{1}{e^w}=\frac{1}{x}\end{aligned}\]</span></p><p>即</p><p><span class="math display">\[\fbox{$\frac{d}{d x} \ln(x) = \frac{1}{x}$}\]</span></p><h3 id="求导">求导</h3><p>对于指数函数 <span class="math inline">\(a^x\)</span>的求导，有两种方法</p><h4 id="利用链式法则">利用链式法则</h4><p>利用 <span class="math inline">\(e^x\)</span> 和 <spanclass="math inline">\(\ln x\)</span> 互为反函数的性质，我们将 <spanclass="math inline">\(a\)</span> 表示为 <spanclass="math inline">\(e^{(\ln a)}\)</span>，有</p><p><span class="math display">\[a^x=\left(e^{\ln (a)}\right)^x=e^{x \ln (a)}\]</span></p><p>所以，有</p><p><span class="math display">\[\begin{aligned}\frac{d}{d x} a^x &amp; = \frac{d}{d x} e^{x \ln (a)} \\&amp; = \ln (a) \cdot e^{x \ln (a)}\end{aligned}\]</span></p><p>即</p><p><span class="math display">\[\fbox{$\frac{d}{d x} a^x = \ln (a) \cdot a^x$}\]</span></p><p>又有</p><p><span class="math display">\[\frac{d}{d x} a^x = M(a) \cdot a^x\]</span></p><p>现在我们知道，魔数 <span class="math inline">\(M(a)\)</span> 即为<span class="math inline">\(\ln(a)\)</span>。</p><h3 id="利用对数微分">利用对数微分</h3><p>相对于寻找原函数的导数，对数微分有时候更为简单，它同样是利用<strong>隐函数求导</strong>。</p><p>我们令 <span class="math inline">\(u = f(x)\)</span>，有</p><p><span class="math display">\[\frac{d}{d x} \ln u = \frac{d}{d u} \ln u \cdot \frac{d u}{d x} =\frac{1}{u} \cdot \frac{d u}{d x} = \frac{u&#39;}{u}\]</span></p><p>即</p><p><span class="math display">\[f&#39; = f \cdot (\ln f)&#39;\]</span></p><p>于是，对于 <span class="math inline">\(f(x) = a^x\)</span>，有</p><p><span class="math display">\[\frac{d}{d x} (\ln f) = \frac{d}{d x} (x \cdot \ln a) = \ln a\]</span></p><p>即</p><p><span class="math display">\[f&#39; = f \cdot (\ln f)&#39; = a^x \cdot \ln a\]</span></p><h2 id="例题">例题</h2><ul><li><span class="math inline">\(\frac{d}{d x} (x^x) = \ ?\)</span></li></ul><p>利用对数微分，其中</p><p><span class="math display">\[\begin{aligned}f &amp; =x^x \\\ln f &amp; =x \ln x \\(\ln f)^{\prime} &amp; =1 \cdot(\ln x)+x\left(\frac{1}{x}\right)=\ln(x)+1\end{aligned}\]</span></p><p>代入上面的结论，有</p><p><span class="math display">\[f&#39; = f \cdot (\ln f)&#39; = x^x \cdot (\ln (x)+1)\]</span></p><ul><li><p><span class="math inline">\(\lim_{k \to \infty} (1 +\frac{1}{k})^k = \ ?\)</span></p><p>同样取对数简化运算，有</p><p><span class="math display">\[\ln (1 + \frac{1}{k})^k = k \cdot \ln (1 + \frac{1}{k})\]</span></p><p>这里利用一个 <em>trick</em>，令 <span class="math inline">\(\Deltax\)</span> 表示 <span class="math inline">\(\frac{1}{k}\)</span>，有</p><p><span class="math display">\[\begin{aligned}\lim_{k \to \infty} \ln (1 + \frac{1}{k})^k &amp; = \lim_{k \to \infty}k \cdot \ln (1 + \frac{1}{k}) \\&amp; = \lim_{\Delta x \to 0} \frac{\ln (1 + \Delta x)}{\Delta x}\end{aligned}\]</span></p><p>再利用一个 <em>trick</em>，注意到 <span class="math inline">\(\ln 1 =0\)</span>（人类智慧，maybe），有</p><p><span class="math display">\[\lim_{\Delta x \to 0} \frac{\ln (1 + \Delta x)}{\Delta x} = \lim_{\Deltax \to 0} \frac{\ln (1 + \Delta x) - \ln 1}{\Delta x}\]</span></p><p>由导数的定义，即</p><p><span class="math display">\[\lim_{k \to \infty} (1 + \frac{1}{k})^k = e^{\frac{d}{d x} \ln x |_{x =1}} = e^{\frac{1}{x} |_{x = 1}} = e\]</span></p><p>利用求出的式子，可以估算出自然底数 <spanclass="math inline">\(e\)</span>。</p></li><li><p>幂函数求导<br />对于幂为实数，利用上述对数微分可以简便地推导出求导公式。<br />由上知，<span class="math inline">\(f&#39; = f \cdot (\lnf)&#39;\)</span>，对于 <span class="math inline">\(f(x) =x^a\)</span>，有</p><p><span class="math display">\[(x^a)&#39; = x^a \cdot (a \ln x)&#39; = x^a \cdot \frac{a}{x} = a \cdotx^{a - 1}\]</span></p><h2 id="参考资料">参考资料</h2></li><li><p>课件 <ahref="https://ocw.mit.edu/courses/18-01-single-variable-calculus-fall-2006/resources/lec6/">Lecture6: Exponential and Log, Logarithmic Differentiation, HyperbolicFunctions | Single Variable Calculus | Mathematics | MITOpenCourseWare</a></p></li><li><p>视频 <ahref="https://ocw.mit.edu/courses/18-01-single-variable-calculus-fall-2006/resources/lecture-6-exponential-and-log/">Lecture6: Exponential and Log | Single Variable Calculus | Mathematics | MITOpenCourseWare</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>微积分</tag>
      
      <tag>高等数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何愉快地在 Linux 下观看带弹幕的番剧</title>
    <link href="/%E5%A6%82%E4%BD%95%E6%84%89%E5%BF%AB%E5%9C%B0%E5%9C%A8-Linux-%E4%B8%8B%E8%A7%82%E7%9C%8B%E5%B8%A6%E5%BC%B9%E5%B9%95%E7%9A%84%E7%95%AA%E5%89%A7/"/>
    <url>/%E5%A6%82%E4%BD%95%E6%84%89%E5%BF%AB%E5%9C%B0%E5%9C%A8-Linux-%E4%B8%8B%E8%A7%82%E7%9C%8B%E5%B8%A6%E5%BC%B9%E5%B9%95%E7%9A%84%E7%95%AA%E5%89%A7/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://cdn.jsdelivr.net/gh/lihaoze123/pic/2024-07-27-173810_screenshot.png" /></p><p>自从之前把主系统换到 Arch Linux 之后，Windows下的一些常规操作都不能，即使是基本的听歌/追番的体验也很差<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="见 https://chumeng.xyz/%E5%9C%A8-Arch-%E4%B8%8A%E4%BD%BF%E7%94%A8-Wine-%E6%9D%A5%E8%BF%90%E8%A1%8C-Lyricify-4-%E6%98%BE%E7%A4%BA%E6%AD%8C%E8%AF%8D/">[1]</span></a></sup>。</p><p>在尝试了半天用 Wine 安装 dandanplay（依赖问题不会解决），使用开源方案KikoPlay （目前 AUR 上面的版本在 Wayland显示协议下有谜之窗口分离问题，且目前版本无法添加巴哈姆特的弹幕）之后，我选择了使用脚本从<a href="https://api.dandanplay.net/swagger/ui/index">弹弹play API</a>获取弹幕，再转换成 mpv 播放器能用的 ASS 字幕格式的方案。</p><h2 id="从-弹弹play-api-获取弹幕">从 弹弹play API 获取弹幕</h2><p>具体的 API 接口说明见 <ahref="https://api.dandanplay.net/swagger/ui/index">弹弹playAPI</a>。</p><h3 id="获取剧集的弹幕库编号">获取剧集的弹幕库编号</h3><p>调用这个 API <code>/api/v2/search/episodes</code> 以搜索剧集的<code>episodeId</code> （单集所对应的弹幕库编号）。</p><p>示例，在命令行使用 <code>curl</code> 搜索 <code>邻座艾莉</code>这部动漫，使用命令行工具 <code>jq</code> 可以直观地解析<code>json</code> 文本以获取单集对应的 <code>episodeId</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -s -X GET --header <span class="hljs-string">&#x27;Accept: application/json&#x27;</span> --data-urlencode <span class="hljs-string">&quot;anime=邻座艾莉&quot;</span> <span class="hljs-string">&#x27;https://api.dandanplay.net/api/v2/search/episodes&#x27;</span> | jq <span class="hljs-string">&#x27;.animes.[].episodes&#x27;</span><br></code></pre></td></tr></table></figure><p>我们会得到这样的文本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;episodeId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">179140001</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;episodeTitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;第1话 用俄语说真心话的艾莉同学&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;episodeId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">179140002</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;episodeTitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;第2话 何为青梅竹马？&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;episodeId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">179140003</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;episodeTitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;第3话 于是他们相遇了&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;episodeId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">179140004</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;episodeTitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;第4话 满溢而出的感情&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;episodeId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">179140005</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;episodeTitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;第5话&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;episodeId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">179140006</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;episodeTitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;第6话&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;episodeId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">179140007</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;episodeTitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;第7话&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;episodeId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">179140008</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;episodeTitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;第8话&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>其中的 <code>episodeId</code> 对应的就是单集的弹幕库编号。</p><h3 id="获取指定弹幕库的弹幕">获取指定弹幕库的弹幕</h3><p>利用以上获取的 <code>episodeId</code>，可以调用这个 API<code>/api/v2/comment/&#123;episodeId&#125;</code> 以获取该集所对应的弹幕。</p><p>以下以第一集为例（<code>179140001</code>）：</p><p>使用 <code>curl</code> 调用该接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -sL -X GET <span class="hljs-string">&#x27;Accept: application/json&#x27;</span> <span class="hljs-string">&#x27;https://api.dandanplay.net/api/v2/comment/179140001/?withRelated=true&#x27;</span><br></code></pre></td></tr></table></figure><p>其中 <code>withRelated</code> 参数可以获取除 <code>dandanplay</code>的弹幕库以外的弹幕。</p><p>我们会得到形如这样的 <code>json</code> 文本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>count<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;comments&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;cid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>cid<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;p&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;time&#125;, &#123;mode&#125;, &#123;color&#125;, &#123;uid&#125;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;m&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;content&#125;&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>其中，<code>p</code> 参数格式为<code>出现时间,模式,颜色,用户ID</code>：</p><ul><li>弹幕出现时间：格式为0.00，单位为秒，精确到小数点后两位，例如12.34、445.6、789.01</li><li>弹幕模式：1-普通弹幕，4-底部弹幕，5-顶部弹幕</li><li>颜色：32位整数表示的颜色，算法为Rx256x256+Gx256+B，R/G/B的范围应是0-255</li><li>用户ID：字符串形式表示的用户ID，通常为数字，不会包含特殊字符</li></ul><h2 id="将-弹弹play-api-中获取的弹幕转换为-acfun-弹幕格式">将 弹弹playAPI 中获取的弹幕转换为 AcFun 弹幕格式</h2><p>AcFun 弹幕格式是形如这样的 <code>json</code> 文本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;c&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;start_time&#125;, &#123;color&#125;, &#123;mode&#125;, &#123;size&#125;, &#123;HASH&#125;, &#123;date&#125;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;m&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;content&#125;&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>其中，<code>c</code> 参数格式为<code>出现时间,颜色,模式,大小,HASH,发送时间</code></p><h3 id="转换格式">转换格式</h3><p>忽略不必要的部分，可以利用命令行工具 <code>jq</code> 将 dandanplay格式的弹幕转换为 AcFun 格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -sL -X GET <span class="hljs-string">&#x27;Accept: application/json&#x27;</span> <span class="hljs-string">&#x27;https://api.dandanplay.net/api/v2/comment/179140001/?withRelated=true&#x27;</span> | jq <span class="hljs-string">&#x27;.comments | map(&#123;c: (.p | split(&quot;,&quot;) | [.[0], .[2], .[1], &quot;18&quot;, .[3], &quot;0&quot;] | join(&quot;,&quot;)), m: .m&#125;)&#x27;</span> &gt; danmuku.json<br></code></pre></td></tr></table></figure><p>通过上述命令，我们得到包括 AcFun 弹幕格式的弹幕文件<code>danmuku.json</code>。</p><h2 id="将-acfun-弹幕格式转换为播放器适用的-ass-字幕格式">将 AcFun弹幕格式转换为播放器适用的 ASS 字幕格式</h2><p>利用在线工具 <ahref="https://tiansh.github.io/us-danmaku/acfun/">AcFun ASS弹幕在线转换</a> 可以将 AcFun 弹幕格式转换为播放器适用的 ASS字幕格式。</p><h2 id="使用-mpv-播放器观看弹幕">使用 MPV 播放器观看弹幕</h2><p>默认选项下，MPV 播放器对双字幕的支持不佳，且弹幕帧率过低。</p><p>前者需要在播放时添加选项<code>--secondary-sub-ass-override</code>。</p><p>后者需要在MPV 播放器的配置文件 <code>~/.config/mpv/mpv.conf</code>添加如下参数：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">vf</span><span class="hljs-operator">=</span>lavfi<span class="hljs-operator">=</span><span class="hljs-string">&quot;fps=fps=144:round=down&quot;</span><br></code></pre></td></tr></table></figure><p>其中帧数 <code>144</code> 视情况而定。</p><p>自此已经能观看弹幕了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mpv --secondary-sub-ass-override --sid=1 --secondary-sid=3 --sub-file=<span class="hljs-variable">$HOME</span>/Downloads/_第1话\ 用俄语说真心话的艾莉同学_.ass \[Nekomoe\ kissaten\&amp;LoliHouse\]\ Tokidoki\ Bosotto\ Russia-go\ de\ Dereru\ Tonari\ no\ Alya-san\ -\ 01\ \[WebRip\ 1080p\ HEVC-10bit\ AAC\ ASSx2\].mkv<br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/lihaoze123/pic/2024-07-27-185741_screenshot.png" /></p><h2 id="使用脚本简化操作">使用脚本简化操作</h2><p>对于上述操作，有 <code>fish</code> 脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs fish">function select_option<br>    set options $argv<br>    set selected &quot;&quot;<br>    set index &quot;&quot;<br><br>    while test -z &quot;$selected&quot;<br>        for i in (seq (count $options))<br>            echo &quot;$i) $options[$i]&quot; &gt; /dev/tty<br>        end<br><br>        read -l -P &quot;请选择一个选项 (1-&quot;(count $options)&quot;): &quot; choice<br><br>        if test &quot;$choice&quot; -ge 1 -a &quot;$choice&quot; -le (count $options) 2&gt;/dev/null<br>            set selected $options[$choice]<br>            set index $choice<br>        else<br>            echo &quot;无效选择,请重试&quot;<br>        end<br>    end<br><br>    echo $selected<br>    echo $index<br>end<br><br>function danmku<br>    set anime $argv[1]<br><br>    set animeRes (curl -s -X GET --header &#x27;Accept: application/json&#x27; --data-urlencode &quot;anime=&#x27;$anime&#x27;&quot; &#x27;https://api.dandanplay.net/api/v2/search/episodes&#x27;)<br>    set episodes (echo $animeRes | jq &#x27;.animes.[].episodes&#x27;)<br><br>    set titles (echo $episodes | jq &#x27;map(.episodeTitle) | .[]&#x27;)<br>    set selected (select_option $titles)    <br>    set episodeTitle $selected[1]<br>    set index $selected[2]<br><br>    set episodeId (echo $episodes | jq &#x27;.[&#x27;$index&#x27;-1].episodeId&#x27;)<br><br>    curl -sL -X GET &#x27;Accept: application/json&#x27; &#x27;https://api.dandanplay.net/api/v2/comment/&#x27;$episodeId&#x27;/?withRelated=true&#x27; | jq &#x27;.comments | map(&#123;c: (.p | split(&quot;,&quot;) | [.[0], .[2], .[1], &quot;18&quot;, .[3], &quot;0&quot;] | join(&quot;,&quot;)), m: .m&#125;)&#x27; &gt; $episodeTitle.json<br><br>    echo $episodeId<br><br>    echo &quot;已下载并转换为 json 格式弹幕 (Acfun) 的剧集 $anime.json ($episodeTitle)&quot;<br>end<br></code></pre></td></tr></table></figure><p>通过该脚本可以较为方便地下载 AcFun 弹幕格式的 <code>json</code>弹幕文件。</p><h2 id="使用-kikoplay-播放器观看弹幕">使用 KikoPlay 播放器观看弹幕</h2><p>KikoPlay 是基于 <code>libmpv</code> 播放内核的弹幕播放器，具有<code>WebDav</code>、<code>资料库</code>、<code>aria2 下载</code>等功能，提供了较为完善的追番体验<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://github.com/KikoPlayProject/KikoPlay">[2]</span></a></sup>。</p><p>但是在目前阶段还存在一些需要改进的地方：</p><ul><li><p>在 Wayland 显示协议下直接运行会造成主窗口和播放窗口分离</p><p>解决方法是是切换为X11显示协议，或者使用xwayland兼容层来运行。要强制在Wayland会话中使用X11(需要安装xwayland)，则需要添加“QT_QPA_PLATFORM=xcb”参数。<br />同时关闭 <code>进度条预览</code> 选项。</p></li><li><p>巴哈姆特动画疯的弹幕无法添加</p><p>尚不确定是笔者网络代理的问题，还是播放器自身弹幕下载脚本的问题。由于目前大部分的新番叔叔都没有买，动画疯弹幕的缺失会大大影响弹幕观看体验。</p><p>笔者的解决方案是用脚本把 AcFun 的 json 格式的弹幕转换成 bilibili 的xml 格式的弹幕，再用 KikoPlay加载本地弹幕<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="KikoPlay 仅支持导入 BiliBili 的 xml 格式弹幕">[3]</span></a></sup>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> xml.etree.ElementTree <span class="hljs-keyword">as</span> ET<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_acfun_to_bilibili</span>(<span class="hljs-params">acfun_json</span>):<br>    root = ET.Element(<span class="hljs-string">&#x27;i&#x27;</span>)<br><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> acfun_json:<br>        d = ET.SubElement(root, <span class="hljs-string">&#x27;d&#x27;</span>)<br>        <br>        c_parts = item[<span class="hljs-string">&#x27;c&#x27;</span>].split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>        <br>        time = c_parts[<span class="hljs-number">0</span>]<br>        color = c_parts[<span class="hljs-number">1</span>]<br>        size = c_parts[<span class="hljs-number">2</span>]<br>        uid = c_parts[<span class="hljs-number">4</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c_parts) &gt; <span class="hljs-number">4</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;0&#x27;</span><br>        <br>        p = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;time&#125;</span>,1,<span class="hljs-subst">&#123;size&#125;</span>,<span class="hljs-subst">&#123;color&#125;</span>,0,0,<span class="hljs-subst">&#123;uid&#125;</span>,0&quot;</span><br>        d.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;p&#x27;</span>, p)<br>        <br>        d.text = item[<span class="hljs-string">&#x27;m&#x27;</span>]<br><br>    <span class="hljs-keyword">return</span> ET.tostring(root, encoding=<span class="hljs-string">&#x27;unicode&#x27;</span>, method=<span class="hljs-string">&#x27;xml&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(sys.argv[<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                acfun_json = json.load(f)<br>        <span class="hljs-keyword">except</span> FileNotFoundError:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;文件 &#x27;<span class="hljs-subst">&#123;sys.argv[<span class="hljs-number">1</span>]&#125;</span>&#x27; 不存在。请输入JSON数据:&quot;</span>)<br>            acfun_json = json.loads(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请输入AcFun JSON弹幕数据:&quot;</span>)<br>        acfun_json = json.loads(<span class="hljs-built_in">input</span>())<br><br>    bilibili_xml = convert_acfun_to_bilibili(acfun_json)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;转换后的Bilibili XML弹幕:&quot;</span>)<br><br>    filename = sys.argv[<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename + <span class="hljs-string">&#x27;.xml&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(bilibili_xml)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已保存到 &#123;&#125;.xml&quot;</span>.<span class="hljs-built_in">format</span>(filename))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="update">2024.7.31 update</h2><p>使用接口 <code>/api/v2/match</code>可以更精确地匹配节目信息，结合下列脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs fish">function danmaku<br>    set filePath $argv[1]<br>    set hash (dd if=$filePath bs=1M count=16 2&gt;/dev/null | md5sum | cut -d &#x27; &#x27; -f 1)<br>    <br>    set fileName (basename $filePath | cut -d &#x27;.&#x27; -f 1)<br><br>    set episodeRes (curl -s -X POST -H &quot;Content-Type: application/json&quot; -d &quot;&#123;\&quot;fileName\&quot;:\&quot;$fileName\&quot;,\&quot;fileHash\&quot;:\&quot;$hash\&quot;&#125;&quot; &quot;https://api.dandanplay.net/api/v2/match&quot;)<br><br>    echo $episodeRes<br><br>    set episodeId (echo $episodeRes | jq &#x27;.matches[0].episodeId&#x27;)<br>    echo $episodeId<br><br>    curl -sL -X GET &#x27;Accept: application/json&#x27; &#x27;https://api.dandanplay.net/api/v2/comment/&#x27;$episodeId&#x27;/?withRelated=true&#x27; | jq &#x27;.comments | map(&#123;c: (.p | split(&quot;,&quot;) | [.[0], .[2], .[1], &quot;18&quot;, .[3], &quot;0&quot;] | join(&quot;,&quot;)), m: .m&#125;)&#x27; &gt; $fileName.json<br><br>    echo &quot;已下载并转换为 json 格式弹幕 (Acfun) 的剧集 $fileName&quot;<br><br>    AcFunDanmuku2Bili.py $fileName.json<br>    echo &quot;已转换为 xml 格式弹幕 (BiliBili) 的剧集 $fileName&quot;<br><br>    rm $fileName.json<br>end<br></code></pre></td></tr></table></figure><p>同时利用 <strong>KikoPlay</strong> 播放器的<code>自动加载本地同名弹幕文件</code> 功能可以方便地观看</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>见https://chumeng.xyz/%E5%9C%A8-Arch-%E4%B8%8A%E4%BD%BF%E7%94%A8-Wine-%E6%9D%A5%E8%BF%90%E8%A1%8C-Lyricify-4-%E6%98%BE%E7%A4%BA%E6%AD%8C%E8%AF%8D/<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://github.com/KikoPlayProject/KikoPlay<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>KikoPlay 仅支持导入 BiliBili的 xml 格式弹幕<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>动漫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>armv7l 架构交叉编译踩坑及群晖 218j 环境配置记录</title>
    <link href="/armv7l-%E6%9E%B6%E6%9E%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E8%B8%A9%E5%9D%91%E5%8F%8A%E7%BE%A4%E6%99%96-218j-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/armv7l-%E6%9E%B6%E6%9E%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E8%B8%A9%E5%9D%91%E5%8F%8A%E7%BE%A4%E6%99%96-218j-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<figure><imgsrc="https://cdn.jsdelivr.net/gh/lihaoze123/pic/image-20240222020421900.png"alt="image-20240222020421900" /><figcaption aria-hidden="true">image-20240222020421900</figcaption></figure><p>记录配置群晖 218j (armv7l 架构)常用环境，仅作为记录。关于交叉编译网络上的资料比较少，很多地方踩了很多坑，有一些心得，同时群晖自带的套件中心套件很少，本人的型号没有什么第三方库，想要装一个<code>aria2</code> 网络上能查到的资料都很少，且 <code>DSM7.0</code>之后本来能用的方法也失效了，即使装了 <code>Entware</code>，很多包版本也是落后的，只能自己编译，所以本文可能有参考价值。但<strong>这不是一篇参考指南</strong>，编译等操作本就门槛不低，而且相比常规的编译，<code>armv7l</code>架构不管是本地编译还是交叉编译都非常抽象，比较基本的操作我也都省略了，也懒得截图。很多地方不一定是标准操作，仅供参考。</p><p><strong>本人交叉编译时踩的坑</strong></p><ul><li><p>有调试编译了一整天，最后发 issue才知道不支持交叉编译的（不写在文档里，issue里也没有相关的说话）。</p></li><li><p>也有搞了半天依赖都编译不出来的，结果人家开发者最近已经不用这个依赖，发过pull request 了的。</p></li><li><p>群晖自带的内核版本太低,有的即使调试一整天，系统调用也可能会报错。</p></li></ul><p>总之交叉编译，特别是给 <code>armv7l</code>编译是一件很麻烦的事，网上几乎查不到资料，下文给出的配置文件 (针对armv7l)对于大部分软件应该是适用的，但是具体到每个软件里还得看情况，即使都用的是<code>make</code>，<code>configure</code>，<code>cmake</code>，但是具体到参数里也不一定通用，如果条件允许尽量本地编译。</p><p>对于莫名其妙的问题，善用 <code>StackOverFlow</code> 和<code>Google</code>或许会有帮助，或者可能是项目本身的问题，尽量下载最近的 release进行编译，很多时候直接编译 <code>git master</code> 不一定是好选择 。</p><p><img src="https://cdn.jsdelivr.net/gh/lihaoze123/pic/image-20240220212953861.png" alt="image-20240220212953861" style="zoom:50%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/lihaoze123/pic/image-20240220212851797.png" alt="image-20240220212851797" style="zoom:50%;" /></p><h2 id="关于-root-账号的配置">关于 root 账号的配置</h2><ol type="1"><li><p><code>sudo -i</code> 切换到 <code>root</code> 账号</p></li><li><p>更改 <code>root</code> 密码</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">synouser --setpw root password</span><br></code></pre></td></tr></table></figure></p></li><li><p>更改 <code>ssh</code> 账号登录限制，修改<code>/etc/ssh/sshd_config</code>(<code>synosystemctl restart sshd</code> 重启)</p><p><code>PermitRootLogin</code> 项改为 <code>yes</code></p><p><code>PubkeyAuthentication</code> 项取消注释</p></li><li><p>本机修改 <code>~/.ssh/config</code></p><p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host MyNAS<br>    HostName <span class="hljs-number">192.168</span>.<span class="hljs-number">50.125</span><br>    Port <span class="hljs-number">22</span><br>    <span class="hljs-keyword">User</span> <span class="hljs-title">root</span><br></code></pre></td></tr></table></figure></p></li><li><p>上传公钥</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-copy-id -i ~/.ssh/id_ed25519.pub MyNAS</span><br></code></pre></td></tr></table></figure></p></li></ol><h2 id="交叉编译环境配置">交叉编译环境配置</h2><ol type="1"><li><p>下载 <ahref="https://help.synology.com/developer-guide/compile_applications/download_dsm_tool_chain.html">DSMTool Chain</a></p></li><li><p>下载 <ahref="https://releases.linaro.org/components/toolchain/binaries/7.5-2019.12/arm-linux-gnueabihf/">arm-linux-gnueabihftool chain</a></p></li><li><p><code>CMake toolchain</code> 配置实例(<code>arm-unknown-linux-gnueabi.toolchain.cmake</code>)</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(CMAKE_SYSTEM_NAME Linux)<br><span class="hljs-keyword">set</span>(CMAKE_SYSTEM_PROCESSOR arm)<br><br><span class="hljs-keyword">set</span>(CMAKE_C_COMPILER <span class="hljs-string">&quot;arm-unknown-linux-gnueabi-gcc&quot;</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_COMPILER <span class="hljs-string">&quot;arm-unknown-linux-gnueabi-g++&quot;</span>)<br><br><span class="hljs-keyword">set</span>(CMAKE_FIND_ROOT_PATH <span class="hljs-string">&quot;/home/chumeng/cross_compile/arm-unknown-linux-gnueabi/arm-unknown-linux-gnueabi/lib&quot;</span>)<br><br><span class="hljs-keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)<br><br><span class="hljs-keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)<br><span class="hljs-keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)<br></code></pre></td></tr></table></figure> 编译命令</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmake -DCMAKE_TOOLCHAIN_FILE=~/cross_compile/arm-unknown-linux-gnueabi.toolchain.cmake -DCMAKE_INSTALL_PREFIX=/home/chumeng/cross_compile/arm-unknown-linux-gnueabi/arm-unknown-linux-gnueabi ..</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>Rust</code> 交叉编译环境</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">rustup target add armv7-unknown-linux-gnueabihf</span><br></code></pre></td></tr></table></figure></p><p>配置文件实例 (<code>.cargo/config.toml</code>)</p><p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[build]</span><br><span class="hljs-attr">target</span> = <span class="hljs-string">&quot;armv7-unknown-linux-gnueabihf&quot;</span><br><br><br><span class="hljs-section">[target.armv7-unknown-linux-gnueabihf]</span><br><span class="hljs-attr">linker</span> = <span class="hljs-string">&quot;arm-unknown-linux-gnueabi-gcc&quot;</span><br></code></pre></td></tr></table></figure></p><p>编译命令</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cargo build --release --target=armv7-unknown-linux-gnueabihf</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>Go</code> 交叉编译</p><p>编译命令</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">CC=arm-unknown-linux-gnueabi-gcc CXX=arm-unknown-linux-gnueabi-g++ AR=arm-unknown-linux-gnueabi-ar  GOARM=7 GOOS=linux GOARCH=arm go build<br></code></pre></td></tr></table></figure></p></li></ol><h2 id="一些必要的工作">一些必要的工作</h2><p><strong>!! 轻易不要乱动 <code>/usr</code> 目录 !!</strong></p><p>本人因为乱改 <code>/usr</code> 重装了很多次系统，有一次提前准备了<code>busybox</code>，但是是动态链接的，环境都配的差不多了，只能前功尽弃，所以提前备好一些常用工具非常重要。</p><h3 id="交叉编译静态-rsync">交叉编译静态 rsync</h3><ol type="1"><li><p>编译 <a href="https://github.com/Cyan4973/xxHash">xxhash</a>，<ahref="https://github.com/lz4/lz4">lz4</a></p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">CC=arm-linux-gnueabihf-gcc make -j32</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">prefix=~/cross_compile/arm-unknown-linux-gnueabi/arm-unknown-linux-gnueabi make install</span><br></code></pre></td></tr></table></figure></p></li><li><p>编译 <a href="https://github.com/facebook/zstd/">zstd</a></p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> build/cmake</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make build &amp;&amp; <span class="hljs-built_in">cd</span> build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmake -DCMAKE_TOOLCHAIN_FILE=~/cross_compile/arm-unknown-linux-gnueabi.toolchain.cmake -DCMAKE_INSTALL_PREFIX=/home/chumeng/cross_compile/arm-unknown-linux-gnueabi/arm-unknown-linux-gnueabi ..</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make -j32</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make install</span><br></code></pre></td></tr></table></figure></p></li><li><p>编译 <a href="https://github.com/WayneD/rsync">rsync</a></p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./configure CFLAGS=<span class="hljs-string">&quot;-static&quot;</span>  --host=arm-unknown-linux-gnueabi --prefix=/home/chumeng/rsync-static --disable-md2man --disable-openssl</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make -j32</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">arm-unknown-linux-gnueabi-strip rsync</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make install</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mv</span> ~/rsync-static/bin/rsync ~/rsync-static/bin/rsync-static</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">scp -r -O ~/rsync-static MyNAS:/root/</span><br></code></pre></td></tr></table></figure></p></li></ol><h3 id="交叉编译静态-busybox">交叉编译静态 BusyBox</h3><ol type="1"><li><p>配置编译选项(<code>.config</code>)</p><p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs diff"># config.patch<br><br>44c44<br>&lt; # CONFIG_STATIC is not set<br><span class="hljs-comment">---</span><br>&gt; CONFIG_STATIC=y<br>51c51<br>&lt; CONFIG_CROSS_COMPILER_PREFIX=&quot;&quot;<br><span class="hljs-comment">---</span><br>&gt; CONFIG_CROSS_COMPILER_PREFIX=&quot;arm-unknown-linux-gnueabi-&quot;<br></code></pre></td></tr></table></figure></p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://git.busybox.net/busybox</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> busybox</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make defconfig</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">patch .config config.patch</span><br></code></pre></td></tr></table></figure></p></li><li><p>编译</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make -j32</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">scp -r -O _install MyNAS:/root/busybox</span><br></code></pre></td></tr></table></figure></p></li></ol><h2 id="fish-shell-配置">Fish shell 配置</h2><ol type="1"><li><p><del>编译 <code>ncurses</code></del>(链接非常痛苦，开发组计划去除ncurses，这是我浪费一上午编译不出来忍无可忍发 issue 得到的答复，拉取 <ahref="https://github.com/fish-shell/fish-shell/pull/10269">Remove(n)curses dependency by faho · Pull Request #10269</a> 可解)</p></li><li><p>编译</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmake -DRust_CARGO_TARGET=armv7-unknown-linux-gnueabihf ..</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make &amp;&amp; arm-unknown-linux-gnueabi-strip fish</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmake --install . --prefix ~/fish</span><br></code></pre></td></tr></table></figure></p><ol type="1"><li>安装</li></ol><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ~/fish</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">scp -r -O etc bin MyNAS:/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">scp -r -O share MyNAS:/usr/local/</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Target</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mv</span> /bin/ash /bin/ash.bak</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ln</span> -s /bin/fish /bin/ash</span><br></code></pre></td></tr></table></figure></p></li><li><p>添加 <code>PATH</code> 路径</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p /volume1/software/bin</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p /volume1/software/.cargo/bin</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">fish_add_path /volume1/software/bin /volume1/software/.cargo/bin /opt/bin /usr/local/bin</span><br></code></pre></td></tr></table></figure></p></li></ol><h2 id="环境配置">环境配置</h2><h3 id="改-lib-脚本">改 lib 脚本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs fish"># ~/.config/fish/functions/change-lib.fish<br><br>set prefix /opt<br><br>function change-lib<br>    if not test &quot;$no_change_lib&quot; = &quot;true&quot;<br>        patchelf --set-rpath $prefix/usr/lib $argv<br>    end<br>end<br><br>function change-interpreter<br>    if not test &quot;$no_change_interpreter&quot; = &quot;true&quot;<br>        patchelf --set-interpreter $prefix/usr/lib/ld-linux-armhf.so.3 $argv<br>    end<br>end<br><br>function change<br>change-lib $argv<br>change-interpreter $argv<br>end<br></code></pre></td></tr></table></figure><h3 id="安装-patchelf-以修改-elf">安装 patchelf 以修改 ELF</h3><p>系统自带的库文件版本太老，很多程序不能正常运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> --depth=1 https://github.com/NixOS/patchelf.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> patchelf</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./bootstrap.sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./configure CXXFLAGS=<span class="hljs-string">&quot;-static&quot;</span> --host=arm-unknown-linux-gnueabi --prefix=/home/chumeng/patchelf</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make -j32</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make install-strip</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay patchelf</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">scp -r -O /home/chumeng/patchelf/* MyNAS:/</span><br></code></pre></td></tr></table></figure><h3 id="安装-entware">安装 Entware</h3><p>参考 <ahref="https://github.com/Entware/Entware/wiki/Install-on-Synology-NAS">Installon Synology NAS</a></p><h3 id="命令行相关">命令行相关</h3><h4 id="常用软件">常用软件</h4><ul><li><strong>neovim</strong> 编辑器 <code>opkg install neovim</code></li><li><strong>git</strong> 版本管理工具<code>opkg install git git-http</code></li><li><strong>tmux</strong> 终端复用器 <code>opkg install tmux</code></li><li><strong>nodejs</strong> JavaScript 运行环境<code>opkg install node node-npm</code></li><li><strong>python</strong> 常用语言 参考 <ahref="https://github.com/Entware/Entware/wiki/Self-installation-of-python-modules">Entware页面</a></li><li><strong>ranger</strong> 管理文件<code>HOME=/volume1/software/python pip install ranger-fm</code></li><li><strong><ahref="https://github.com/TheLocehiliosan/yadm">yadm</a></strong> 管理dotfiles 参考 <a href="https://yadm.io/docs/install#openwrt">yadm文档页面</a></li><li><a href="https://github.com/sharkdp/bat"><strong>bat</strong></a>替代 cat <strong>使用 cargo 交叉编译</strong></li><li><strong><ahref="https://github.com/jesseduffield/lazygit">lazygit</a></strong> gitGUI <strong>使用 go 交叉编译</strong></li><li><strong><ahref="https://github.com/hykilpikonna/hyfetch">hyfetch</a></strong>命令行系统信息工具 <strong>pip 安装</strong></li></ul><h4 id="配置-dotfile">配置 dotfile</h4><p>这是我的 <strong><ahref="https://github.com/lihaoze123/dotfiles">dotfiles</a></strong>仓库，可以参考一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yadm <span class="hljs-built_in">clone</span> https://github.com/lihaoze123/dotfiles</span><br></code></pre></td></tr></table></figure><h3 id="nas-相关">NAS 相关</h3><h4 id="ddns-go">ddns-go</h4><p>个别 DNS 服务商无法访问，需要配置 proxy，这个没什么说的</p><ol type="1"><li><p>使用 go 交叉编译</p></li><li><p>安装服务</p></li></ol><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ddns-go -s install</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl <span class="hljs-built_in">enable</span> ddns-go.service</span><br></code></pre></td></tr></table></figure></p><ol start="3" type="1"><li>修改 <code>EnvironmentFile</code> (<code>ddns-go</code> 读取不了<code>fish</code> 设置的环境变量，需要配置<code>EnvironmentFile</code>)</li></ol><p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># /etc/sysconfig/ddns-go</span><br><br><span class="hljs-attr">HTTP_PROXY</span>=http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7890</span><br><span class="hljs-attr">HTTPS_PROXY</span>=http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7890</span><br></code></pre></td></tr></table></figure></p><h4 id="transmission">Transmission</h4><ol type="1"><li><strong>安装</strong> 参考 <ahref="https://github.com/Entware/Entware/wiki/Using-Transmission">UsingTransmission</a></li><li>修改 <code>/opt/etc/transmission/settings.json</code> 中<code>rpc-bind-address</code> 项为 <code>::</code> 以支持 IPv6(首先关闭进程)</li></ol><h4 id="aria2">aria2</h4><ol type="1"><li><strong>安装</strong> 参考 <ahref="https://github.com/Entware/Entware/wiki/Using-Aria2">UsingAria2</a></li><li>下载 <strong><ahref="https://github.com/mayswind/AriaNg">AriaNG</a></strong>，放在<code>/volume1</code> 的子目录中</li><li>群晖自带套件 <code>WebStation</code> 中<code>网页服务门户 - 新增 - 虚拟主机</code> 中 <code>门户类型</code>选基于端口，设置端口，下一步选择网页文件放置的目录</li><li>同理选基于名称，设置域名，端口以支持域名访问</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>NAS</tag>
      
      <tag>编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Arch 上使用 Wine 来运行 Lyricify 4 显示歌词</title>
    <link href="/%E5%9C%A8-Arch-%E4%B8%8A%E4%BD%BF%E7%94%A8-Wine-%E6%9D%A5%E8%BF%90%E8%A1%8C-Lyricify-4-%E6%98%BE%E7%A4%BA%E6%AD%8C%E8%AF%8D/"/>
    <url>/%E5%9C%A8-Arch-%E4%B8%8A%E4%BD%BF%E7%94%A8-Wine-%E6%9D%A5%E8%BF%90%E8%A1%8C-Lyricify-4-%E6%98%BE%E7%A4%BA%E6%AD%8C%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/WXRIW/Lyricify-App">Lyricify 4</a>是一款为 Spotify 提供滚动歌词和更多功能的软件。作为一个歌词软件，Lyricify 4简洁美观，但在可预见的未来，作者似乎没有计划提供 Linux版本<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://github.com/WXRIW/Lyricify-App/issues/203#issuecomment-1817454324">[1]</span></a></sup>。遗憾的是目前来说似乎并没有其他可替代的方案来在 Linux 系统上面显示Spotify 歌词，于是在 Linux 系统中唯一的方法就是使用 Wine 来运行 Windows端的 Lyricify 程序。</p><h2 id="lyricify-on-wine">Lyricify-on-Wine</h2><p>笔者经过多次尝试，发现很难准确地安装必要的依赖，始终无法正常启动。后来发现了GitHub 仓库 <ahref="https://github.com/Lyricify/Lyricify-on-Wine">Lyricify-on-Wine</a>，其中预装了用于 Lyricify 4 的依赖库，对于 Debian系的系统<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="即使用 deb 软件包格式的发行版">[2]</span></a></sup>来说，该仓库提供的<code>deb</code> 包文件已经足够方便，但是对于其他发行版来说，一个<code>deb</code> 包文件并不能提供很大的帮助。笔者解包后对照包内的脚本探索出了私以为在 Arch系统上比较方便的使用方法，虽然步骤不多但是每一步都花费了笔者很多精力研究。</p><h2 id="安装">安装</h2><ul><li><p>安装要用到的程序<strong>spark-dwine-helper</strong>，<strong>dpkg</strong> 和<strong>7z</strong> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo pacman -S spark-dwine-helper dpkg p7zip<br></code></pre></td></tr></table></figure></p></li><li><p>下载 <ahref="https://github.com/Lyricify/Lyricify-on-Wine">Lyricify-on-Wine</a>仓库提供的 <code>.deb</code> 包，并解包，剩余的文件可以自行删除<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl -OL https://github.com/Lyricify/Lyricify-on-Wine/releases/download/Lyricify4/com.wxriw.lyricify4_4.2.28.240502-release-wpack240503.02_amd64.deb<br>$ dpkg -X com.wxriw.lyricify4_4.2.28.240502-release-wpack240503.02_amd64.deb Lyricify<br>$ <span class="hljs-built_in">mv</span> Lyricify/opt/apps/com.wxriw.lyricify4/files/files.7z Lyricify/opt/apps/com.wxriw.lyricify4/files/wine_archive.7z .<br>$ 7z x wine_archive.7z -o./Wine-for-Lyricify<br>$ 7z x files.7z -o./Lyricify<br>$ <span class="hljs-built_in">rm</span> *7z<br></code></pre></td></tr></table></figure></p></li><li><p>将 <code>Lyricify</code> 文件夹移动到<strong>spark-dwine-helper</strong> 所对应的默认 <code>WINEPREFIX</code>路径 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mv</span> Lyricify/ ~/.deepinwine/<br></code></pre></td></tr></table></figure></p></li></ul><h2 id="运行">运行</h2><p>至此应该已经能正常地运行 Lyricify 4，这里假设最初的工作目录是<code>~/.Lyricify</code> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ APPRUN_CMD=~/.Lyricify/Wine-for-Lyricify/bin/wine64 /opt/deepinwine/tools/spark_run_v4.sh <span class="hljs-string">&quot;Lyricify&quot;</span> <span class="hljs-string">&quot;4.2.28.240502-release-wpack240503.02&quot;</span> <span class="hljs-string">&quot;C:/Program Files/Lyricify 4/Lyricify for Spotify.exe&quot;</span><br></code></pre></td></tr></table></figure></p><h2 id="编写-.desktop-文件以将应用程序集成到应用程序菜单中">编写<code>.desktop</code> 文件以将应用程序集成到应用程序菜单中</h2><p>编辑<code>~/.local/share/applications/com.wxriw.lyricify4.desktop</code>文件 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#!/usr/bin/env xdg-open</span><br><span class="hljs-section">[Desktop Entry]</span><br><span class="hljs-attr">Encoding</span>=UTF-<span class="hljs-number">8</span><br><span class="hljs-attr">Type</span>=Application<br><span class="hljs-attr">Categories</span>=Audio<span class="hljs-comment">;</span><br><span class="hljs-comment"># 安装时该文件的相对路径应该是</span><br><span class="hljs-comment"># ./opt/apps/com.wxriw.lyricify4/entries/icons/hicolor/scalable/apps/com.wxriw.lyricify4.png</span><br><span class="hljs-attr">Icon</span>=~/.Lyricify/com.wxriw.lyricify4.png<br><span class="hljs-attr">Exec</span>=<span class="hljs-string">&quot;~/.Lyricify/run.sh&quot;</span> --uri <br><span class="hljs-attr">Name</span>=Lyricify<br><span class="hljs-attr">Comment</span>=Lyricify <span class="hljs-number">4</span> in a Wine container<br><span class="hljs-attr">MimeType</span>=<br><span class="hljs-attr">GenericName</span>=com.wxriw.lyricify4<br><span class="hljs-attr">Terminal</span>=<span class="hljs-literal">false</span><br><span class="hljs-attr">StartupNotify</span>=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></p><p>编写 <code>~/.Lyricify/run.sh</code> 文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">export</span> APPRUN_CMD=~/.Lyricify/Wine-for-Lyricify/bin/wine64 <br>/opt/deepinwine/tools/spark_run_v4.sh <span class="hljs-string">&quot;Lyricify&quot;</span> <span class="hljs-string">&quot;4.2.28.240502-release-wpack240503.02&quot;</span> <span class="hljs-string">&quot;C:/Program Files/Lyricify 4/Lyricify for Spotify.exe&quot;</span><br></code></pre></td></tr></table></figure></p><h2 id="一些可能的问题">一些可能的问题</h2><ul><li>在进行 Spotify 授权的时候浏览器无法正常弹出，需要点击左下角的<code>登录时遇到问题？</code> 按钮手动打开浏览器授权。</li><li>应用界面出现奇怪的显示问题，打开<code>设置-Apple Music 歌词-背景-动态</code> 可以缓解该问题。</li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://github.com/WXRIW/Lyricify-App/issues/203#issuecomment-1817454324<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>即使用 deb软件包格式的发行版<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Wine</tag>
      
      <tag>Arch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些用语的约定</title>
    <link href="/%E4%B8%80%E4%BA%9B%E7%94%A8%E8%AF%AD%E7%9A%84%E7%BA%A6%E5%AE%9A/"/>
    <url>/%E4%B8%80%E4%BA%9B%E7%94%A8%E8%AF%AD%E7%9A%84%E7%BA%A6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h3 id="伪代码">伪代码</h3><h4 id="约定">约定</h4><p>我们在伪代码中采用以下约定（参考《算法导论》，使用 <spanclass="math inline">\(\LaTeX\)</span> 书写）</p><ol type="1"><li><p>缩进表示块结构。</p></li><li><p><span class="math inline">\(\textbf{while}\)</span>, <spanclass="math inline">\(\textbf{for}\)</span>, <spanclass="math inline">\(\textbf{repeat-until}\)</span> 等循环结构以及<span class="math inline">\(\textbf{if-else}\)</span> 等条件结构与C，C++，Java，Python，和 Pascal 中的那些结构具有类似的解释。</p><p>退出循环后，循环计数器保持其值。</p><p>当一个 <span class="math inline">\(\textbf{for}\)</span>循环每次迭代增加其循环计数器时，我们使用关键词 <spanclass="math inline">\(\textbf{to}\)</span>，反之使用 <spanclass="math inline">\(\textbf{downto}\)</span>。</p><p>当循环计数器以大于一的一个量改变时，该改变量跟在可选关键词 <spanclass="math inline">\(\textbf{by}\)</span> 之后。 例：<spanclass="math inline">\(\textbf{for} \ i = 1 \ \textbf{to} \ A.length \\textbf{by} \ 2\)</span></p></li><li><p>符号 “<span class="math inline">\(\text{//}\)</span>”表示该行后面部分是个注释。</p></li><li><p>形如 <span class="math inline">\(i=j=e\)</span>的多重赋值将表达式 <span class="math inline">\(e\)</span> 的值赋给变量<span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span>；它应该被处理成等价于赋值 <spanclass="math inline">\(j=e\)</span> 后跟着赋值 <spanclass="math inline">\(i=j\)</span>。</p></li><li><p>变量（如 <span class="math inline">\(i\)</span>、<spanclass="math inline">\(j\)</span> 和 <spanclass="math inline">\(key\)</span>）是局部于给定过程的，若无显式说明，我们不使用全局变量。</p></li><li><p>数据元素通过“数组名[下标]”这样的形式来访问。记号“..”用于表示数组中值的一个范围，如<span class="math inline">\(A[1..j]\)</span> 包含 <spanclass="math inline">\(j\)</span> 个元素 <spanclass="math inline">\(A[1], \ A[2], \ \dots, \ A[j]\)</span>。</p></li><li><p>复合数据通常被组织成<strong>对象</strong>，对象又由<strong>属性</strong>组成。如<span class="math inline">\(A.length\)</span>。</p><p>有时，一个指针根本不指向任何对象，这时，我们赋给它特殊值 <spanclass="math inline">\(\text{NIL}\)</span>。</p></li><li><p>我们<strong>按值</strong>把参数传递给过程：被调用过程接受其参数自身的副本。</p></li><li><p>一个 <span class="math inline">\(\textbf{return}\)</span>语句立即将控制返回调用过程的调用点。</p></li><li><p>布尔运算符 “<span class="math inline">\(\text{and}\)</span>” 和“<span class="math inline">\(\text{or}\)</span>”都是<strong>短路的</strong>。</p></li><li><p>关键词 <span class="math inline">\(\textbf{error}\)</span>表示因为已被调用的过程情况不对而出现了一个错误。</p></li></ol><h4 id="实例">实例</h4><p>以下是插入排序的伪代码： <span class="math display">\[\begin{align}&amp; \text{INSERTION-SORT($A$)} \\&amp; 1 \qquad \textbf{for} \ j = 2 \ \textbf{to} \ A.length \\&amp; 2 \qquad \qquad key = A[j] \\&amp; 3 \qquad \qquad \text{// Insert $A[j]$ into the sorted sequence$A[1..j - 1]$.} \\&amp; 4 \qquad \qquad i = j - 1 \\&amp; 5 \qquad \qquad \textbf{while} \ i &gt; 0 \ \text{and} \ A[i] &gt;key \\&amp; 6 \qquad \qquad \qquad A[i + 1] = A[i] \\&amp; 7 \qquad \qquad \qquad i = i - 1 \\&amp; 8 \qquad \qquad A[i + 1] = key\end{align}\]</span> 以上伪代码的 <span class="math inline">\(\LaTeX\)</span>代码是</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;align&#125;<br><span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\text</span>&#123;INSERTION-SORT(<span class="hljs-built_in">$</span>A<span class="hljs-built_in">$</span>)&#125; <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> 1 <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\textbf</span>&#123;for&#125; <span class="hljs-keyword">\ </span>j = 2 <span class="hljs-keyword">\ </span><span class="hljs-keyword">\textbf</span>&#123;to&#125; <span class="hljs-keyword">\ </span>A.length <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> 2 <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\qquad</span> key = A[j] <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> 3 <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\text</span>&#123;// Insert <span class="hljs-built_in">$</span>A[j]<span class="hljs-built_in">$</span> into the sorted sequence <span class="hljs-built_in">$</span>A[1..j - 1]<span class="hljs-built_in">$</span>.&#125; <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> 4 <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\qquad</span> i = j - 1 <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> 5 <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\textbf</span>&#123;while&#125; <span class="hljs-keyword">\ </span>i &gt; 0 <span class="hljs-keyword">\ </span><span class="hljs-keyword">\text</span>&#123;and&#125; <span class="hljs-keyword">\ </span>A[i] &gt; key <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> 6 <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\qquad</span> A[i + 1] = A[i] <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> 7 <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\qquad</span> i = i - 1 <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> 8 <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\qquad</span> A[i + 1] = key<br><span class="hljs-keyword">\end</span>&#123;align&#125;<br></code></pre></td></tr></table></figure><h4 id="利用-latex-公式书写伪代码的简便方法">利用 <spanclass="math inline">\(\LaTeX\)</span> 公式书写伪代码的简便方法</h4><p>事实上，在大型语言模型流行的当下，利用大型语言模型，可以较为方便地得到伪代码所对应的<span class="math inline">\(\LaTeX\)</span> 公式。</p><p>以下是利用大型语言模型（此处以 <em>Claude 3.5 Sonnet</em>为例）将纯文本转化为 <span class="math inline">\(\LaTeX\)</span>伪代码的实例（我相信有充分的理由确信对于多行公式，没有人愿意手敲 <spanclass="math inline">\(\LaTeX\)</span> 公式）：</p><p>这是对于 SPFA 算法，让大型语言模型产生 <spanclass="math inline">\(\LaTeX\)</span> 伪代码的<strong>Prompt</strong>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs r">Refer to the following example to translate plaintext into LaTex pseudocode<span class="hljs-punctuation">,</span> <span class="hljs-keyword">in</span> which emptyset use <span class="hljs-punctuation">\</span>varnothing<span class="hljs-punctuation">,</span> functions use <span class="hljs-punctuation">\</span>operatorname<span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-keyword">while</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">for</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">repeat</span><span class="hljs-operator">-</span>until<span class="hljs-punctuation">,</span> <span class="hljs-keyword">if</span><span class="hljs-operator">-</span><span class="hljs-keyword">else</span><span class="hljs-punctuation">,</span> to<span class="hljs-punctuation">,</span> downto<span class="hljs-punctuation">,</span> by<span class="hljs-punctuation">&#125;</span> use <span class="hljs-punctuation">\</span>textbf<br>Q<span class="hljs-operator">:</span><br>```<br>BELLMAN-FORD(G, w, s)<br>    INITIALIZE-SINGLE-SOURCE(G, s)<br>    for i = 1 to |G.V| - 1<br>        for each edge(u, v) in G.E<br>            RELAX(u, v, w)<br>    for each edge(u, v) in G.E<br>        if v.d &gt; u.d + w(u, v)<br>            return FALSE<br>    return TRUE<br>```<br><br>A<span class="hljs-operator">:</span><br>```latex<br>\begin&#123;align&#125;<br>&amp; \text&#123;BELLMAN-FORD($G$, $w$, $s$)&#125; \\<br>&amp; 1 \qquad \text&#123;INITIALIZE\_SINGLE\_SOURCE($G$, $s$)&#125; \\<br>&amp; 2 \qquad \textbf&#123;for&#125; \ i = 1 \ \textbf&#123;to&#125; \ |G.V| - 1 \\<br>&amp; 3 \qquad \qquad \textbf&#123;for&#125; \ \text&#123;each &#125; \operatorname&#123;edge&#125;(u, v) \ \in \ G.E \\<br>&amp; 4 \qquad \qquad \qquad \operatorname&#123;RELAX&#125;(u, v, w) \\<br>&amp; 5 \qquad \textbf&#123;for&#125; \ \text&#123;each &#125; \operatorname&#123;edge&#125;(u, v) \ \in \ G.E \\<br>&amp; 6 \qquad \qquad \textbf&#123;if&#125; \ v.d &gt; u.d + w(u, v) \\<br>&amp; 7 \qquad \qquad \qquad \textbf&#123;return &#125; \text&#123;FALSE&#125; \\<br>&amp; 8 \qquad \textbf&#123;return &#125; \text&#123;TRUE&#125;<br>\end&#123;align&#125;<br>```<br><br>Q<span class="hljs-operator">:</span><br>```<br>SHORTEST-PATH-FAST-ALGORITHM(G, w, s)<br>    INITIALIZE-SINGLE-SOURCE(G, s)<br>    Q = &lt;v_1, v_2, ..., v_k&gt; // v in G.V, k = |G.V|<br>    COUNT = []<br>    // COUNT is an array used to store the number of nodes on a certain shortest path to determine whether the graph has a negative cycle.<br>    while Q != emptyset<br>        u = EXTRACT-FRONT(Q)<br>        for each vertex v in G.Adj[u]<br>            if RELAX(u, v, w) = TRUE<br>                COUNT[v] = COUNT[u] + 1<br>                if COUNT[v] &gt;= |G.V|<br>                    return FALSE<br>                if v notin Q<br>                    Q = Q push v<br>    return TRUE<br>```<br><br>A<span class="hljs-operator">:</span><br></code></pre></td></tr></table></figure><p>它会产生形如下面的语句，根据 <em>系统提示词</em>等参数的不同，返回的语句可能会略有不同：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\begin&#123;align&#125;</span><br>&amp; <span class="hljs-string">\text&#123;SHORTEST-PATH-FAST-ALGORITHM($G$,</span> $w$, $s$)&#125; <span class="hljs-string">\\</span><br>&amp; <span class="hljs-number">1</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\operatorname&#123;INITIALIZE\_SINGLE\_SOURCE&#125;(G,</span> s) <span class="hljs-string">\\</span><br>&amp; <span class="hljs-number">2</span> <span class="hljs-string">\qquad</span> Q = <span class="hljs-string">\langle</span> v_1, v_2, <span class="hljs-string">\cdots,</span> v_k <span class="hljs-string">\rangle</span> <span class="hljs-string">\text&#123;</span> <span class="hljs-regexp">// &#125; v_i \in G.V, \ k = |G.V| \\</span><br><span class="hljs-regexp">&amp; 3 \qquad \text&#123;COUNT&#125; = [] \\</span><br><span class="hljs-regexp">&amp; 4 \qquad \text&#123;//</span> COUNT <span class="hljs-keyword">is</span> an array used <span class="hljs-keyword">to</span> store the number <span class="hljs-keyword">of</span> nodes <span class="hljs-literal">on</span> a certain shortest path&#125; <span class="hljs-string">\\</span><br>&amp; <span class="hljs-number">5</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\text&#123;//</span> <span class="hljs-keyword">to</span> determine whether the graph has a negative cycle.&#125; <span class="hljs-string">\\</span><br>&amp; <span class="hljs-number">6</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\textbf&#123;while&#125;</span> <span class="hljs-string">\</span> Q <span class="hljs-string">\neq</span> <span class="hljs-string">\varnothing</span> <span class="hljs-string">\\</span><br>&amp; <span class="hljs-number">7</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> u = <span class="hljs-string">\operatorname&#123;EXTRACT\_FRONT&#125;(Q)</span> <span class="hljs-string">\\</span><br>&amp; <span class="hljs-number">8</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\textbf&#123;for&#125;</span> <span class="hljs-string">\</span> <span class="hljs-string">\text&#123;each</span> vertex &#125; v <span class="hljs-string">\in</span> G.<span class="hljs-string">\operatorname&#123;Adj&#125;[u]</span> <span class="hljs-string">\\</span><br>&amp; <span class="hljs-number">9</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\textbf&#123;if&#125;</span> <span class="hljs-string">\</span> <span class="hljs-string">\operatorname&#123;RELAX&#125;(u,</span> v, w) = <span class="hljs-string">\text&#123;TRUE&#125;</span> <span class="hljs-string">\\</span><br>&amp; <span class="hljs-number">10</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\text&#123;COUNT&#125;[v]</span> = <span class="hljs-string">\text&#123;COUNT&#125;[u]</span> + <span class="hljs-number">1</span> <span class="hljs-string">\\</span><br>&amp; <span class="hljs-number">11</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\textbf&#123;if&#125;</span> <span class="hljs-string">\</span> <span class="hljs-string">\text&#123;COUNT&#125;[v]</span> <span class="hljs-string">\geq</span> |G.V| <span class="hljs-string">\\</span><br>&amp; <span class="hljs-number">12</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\textbf&#123;return&#125;</span> <span class="hljs-string">\</span> <span class="hljs-string">\text&#123;FALSE&#125;</span> <span class="hljs-string">\\</span><br>&amp; <span class="hljs-number">13</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\textbf&#123;if&#125;</span> <span class="hljs-string">\</span> v <span class="hljs-string">\notin</span> Q <span class="hljs-string">\\</span><br>&amp; <span class="hljs-number">14</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\qquad</span> Q = Q <span class="hljs-string">\text&#123;</span> push &#125; v <span class="hljs-string">\\</span><br>&amp; <span class="hljs-number">15</span> <span class="hljs-string">\qquad</span> <span class="hljs-string">\textbf&#123;return&#125;</span> <span class="hljs-string">\</span> <span class="hljs-string">\text&#123;TRUE&#125;</span><br><span class="hljs-string">\end&#123;align&#125;</span><br></code></pre></td></tr></table></figure><p>这是渲染之后的 <span class="math inline">\(\LaTeX\)</span> 公式：<span class="math display">\[\begin{align}&amp; \text{SHORTEST-PATH-FAST-ALGORITHM($G$, $w$, $s$)} \\&amp; 1 \qquad \operatorname{INITIALIZE\_SINGLE\_SOURCE}(G, s) \\&amp; 2 \qquad Q = \langle v_1, v_2, \cdots, v_k \rangle \text{ // } v_i\in G.V, \ k = |G.V| \\&amp; 3 \qquad \text{COUNT} = [] \\&amp; 4 \qquad \text{// COUNT is an array used to store the number ofnodes on a certain shortest path} \\&amp; 5 \qquad \text{// to determine whether the graph has a negativecycle.} \\&amp; 6 \qquad \textbf{while} \ Q \neq \varnothing \\&amp; 7 \qquad \qquad u = \operatorname{EXTRACT\_FRONT}(Q) \\&amp; 8 \qquad \qquad \textbf{for} \ \text{each vertex } v \inG.\operatorname{Adj}[u] \\&amp; 9 \qquad \qquad \qquad \textbf{if} \ \operatorname{RELAX}(u, v, w)= \text{TRUE} \\&amp; 10 \qquad \qquad \qquad \qquad \text{COUNT}[v] = \text{COUNT}[u] +1 \\&amp; 11 \qquad \qquad \qquad \qquad \textbf{if} \ \text{COUNT}[v] \geq|G.V| \\&amp; 12 \qquad \qquad \qquad \qquad \qquad \textbf{return} \\text{FALSE} \\&amp; 13 \qquad \qquad \qquad \qquad \textbf{if} \ v \notin Q \\&amp; 14 \qquad \qquad \qquad \qquad \qquad Q = Q \text{ push } v \\&amp; 15 \qquad \textbf{return} \ \text{TRUE}\end{align}\]</span></p><p>这样做已经足够产生一段精美的 <spanclass="math inline">\(\LaTeX\)</span> 公式，细微处可能需要人工调整。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Chumeng&#39;s code style for OI/ACM</title>
    <link href="/Chumeng-s-code-style-for-OI-ACM/"/>
    <url>/Chumeng-s-code-style-for-OI-ACM/</url>
    
    <content type="html"><![CDATA[<p>下面是 Chumeng的算法竞赛代码规范（即通常情况下，在代码中采用以下约定）。其来源主要来自于Chumeng 的长期实践，<ahref="https://codeforces.com/submissions/jiangly">jiangly的提交记录</a>，<a href="https://oi.men.ci/code-style-oi/">Menci的代码规范</a>，<ahref="https://rqy.moe/old_posts/rqy-s-Code-Style-for-OI.html">_rqy的代码规范</a>， <ahref="https://studyingfather.com/archives/1361">Studying Father的代码规范</a>。</p><h3 id="概览">概览</h3><p><strong>不推荐</strong>使用命名空间。</p><p><strong>不推荐</strong>使用诸如 <code>LL</code> 或 <code>ULL</code>的缩写来作为类型别名，而应使用 <code>i64</code> 或<code>u64</code>。</p><p><code>main</code> 函数<strong>应该</strong>置于整段程序的末尾。</p><p><strong>应该</strong>使用现代化的语法或数据类型，例如使用 lambda函数，结构化绑定，用 <code>std::vector&lt;int&gt; a[N]</code> 代替<code>int a[N]</code> 等。</p><h3 id="预编译">预编译</h3><p><code>#include</code>语句<strong>必须</strong>置于程序开头。</p><p>在算法竞赛中，<strong>推荐</strong>使用<code>#include "path-spec"</code> （见 <ahref="https://codeforces.com/blog/entry/53909?f0a28=1">Speed up GCCCompile time</a>，当使用 <em>带引号的形式</em>时，目录搜索从父文件的目录开始）。</p><p>在大多数的软件工程实践下，<strong>应该</strong>使用<em>尖括号形式</em>。</p><p><strong>推荐</strong>使用 <em>万能头文件</em> （即<code>#include &lt;bits/stdc++.h&gt;</code>）</p><p><strong>不应</strong>使用 <code>#define</code> 或<code>typedef</code> （<code>#define i64 long long</code>）来为数据类型取别名，而<strong>应该</strong>使用<code>using i64 = long long;</code></p><p><strong>应该</strong>使用 <code>constexpr</code> 关键定义常数。</p><h3 id="缩进">缩进</h3><p>对于每个代码块，<strong>应该</strong>使用 4 空格缩进。</p><p>所有的预编译指令（包括 <code>#ifdef</code>等）<strong>不能</strong>缩进。</p><h3 id="空格及行">空格及行</h3><p>大括号<strong>不应</strong>换行。</p><p>多个意义独立的代码块之间<strong>应该</strong>用空行隔开。</p><p>当条件或循环语句后只跟随一条语句时，<strong>可以</strong>直接另起一行，不加花括号。</p><p>二元运算符（包括赋值运算符）两侧<strong>必须</strong>有一个空格。</p><p><code>if</code>,<code>for</code>等控制流关键字与其后的左括号之间<strong>必须</strong>有一个空格。</p><p><code>do-while</code>中的<code>while</code>、<code>if-else</code>中的<code>else</code>与其前面的右大括号之间<strong>必须</strong>有一个空格。</p><p>双目运算符、三目运算符的两侧<strong>必须</strong>有一个空格。</p><p>逗号 <code>,</code> 与 <code>for</code> 中的分号 <code>;</code>后面<strong>必须</strong>有一个空格。</p><p>在书写长表达式时，为了便于阅读，<strong>可以</strong>加一个空格（e.g.<code>f[i][j] = f[ f[i][j - 1] ][j - 1]</code>）</p><p>单目运算符的两侧<strong>不能</strong>有空格。</p><p>冒号的两侧<strong>必须</strong>有一个空格（除 <code>::</code>）。</p><h3 id="命名">命名</h3><p>结构体、函数、变量、参数名<strong>必须</strong>使用驼峰命名法。</p><p>结构体首字母<strong>必须</strong>大写。</p><p>当问题中给定变量名时，<strong>应该</strong>优先使用。</p><p>命名中的单词<strong>可以</strong>使用缩写，函数、变量、参数名<strong>可以</strong>用一个小写字母代替。</p><p>一些常见名称：</p><ul><li>a/b/c/m/n/p/q/t/s/v/val：变量的值，其中 a/b/c 常用于作为数组名，s作为字符串</li><li>i/j/k：只能用于循环结构中</li><li>f/g/h：动态规划中存储状态的数组</li><li>cnt/tot：计数</li><li>siz：大小</li><li>dir：方向</li><li>dis/dist：距离</li><li>ans/res：结果</li></ul><h3 id="示例代码">示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-type">const</span> i64 P = <span class="hljs-number">998244353</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>i64 n, m, C, F;<br>std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; C &gt;&gt; F;<br><br>std::vector&lt;std::vector&lt;i64&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>std::string s;<br>std::cin &gt;&gt; s;<br><br>a[i] = std::<span class="hljs-built_in">vector</span>&lt;i64&gt;(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; x : a[i]) <br>x -= <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br>std::vector&lt;std::vector&lt;i64&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;i64&gt;(m + <span class="hljs-number">1</span>)), <span class="hljs-built_in">g</span>(n + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;i64&gt;(m + <span class="hljs-number">1</span>));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++ i)<br>f[i][m] = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; ++ j)<br>g[<span class="hljs-number">0</span>][j] = <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; -- j) &#123;<br><span class="hljs-keyword">if</span> (a[i][j]) &#123;<br>f[i][j] = g[i][j] = <span class="hljs-number">-1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>(f[i][j] = f[i][j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) %= P,<br>(g[i][j] = g[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>) %= P;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123; <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br><span class="hljs-keyword">if</span> (a[i][j]) &#123;<br>f[i][j] = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>(f[i][j] += f[i - <span class="hljs-number">1</span>][j]) %= P;<br>&#125;<br>&#125;<br>    &#125;<br><br>i64 resC = <span class="hljs-number">0</span>, resF = <span class="hljs-number">0</span>;<br>std::vector&lt;std::vector&lt;i64&gt;&gt; <span class="hljs-built_in">c</span>(n + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;i64&gt;(m + <span class="hljs-number">1</span>));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; ++ i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br><span class="hljs-keyword">if</span> (a[i][j]) &#123;<br>c[i][j] = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (f[i][j] &gt; <span class="hljs-number">0</span> &amp;&amp; f[i - <span class="hljs-number">2</span>][j] &gt; <span class="hljs-number">0</span> &amp;&amp; g[i][j] &gt; <span class="hljs-number">0</span>) &#123;<br>(c[i][j] = (f[i][j] - f[i - <span class="hljs-number">1</span>][j]) * (f[i - <span class="hljs-number">2</span>][j])) %= P;<br>(resC += c[i][j]) %= P;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; ++ i) <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br><span class="hljs-keyword">if</span> (a[i][j]) &#123;<br>c[i][j] = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>(c[i][j] += c[i - <span class="hljs-number">1</span>][j]) %= P;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; ++ i) <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++ j) <br><span class="hljs-keyword">if</span> (!a[i][j] &amp;&amp; c[i - <span class="hljs-number">1</span>][j] &amp;&amp; g[i][j] &gt; <span class="hljs-number">0</span>) <br>(resF += c[i - <span class="hljs-number">1</span>][j]) %= P;<br><br>std::cout &lt;&lt; C * resC % P &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; F * resF % P &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <br><span class="hljs-type">int</span> t, id;<br>std::cin &gt;&gt; t &gt;&gt; id;<br><br><span class="hljs-keyword">while</span> (t --) &#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Haskell 学习记录</title>
    <link href="/Haskell-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/Haskell-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Think Functional! -- fhq</p></blockquote><p>最近对函数式编程比较感兴趣，记录一下用 <strong>Haskell</strong>解决的算法/数学问题。</p><span id="more"></span><ol type="1"><li><p><em>Project Euler Prob. 2</em>: 求斐波纳契数列和</p><p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">fib</span> n | n &lt; <span class="hljs-number">2</span> = n<br>      | otherwise = fib (n - <span class="hljs-number">1</span>) + fib (n - <span class="hljs-number">2</span>)<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br> putStrLn $ show $ sum [a | a &lt;- (takeWhile (flip (&lt;=) (<span class="hljs-number">4</span>*<span class="hljs-number">10</span>^<span class="hljs-number">6</span>)) . map fib $ [<span class="hljs-number">1</span>..]), even a]<br></code></pre></td></tr></table></figure></p></li><li><p><em>Project Euler Prob. 3</em>: 因式分解</p><p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">primeFactor</span> :: <span class="hljs-type">Integer</span> -&gt; [<span class="hljs-type">Integer</span>]<br><span class="hljs-title">primeFactor</span> n = factor n <span class="hljs-number">2</span><br>    <span class="hljs-keyword">where</span><br>    factor n m<br>      | n &lt; m * m = [n]<br>      | n `mod` m == <span class="hljs-number">0</span> = m : factor (n `div` m) m<br>      | otherwise = factor n (m + <span class="hljs-number">1</span>)<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    putStrLn $ show $ maximum $ primeFactor <span class="hljs-number">600851475143</span><br></code></pre></td></tr></table></figure></p></li><li><p>二项式展开(在实数域适用，能用来求无穷级数(收敛的)，不保证精度)<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-comment">-- 二项式系数</span><br><span class="hljs-title">choose</span> :: (<span class="hljs-type">Fractional</span> a, <span class="hljs-type">Enum</span> a, <span class="hljs-type">Eq</span> a) =&gt; a -&gt; a -&gt; a<br><span class="hljs-title">choose</span> _ <span class="hljs-number">0</span> = <span class="hljs-number">1</span><br><span class="hljs-title">choose</span> n k = n / k * choose (n - <span class="hljs-number">1</span>) (k - <span class="hljs-number">1</span>)<br><br><span class="hljs-comment">-- 生成带未知数的二项式展开式</span><br><span class="hljs-title">make</span> :: (<span class="hljs-type">Enum</span> a, <span class="hljs-type">Num</span> a, <span class="hljs-type">RealFloat</span> a, <span class="hljs-type">Eq</span> a) =&gt; (a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; [[a -&gt; a]]<br><span class="hljs-title">make</span> a b n = [[f1 k, f2 k, f3 k] | k &lt;- [<span class="hljs-number">0</span>..]]<br>    <span class="hljs-keyword">where</span> f1 k x = choose n k<br>          f2 k = (\x -&gt; x ** k) . a<br>          f3 k = (\x -&gt; x ** (n - k)) . b<br><br><span class="hljs-comment">-- 代入未知数</span><br><span class="hljs-comment">-- 结果形如 [[1.0,1.0,1.0],[2.0,1.0,1.0],[1.0,1.0,1.0]]</span><br><span class="hljs-title">substitute</span> :: (<span class="hljs-type">Num</span> a, <span class="hljs-type">Eq</span> a, <span class="hljs-type">RealFloat</span> a) =&gt; a -&gt; [[a -&gt; a]] -&gt; [[a]]<br><span class="hljs-title">substitute</span> x = takeWhile (\xs -&gt; head xs /= <span class="hljs-number">0</span> &amp;&amp; (not . any isInfinite) xs) . map (map (\f -&gt; f x))<br><br><span class="hljs-comment">-- 对展开式求和</span><br><span class="hljs-title">sum&#x27;</span> :: (<span class="hljs-type">Num</span> a) =&gt; [[a]] -&gt; a<br><span class="hljs-title">sum&#x27;</span> = sum . (map product)<br><br><span class="hljs-comment">-- 计算二项式展开式</span><br><span class="hljs-title">calc</span> :: (<span class="hljs-type">Num</span> a, <span class="hljs-type">Eq</span> a, <span class="hljs-type">RealFloat</span> a) =&gt; a -&gt; [[a -&gt; a]] -&gt; a<br><span class="hljs-title">calc</span> x = sum&#x27; . substitute x<br></code></pre></td></tr></table></figure></p></li><li><p><em>Project Euler Prob. 4</em>: 回文序列</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    putStrLn $ show $ maximum $ [z | x &lt;- [<span class="hljs-number">100</span>..<span class="hljs-number">999</span>], y &lt;- [x..<span class="hljs-number">999</span>], z &lt;- [x * y], isPalindrome z]<br>        <span class="hljs-keyword">where</span> isPalindrome s = (show s) == reverse (show s)<br></code></pre></td></tr></table></figure></li><li><p><em>Project Euler Prob. 5</em>: 最小公倍数</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">foldl1</span> lcm [<span class="hljs-number">1</span>..<span class="hljs-number">20</span>]<br></code></pre></td></tr></table></figure></li><li><p><em>Project Euler Prob. 6</em>: 筛法</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">primes</span> = sieve [<span class="hljs-number">2</span>..]<br>  <span class="hljs-keyword">where</span> sieve (p:xs) = p : sieve [x | x &lt;- xs, x `mod` p /= <span class="hljs-number">0</span>]<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span> print $ primes !! <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Picnic Planning 解题报告</title>
    <link href="/Picnic-Planning-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/Picnic-Planning-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><h3 id="题目描述">题目描述</h3><p>The Contortion Brothers are a famous set of circus clowns, knownworldwide for their incredible ability to cram an unlimited number ofthemselves into even the smallest vehicle. During the off-season, thebrothers like to get together for an Annual Contortionists Meeting at alocal park. However, the brothers are not only tight with regard tocramped quarters, but with money as well, so they try to find the way toget everyone to the party which minimizes the number of miles put oneveryone's cars (thus saving gas, wear and tear, etc.). To this end theyare willing to cram themselves into as few cars as necessary to minimizethe total number of miles put on all their cars together. This oftenresults in many brothers driving to one brother's house, leaving all butone car there and piling into the remaining one. There is a constraintat the park, however: the parking lot at the picnic site can only hold alimited number of cars, so that must be factored into the overallmiserly calculation. Also, due to an entrance fee to the park, once anybrother's car arrives at the park it is there to stay; he will not dropoff his passengers and then leave to pick up other brothers. Now foryour average circus clan, solving this problem is a challenge, so it isleft to you to write a program to solve their milage minimizationproblem.</p><h3 id="输入格式">输入格式</h3><p>Input will consist of one problem instance. The first line willcontain a single integer n indicating the number of highway connectionsbetween brothers or between brothers and the park. The next n lines willcontain one connection per line, of the form name1 name2 dist, wherename1 and name2 are either the names of two brothers or the word Parkand a brother's name (in either order), and dist is the integer distancebetween them. These roads will all be 2-way roads, and dist will alwaysbe positive.The maximum number of brothers will be 20 and themaximumlength of any name will be 10 characters.Following these n lineswill be one final line containing an integer s which specifies thenumber of cars which can fit in the parking lot of the picnic site. Youmay assume that there is a path from every brother's house to the parkand that a solution exists for each problem instance.</p><h3 id="输出格式">输出格式</h3><p>Output should consist of one line of the form Total miles driven: xxxwhere xxx is the total number of miles driven by all the brothers'cars.</p><h2 id="分析">分析</h2><p>有两种方法：一种是先求最小生成树，然后删边，另一种是先把除了节点一以外的连通块分别求出来最小生成树，将每个连通块和节点一连边，然后不断更新答案。</p><p>第一种方法的时间复杂度为 <spanclass="math inline">\(O(n^4)\)</span>，第二种方法的时间复杂度为 <spanclass="math inline">\(O(n^2)\)</span>。</p><h2 id="代码">代码</h2><p>法一： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">40</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n, m, s, ans, deg;<br><span class="hljs-type">int</span> a[N][N], b[N][N];<br><span class="hljs-type">int</span> d[N], st[N], conn[N];<br>std::map&lt;std::string, <span class="hljs-type">int</span>&gt; h;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    st[x] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">2</span>; y &lt;= n; ++ y) &#123;<br>        <span class="hljs-keyword">if</span> (b[x][y] != INF &amp;&amp; !st[y]) &#123;<br>            <span class="hljs-built_in">dfs</span>(y);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> min = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) <span class="hljs-keyword">if</span> (st[i]) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= n; ++ j) <span class="hljs-keyword">if</span> (!st[j]) <br>            <span class="hljs-keyword">if</span> (a[i][j] &lt; min) &#123;<br>                min = a[i][j], x = i, y = j;<br>            &#125;<br>    <span class="hljs-keyword">return</span> min;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> min = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>, mini, minx, miny;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (b[<span class="hljs-number">1</span>][i] != INF) &#123;<br>            <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>            st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(i);<br>            <span class="hljs-type">int</span> x, y;<br>            <span class="hljs-type">int</span> addEdge = <span class="hljs-built_in">findMin</span>(x, y);<br>            <span class="hljs-keyword">if</span> (addEdge &lt; INF &amp;&amp; addEdge - b[<span class="hljs-number">1</span>][i] &lt; min) &#123;<br>                min = addEdge - b[<span class="hljs-number">1</span>][i];<br>                mini = i, minx = x, miny = y;<br>            &#125; <br>        &#125;<br>    &#125;<br>    ans += min;<br>    b[<span class="hljs-number">1</span>][mini] = b[mini][<span class="hljs-number">1</span>] = INF;<br>    b[minx][miny] = b[miny][minx] = a[minx][miny];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> a);<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> d);<br>    std::cin &gt;&gt; m;<br>    h[<span class="hljs-string">&quot;Park&quot;</span>] = <span class="hljs-number">1</span>, n = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br>        std::string x, y;<br>        <span class="hljs-type">int</span> z;<br>        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        <span class="hljs-keyword">if</span> (!h[x]) h[x] = ++ n;<br>        <span class="hljs-keyword">if</span> (!h[y]) h[y] = ++ n;<br>        a[h[x]][h[y]] = std::<span class="hljs-built_in">min</span>(a[h[x]][h[y]], z);<br>        a[h[y]][h[x]] = std::<span class="hljs-built_in">min</span>(a[h[y]][h[x]], z);<br>    &#125;<br>    std::cin &gt;&gt; s;<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j) &#123;<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (x == <span class="hljs-number">0</span> || d[j] &lt; d[x])) &#123;<br>                x = j;<br>            &#125;<br>        &#125;<br>        st[x] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">1</span>; y &lt;= n; ++ y) &#123;<br>            <span class="hljs-keyword">if</span> (!st[y] &amp;&amp; d[y] &gt; a[x][y]) &#123;<br>                d[y] = a[x][y], conn[y] = x;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(b, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> b);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>        ans += d[i];<br>        <span class="hljs-keyword">if</span> (conn[i] == <span class="hljs-number">1</span>) &#123;<br>            ++ deg;<br>        &#125;<br>        b[conn[i]][i] = b[i][conn[i]] = d[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (deg &gt; s) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>        -- deg;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Total miles driven:&quot;</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>法二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">40</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n, m, s, ans, deg;<br><span class="hljs-type">int</span> a[N][N], b[N][N];<br><span class="hljs-type">int</span> c[N], d[N], conn[N], st[N], v[N], p;<br><span class="hljs-type">int</span> f[N], fx[N], fy[N];<br>std::map&lt;std::string, <span class="hljs-type">int</span>&gt; h;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    v[++ p] = x;<br>    c[x] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">1</span>; y &lt;= n; ++ y) &#123;<br>        <span class="hljs-keyword">if</span> (a[x][y] != INF &amp;&amp; !c[y]) &#123;<br>            <span class="hljs-built_in">dfs</span>(y);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span> </span>&#123;<br>    d[root] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; ++ i) &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= p; ++ j) &#123;<br>            <span class="hljs-keyword">if</span> (!st[v[j]] &amp;&amp; (x == <span class="hljs-number">0</span> || d[v[j]] &lt; d[x])) &#123;<br>                x = v[j];<br>            &#125;<br>        &#125;<br>        st[x] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= p; ++ j) &#123;<br>            <span class="hljs-type">int</span> y = v[j];<br>            <span class="hljs-keyword">if</span> (!st[y] &amp;&amp; a[x][y] &lt; d[y]) &#123;<br>                d[y] = a[x][y], conn[y] = x;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> closest = root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; ++ i) &#123;<br>        <span class="hljs-type">int</span> x = v[i];<br>        <span class="hljs-keyword">if</span> (root != x) &#123;<br>            ans += d[x];<br>            b[conn[x]][x] = b[x][conn[x]] = d[x];<br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-number">1</span>][x] &lt; a[<span class="hljs-number">1</span>][closest]) &#123;<br>                closest = x;<br>            &#125;<br>        &#125;<br>    &#125;<br>    ++ deg;<br>    ans += a[<span class="hljs-number">1</span>][closest];<br>    b[<span class="hljs-number">1</span>][closest] = b[closest][<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>][closest];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">primForAll</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-built_in">memset</span>(b, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> b);<br>    c[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (!c[i]) &#123;<br>            p = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">dfs</span>(i),<br>            <span class="hljs-built_in">prim</span>(i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    st[x] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">2</span>; y &lt;= n; ++ y) &#123;<br>        <span class="hljs-keyword">if</span> (b[x][y] != INF &amp;&amp; !st[y]) &#123;<br>            <span class="hljs-keyword">if</span> (f[x] &gt; b[x][y]) &#123;<br>                std::<span class="hljs-built_in">tie</span>(f[y], fx[y], fy[y]) = std::<span class="hljs-built_in">tie</span>(f[x], fx[x], fy[x]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                std::<span class="hljs-built_in">tie</span>(f[y], fx[y], fy[y]) = std::<span class="hljs-built_in">tie</span>(b[x][y], x, y);<br>            &#125;<br>            <span class="hljs-built_in">dp</span>(y);<br>        &#125;<br>    &#125;<br>    st[x] = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> min = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>, mini;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) <br>        <span class="hljs-keyword">if</span> (b[<span class="hljs-number">1</span>][i] == INF &amp;&amp; a[<span class="hljs-number">1</span>][i] != INF) <br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-number">1</span>][i] - b[fx[i]][fy[i]] &lt; min) &#123;<br>                min = a[<span class="hljs-number">1</span>][i] - b[fx[i]][fy[i]],<br>                mini = i;<br>            &#125; <br>    <span class="hljs-keyword">if</span> (min &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    ans += min;<br>    b[<span class="hljs-number">1</span>][mini] = b[mini][<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>][mini];<br>    b[fx[mini]][fy[mini]] = b[fy[mini]][fx[mini]] = INF;<br>    f[mini] = a[<span class="hljs-number">1</span>][mini],<br>    fx[mini] = <span class="hljs-number">1</span>, fy[mini] = mini;<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">dp</span>(mini);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> a);<br>    std::cin &gt;&gt; m;<br>    h[<span class="hljs-string">&quot;Park&quot;</span>] = <span class="hljs-number">1</span>, n = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br>        std::string x, y;<br>        <span class="hljs-type">int</span> z;<br>        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        <span class="hljs-keyword">if</span> (!h[x]) h[x] = ++ n;<br>        <span class="hljs-keyword">if</span> (!h[y]) h[y] = ++ n;<br>        a[h[x]][h[y]] = std::<span class="hljs-built_in">min</span>(a[h[x]][h[y]], z);<br>        a[h[y]][h[x]] = std::<span class="hljs-built_in">min</span>(a[h[y]][h[x]], z);<br>    &#125;<br>    std::cin &gt;&gt; s;<br>    <span class="hljs-built_in">primForAll</span>();<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (deg &lt; s) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">solve</span>()) <span class="hljs-keyword">break</span>;<br>        ++ deg;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Total miles driven:&quot;</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cow Relays 解题报告</title>
    <link href="/Cow-Relays-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/Cow-Relays-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>Description</p><p>For their physical fitness program, <em>N</em> (2 ≤ <em>N</em> ≤1,000,000) cows have decided to run a relay race using the <em>T</em> (2≤ <em>T</em> ≤ 100) cow trails throughout the pasture.</p><p>Each trail connects two different intersections (1 ≤<em>I</em>1<em>i</em> ≤ 1,000; 1 ≤ <em>I</em>2<em>i</em> ≤ 1,000), eachof which is the termination for at least two trails. The cows know the<em>lengthi</em> of each trail (1 ≤ <em>lengthi</em> ≤ 1,000), the twointersections the trail connects, and they know that no twointersections are directly connected by two different trails. The trailsform a structure known mathematically as a graph.</p><p>To run the relay, the <em>N</em> cows position themselves at variousintersections (some intersections might have more than one cow). Theymust position themselves properly so that they can hand off the batoncow-by-cow and end up at the proper finishing place.</p><p>Write a program to help position the cows. Find the shortest paththat connects the starting intersection (<em>S</em>) and the endingintersection (<em>E</em>) and traverses exactly <em>N</em> cowtrails.</p><p>Input</p><p>* Line 1: Four space-separated integers: <em>N</em>, <em>T</em>,<em>S</em>, and <em>E</em> * Lines 2..<em>T</em>+1: Line <em>i</em>+1describes trail <em>i</em> with three space-separated integers:<em>lengthi</em> , <em>I</em>1<em>i</em> , and <em>I</em>2<em>i</em></p><p>Output</p><p>* Line 1: A single integer that is the shortest distance fromintersection <em>S</em> to intersection <em>E</em> that traversesexactly <em>N</em> cow trails.</p><h2 id="分析">分析</h2><p>因为边最多有 <span class="math inline">\(100\)</span>条，所以有效的节点编号最多只有 <span class="math inline">\(200\)</span>个，考虑离散化。</p><p>设离散化之后的 <span class="math inline">\(P \times P\)</span>的邻接矩阵 <span class="math inline">\(A\)</span>，那么不难想到这个邻接矩阵经过两条边的最短路就是 <spanclass="math display">\[B[i, j] = \min_{1 \le k \le P} \{A[i, k] + A[k, j]\} \notag\]</span></p><p>紧接着，经过三条边的最短路也不难想到。 <span class="math display">\[C[i, j] = \min_{1 \le k \le P} \{A[i, k] + B[k, j]\} \notag\]</span> 联想到什么了吗？像乘法一样！实际上，求经过 <spanclass="math inline">\(n\)</span>条边的最短路等价于一个广义“矩阵乘法”，用 <spanclass="math inline">\(A^m\)</span> 表示经过 <spanclass="math inline">\(m\)</span>条边的最短路的话，就能表示出来一般的式子： <span class="math display">\[A^{a + b}[i, j] = \min_{1 \le k \le P} \{A^a[i, k] + A^b[k, j]\} \notag\]</span> 于是，求几条边就相当于求“几次幂”，求幂的话当然是快速幂了。</p><p>具体到这个广义的“矩阵乘法”快速幂的话，一次“矩阵乘法”就类似于进行一次<span class="math inline">\(\operatorname{floyd}\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>;<br><span class="hljs-type">int</span> n, t, s, e, p, cnt;<br><span class="hljs-type">int</span> len[N], a[N], b[N], vals[N];<br><span class="hljs-type">int</span> d[N][N], ans[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> a[N][N], <span class="hljs-type">int</span> b[N][N])</span> </span>&#123;<br>    <span class="hljs-type">int</span> c[N][N];<br>    <span class="hljs-built_in">memset</span>(c, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> c);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= p; ++ k) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; ++ i) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= p; ++ j) <br>                <span class="hljs-keyword">if</span> (c[i][j] &gt; a[i][k] + b[k][j]) &#123;<br>                    c[i][j] = a[i][k] + b[k][j];<br>                &#125;<br>    <span class="hljs-built_in">memcpy</span>(a, c, <span class="hljs-keyword">sizeof</span> c);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin &gt;&gt; n &gt;&gt; t &gt;&gt; s &gt;&gt; e;<br>    vals[++ cnt] = s, vals[++ cnt] = s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= t; ++ i) &#123;<br>        std::cin &gt;&gt; len[i] &gt;&gt; a[i] &gt;&gt; b[i]; <br>        vals[++ cnt] = a[i],<br>        vals[++ cnt] = b[i];<br>    &#125;<br>    std::<span class="hljs-built_in">sort</span>(vals + <span class="hljs-number">1</span>, vals + <span class="hljs-number">1</span> + cnt);<br>    p = std::<span class="hljs-built_in">unique</span>(vals + <span class="hljs-number">1</span>, vals + <span class="hljs-number">1</span> + cnt) - vals - <span class="hljs-number">1</span>;<br>    s = std::<span class="hljs-built_in">lower_bound</span>(vals + <span class="hljs-number">1</span>, vals + <span class="hljs-number">1</span> + p, s) - vals,<br>    e = std::<span class="hljs-built_in">lower_bound</span>(vals + <span class="hljs-number">1</span>, vals + <span class="hljs-number">1</span> + p, e) - vals;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= t; ++ i) &#123;<br>        a[i] = std::<span class="hljs-built_in">lower_bound</span>(vals + <span class="hljs-number">1</span>, vals + <span class="hljs-number">1</span> + p, a[i]) - vals,<br>        b[i] = std::<span class="hljs-built_in">lower_bound</span>(vals + <span class="hljs-number">1</span>, vals + <span class="hljs-number">1</span> + p, b[i]) - vals;<br>        d[a[i]][b[i]] = std::<span class="hljs-built_in">min</span>(d[a[i]][b[i]], len[i]);<br>        d[b[i]][a[i]] = std::<span class="hljs-built_in">min</span>(d[b[i]][a[i]], len[i]);<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> ans);<br>    ans[s][s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; n; n /= <span class="hljs-number">2</span>, <span class="hljs-built_in">mul</span>(d, d)) &#123;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) <span class="hljs-built_in">mul</span>(ans, d);<br>    &#125; <br>    std::cout &lt;&lt; ans[s][e] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最优贸易 解题报告</title>
    <link href="/%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><h3 id="题目描述">题目描述</h3><p><span class="math inline">\(C\)</span> 国有 $ n $个大城市和 <spanclass="math inline">\(m\)</span> 条道路，每条道路连接这 <spanclass="math inline">\(n\)</span>个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 <spanclass="math inline">\(m\)</span>条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为<span class="math inline">\(1\)</span> 条。</p><p><span class="math inline">\(C\)</span>国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。</p><p>商人阿龙来到 <span class="math inline">\(C\)</span>国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设<span class="math inline">\(C\)</span> 国 n 个城市的标号从 <spanclass="math inline">\(1\sim n\)</span>，阿龙决定从 $1$号城市出发，并最终在 <span class="math inline">\(n\)</span>号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有<span class="math inline">\(n\)</span>个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来<span class="math inline">\(C\)</span>国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。</p><p>假设 $C $国有 <span class="math inline">\(5\)</span>个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。</p><h3 id="输入格式">输入格式</h3><p>第一行包含 <span class="math inline">\(2\)</span> 个正整数 $ n $ 和<spanclass="math inline">\(m\)</span>，中间用一个空格隔开，分别表示城市的数目和道路的数目。</p><p>第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这n 个城市的商品价格。</p><p>接下来 <span class="math inline">\(m\)</span> 行，每行有$ 3 $个正整数<spanclass="math inline">\(x,y,z\)</span>，每两个整数之间用一个空格隔开。如果<span class="math inline">\(z=1\)</span>，表示这条道路是城市$ x <spanclass="math inline">\(到城市\)</span> y <spanclass="math inline">\(之间的单向道路；如果\)</span>z=2$，表示这条道路为城市 <span class="math inline">\(x\)</span> 和城市<span class="math inline">\(y\)</span> 之间的双向道路。</p><h3 id="输出格式">输出格式</h3><p>一 个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 <spanclass="math inline">\(0\)</span>。</p><h2 id="分析">分析</h2><p>这题实际上相当于在一条 <span class="math inline">\(1\)</span> ~ <spanclass="math inline">\(n\)</span> 的路径，找到两个点 <spanclass="math inline">\(a, b\)</span>（先经过 <spanclass="math inline">\(a\)</span>），使得 <spanclass="math inline">\(w(b) - w(a)\)</span> 最大。</p><p>可以用 <strong>SPFA</strong> 算法维护从节点 <spanclass="math inline">\(1\)</span> 到其它节点的点权值的最小值，以及节点<span class="math inline">\(n\)</span>到该节点的点权值的最大值，具体实现时候，用 <spanclass="math inline">\(\min(min(u), w(v))\)</span> 代替 <spanclass="math inline">\(min(u) + w(v)\)</span> 进行松弛就可以了。</p><p>最后枚举所有的节点，找到 <span class="math inline">\(\displaystyle\max_{1 \le i \le n}(max(i) - min(i))\)</span> 。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N], min[N], max[N];<br>std::vector&lt;<span class="hljs-type">int</span>&gt; to[M], from[M];<br>std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; st;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>), st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        st[u] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : to[u]) &#123;<br>            <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">min</span>(min[u], a[v]) &lt; min[v]) &#123;<br>                min[v] = std::<span class="hljs-built_in">min</span>(min[u], a[v]);<br>                <span class="hljs-keyword">if</span> (!st[v]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(v),<br>                    st[v] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) q.<span class="hljs-built_in">pop</span>();<br>    st.<span class="hljs-built_in">clear</span>();<br>    q.<span class="hljs-built_in">push</span>(n), st[n] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        st[u] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : from[u]) &#123;<br>            <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">max</span>(max[u], a[v]) &gt; max[v]) &#123;<br>                max[v] = std::<span class="hljs-built_in">max</span>(max[u], a[v]);<br>                <span class="hljs-keyword">if</span> (!st[v]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(v);<br>                    st[v] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(min, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> min);<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        std::cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br>        <span class="hljs-type">int</span> x, y, z;<br>        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        to[x].<span class="hljs-built_in">emplace_back</span>(y), <br>        from[y].<span class="hljs-built_in">emplace_back</span>(x);<br>        <span class="hljs-keyword">if</span> (z == <span class="hljs-number">2</span>) &#123;<br>            to[y].<span class="hljs-built_in">emplace_back</span>(x),<br>            from[x].<span class="hljs-built_in">emplace_back</span>(y);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">spfa</span>();<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        ans = std::<span class="hljs-built_in">max</span>(ans, max[i] - min[i]);<br>    &#125;<br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Telephone Lines 解题报告</title>
    <link href="/Telephone-Lines-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/Telephone-Lines-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><h3 id="题目描述">题目描述</h3><p>Farmer John wants to set up a telephone line at his farm.Unfortunately, the phone company is uncooperative, so he needs to payfor some of the cables required to connect his farm to the phonesystem.</p><p>There are <em>N</em> (1 ≤ <em>N</em> ≤ 1,000) forlorn telephone polesconveniently numbered 1..<em>N</em> that are scattered around FarmerJohn's property; no cables connect any them. A total of <em>P</em> (1 ≤<em>P</em> ≤ 10,000) pairs of poles can be connected by a cable; therest are too far apart.</p><p>The <em>i</em>-th cable can connect the two distinct poles<em>Ai</em> and <em>Bi</em>, with length <em>Li</em> (1 ≤ <em>Li</em> ≤1,000,000) units if used. The input data set never names any{<em>Ai</em>, <em>Bi</em>} pair more than once. Pole 1 is alreadyconnected to the phone system, and pole <em>N</em> is at the farm. Poles1 and <em>N</em> need to be connected by a path of cables; the rest ofthe poles might be used or might not be used.</p><p>As it turns out, the phone company is willing to provide Farmer Johnwith <em>K</em> (0 ≤ <em>K</em> &lt; <em>N</em>) lengths of cable forfree. Beyond that he will have to pay a price equal to the length of thelongest remaining cable he requires (each pair of poles is connectedwith a separate cable), or 0 if he does not need any additionalcables.</p><p>Determine the minimum amount that Farmer John must pay.</p><h3 id="输入格式">输入格式</h3><p>* Line 1: Three space-separated integers: <em>N</em>, <em>P</em>, and<em>K</em> * Lines 2..<em>P</em>+1: Line <em>i</em>+1 contains the threespace-separated integers: <em>Ai</em>, <em>Bi</em>, and <em>Li</em></p><h3 id="输出格式">输出格式</h3><p>* Line 1: A single integer, the minimum amount Farmer John can pay.If it is impossible to connect the farm to the phone company, print-1.</p><h2 id="分析">分析</h2><p>上述题目实际可以简化为：求一个节点 <spanclass="math inline">\(1\)</span> 到节点 <spanclass="math inline">\(n\)</span> 的路径，第 <spanclass="math inline">\(k + 1\)</span>大的边权最小。是一个贪心的思想，很容易得出。</p><p>我们用 <span class="math inline">\(f[u, k]\)</span> 表示在节点 <spanclass="math inline">\(1\)</span> 到节点 <spanclass="math inline">\(u\)</span> 的路径中，用了 <spanclass="math inline">\(k\)</span>次免费机会时，路径上最大的边权的最小值。</p><p>那么对于一个边 <span class="math inline">\(u \to v\)</span>有以下状态转移：</p><ol type="1"><li><p>当这个边不免费时</p><p><span class="math inline">\(f[v, k] = \min(f[v, k], \max(f[u][k],w(u, v)))\)</span></p></li><li><p>当这个边免费时</p><p><span class="math inline">\(f[v, k + 1] = \min(f[v, k + 1], f[u,k])\)</span></p></li></ol><p>这个状态转移显然有后效性，因为题目给出的并不一定是DAG，确定不了遍历顺序。对于这种情况，我们使用 <strong>SPFA</strong>来进行状态的转移。这样的最短路问题被称为<strong>分层图最短路</strong>。用 <strong>SPFA</strong>算法的时间复杂度是 <span class="math inline">\(O(tNP)\)</span>，其中<span class="math inline">\(t\)</span> 应该是一个比较小的常数，实际可以<strong>AC</strong> 这一题。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> PII = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, P = <span class="hljs-number">20010</span>;<br><span class="hljs-type">int</span> n, p, k;<br><span class="hljs-type">int</span> f[N][N];<br>std::map&lt;PII, <span class="hljs-type">bool</span>&gt; st;<br><br><span class="hljs-type">int</span> e[P], ne[P], h[P], w[P], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;<br>    std::queue&lt;PII&gt; q;<br>    q.<span class="hljs-built_in">push</span>(&#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;);<br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, st[&#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        PII t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">auto</span> [u, nk] = t;<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> v = e[i];<br>            <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">max</span>(f[u][nk], w[i]) &lt; f[v][nk]) &#123;<br>                f[v][nk] = std::<span class="hljs-built_in">max</span>(f[u][nk], w[i]);<br>                <span class="hljs-keyword">if</span> (!st[&#123; v, nk &#125;]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(&#123; v, nk &#125;),<br>                    st[&#123; v, nk &#125;] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (f[u][nk] &lt; f[v][nk + <span class="hljs-number">1</span>] &amp;&amp; nk &lt; k) &#123;<br>                f[v][nk + <span class="hljs-number">1</span>] = f[u][nk];<br>                <span class="hljs-keyword">if</span> (!st[&#123; v, nk + <span class="hljs-number">1</span> &#125;]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(&#123; v, nk + <span class="hljs-number">1</span> &#125;),<br>                    st[&#123; v, nk + <span class="hljs-number">1</span> &#125;] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    std::cin &gt;&gt; n &gt;&gt; p &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; ++ i) &#123;<br>        <span class="hljs-type">int</span> x, y, z;<br>        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        <span class="hljs-built_in">add</span>(x, y, z), <span class="hljs-built_in">add</span>(y, x, z);<br>    &#125;<br>    <span class="hljs-built_in">spfa</span>();<br>    <span class="hljs-keyword">if</span> (f[n][k] &gt;= <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; f[n][k] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>函数调用 解题报告</title>
    <link href="/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><h3 id="题目描述">题目描述</h3><p>函数是各种编程语言中一项重要的概念，借助函数，我们总可以将复杂的任务分解成一个个相对简单的子任务，直到细化为十分简单的基础操作，从而使代码的组织更加严密、更加有条理。然而，过多的函数调用也会导致额外的开销，影响程序的运行效率。</p><p>某数据库应用程序提供了若干函数用以维护数据。已知这些函数的功能可分为三类：</p><ol type="1"><li><p>将数据中的指定元素加上一个值；</p></li><li><p>将数据中的每一个元素乘以一个相同值；</p></li><li><p><strong>依次</strong>执行若干次函数调用，保证不会出现递归（即不会直接或间接地调用本身）。</p></li></ol><p>在使用该数据库应用时，用户可一次性输入要调用的函数序列（一个函数可能被调用多次），在依次执行完序列中的函数后，系统中的数据被加以更新。某一天，小 A在应用该数据库程序处理数据时遇到了困难：由于频繁而低效的函数调用，系统在执行操作时进入了无响应的状态，他只好强制结束了数据库程序。为了计算出正确数据，小A查阅了软件的文档，了解到每个函数的具体功能信息，现在他想请你根据这些信息帮他计算出更新后的数据应该是多少。</p><h3 id="输入格式">输入格式</h3><p>第一行一个正整数 <spanclass="math inline">\(n\)</span>，表示数据的个数。 第二行 <spanclass="math inline">\(n\)</span> 个整数，第 <spanclass="math inline">\(i\)</span> 个整数表示下标为 <spanclass="math inline">\(i\)</span> 的数据的初始值为 <spanclass="math inline">\(a_i\)</span>。 第三行一个正整数 <spanclass="math inline">\(m\)</span>，表示数据库应用程序提供的函数个数。函数从<span class="math inline">\(1\ldots m\)</span> 编号。 接下来 <spanclass="math inline">\(m\)</span> 行中，第 <spanclass="math inline">\(j\)</span>（<span class="math inline">\(1 \le j\le m\)</span>）行的第一个整数为 <spanclass="math inline">\(T_j\)</span>，表示 <spanclass="math inline">\(j\)</span> 号函数的类型：</p><ol type="1"><li>若 <span class="math inline">\(T_j = 1\)</span>，接下来两个整数<span class="math inline">\(P_j,~V_j\)</span>分别表示要执行加法的元素的下标及其增加的值；</li><li>若 <span class="math inline">\(T_j = 2\)</span>，接下来一个整数<span class="math inline">\(V_j\)</span> 表示所有元素所乘的值；</li><li>若 <span class="math inline">\(T_j = 3\)</span>，接下来一个正整数<span class="math inline">\(C_j\)</span> 表示 <spanclass="math inline">\(j\)</span> 号函数要调用的函数个数，随后 <spanclass="math inline">\(C_j\)</span> 个整数 <spanclass="math inline">\(g_1^{(j)},~g_2^{(j)},~\ldots,~g_{C_j}^{(j)}\)</span>，依次表示其所调用的函数的编号。</li></ol><p>第 <span class="math inline">\(m + 4\)</span> 行一个正整数 <spanclass="math inline">\(Q\)</span>，表示输入的函数操作序列长度。 第 <spanclass="math inline">\(m + 5\)</span> 行 <spanclass="math inline">\(Q\)</span> 个整数 <spanclass="math inline">\(f_i\)</span>，第 <spanclass="math inline">\(i\)</span> 个整数表示第 <spanclass="math inline">\(i\)</span> 个执行的函数的编号。</p><h3 id="输出格式">输出格式</h3><p>一行 <span class="math inline">\(n\)</span>个用空格隔开的整数，按照下标 <span class="math inline">\(1\ldotsn\)</span>的顺序，分别输出在执行完输入的函数序列后，数据库中每一个元素的值。<strong>答案对</strong><span class="math inline">\(\boldsymbol{998244353}\)</span><strong>取模。</strong></p><h2 id="分析">分析</h2><p>这一题对于一道 t3 来说似乎过于简单？</p><p>不难注意到函数调用关系是一个<strong>DAG</strong>，不妨把最后的操作序列看作一个主函数，它在整个 DAG中的入度为 <span class="math inline">\(0\)</span>。</p><p>然后，后面的函数 <span class="math inline">\(2\)</span>相当于影响了其它函数的调用次数，并且影响了序列中的值 ( <spanclass="math inline">\((x + y) \times z = x \times z + y \timesz\)</span> )，所以，跑两次 <strong>toposort</strong>，分别维护函数 <spanclass="math inline">\(2\)</span> 对序列的影响（其实用<strong>dfs</strong> 会更加简洁），以及对函数调用次数的影响。</p><p>由于答案要取模，实际实现中会进行很多的模运算，这里写了一种自动取模的类型来方便调试（从jiangly 的cf比赛代码学来的，神犇的代码真的很优雅）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br> <br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> P = <span class="hljs-number">998244353</span>;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">norm</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <br>        x += P;<br>    <span class="hljs-keyword">if</span> (x &gt;= P)<br>        x -= P;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function">T <span class="hljs-title">power</span><span class="hljs-params">(T a, i64 b)</span> </span>&#123;<br>    T res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (; b; b /= <span class="hljs-number">2</span>, a *= a)<br>        <span class="hljs-keyword">if</span> (b % <span class="hljs-number">2</span>)<br>            res *= a;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z</span> &#123;<br>    i64 x;<br>    <span class="hljs-built_in">Z</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(<span class="hljs-built_in">norm</span>(x)) &#123; &#125;<br>    <span class="hljs-built_in">Z</span> (i64 x) : <span class="hljs-built_in">x</span>(<span class="hljs-built_in">norm</span>(x % P)) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-function">Z <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">assert</span>(x != <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">power</span>(*<span class="hljs-keyword">this</span>, P - <span class="hljs-number">2</span>);<br>    &#125;<br>    Z &amp; <span class="hljs-keyword">operator</span> *= (<span class="hljs-type">const</span> Z &amp;rhs) &#123;<br>        x = <span class="hljs-built_in">i64</span>(x) * rhs.x % P;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    Z &amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> Z &amp;rhs) &#123;<br>        x = <span class="hljs-built_in">norm</span>(x + rhs.x);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    Z &amp; <span class="hljs-keyword">operator</span> -= (<span class="hljs-type">const</span> Z &amp;rhs) &#123;<br>        x = <span class="hljs-built_in">norm</span>(x - rhs.x);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    Z &amp; <span class="hljs-keyword">operator</span> /= (<span class="hljs-type">const</span> Z &amp;rhs) &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> *= rhs.<span class="hljs-built_in">inv</span>();<br>    &#125;<br>    <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> Z &amp;lhs, <span class="hljs-type">const</span> Z &amp;rhs) &#123;<br>        Z res = lhs;<br>        res *= rhs;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Z &amp;lhs, <span class="hljs-type">const</span> Z &amp;rhs) &#123;<br>        Z res = lhs;<br>        res += rhs;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> Z &amp;lhs, <span class="hljs-type">const</span> Z &amp;rhs) &#123;<br>        Z res = lhs;<br>        res -= rhs;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span> / (<span class="hljs-type">const</span> Z &amp;lhs, <span class="hljs-type">const</span> Z &amp;rhs) &#123;<br>        Z res = lhs;<br>        res /= rhs;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-keyword">operator</span> &gt;&gt; (std::istream &amp;is, Z &amp;a) &#123;<br>        i64 v;<br>        is &gt;&gt; v;<br>        a = <span class="hljs-built_in">Z</span>(v);<br>        <span class="hljs-keyword">return</span> is;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span> &lt;&lt; (std::ostream &amp;os, <span class="hljs-type">const</span> Z &amp;a) &#123;<br>        <span class="hljs-keyword">return</span> os &lt;&lt; a.<span class="hljs-built_in">val</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">func</span> &#123;<br>    Z add, mul, pos, type, time;<br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, t;<br>Z a[N];<br><span class="hljs-type">bool</span> st[N];<br>func f[N];<br>std::vector&lt;<span class="hljs-type">int</span>&gt; to[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : to[u]) &#123;<br>        <span class="hljs-keyword">if</span> (!st[v]) <span class="hljs-built_in">dfs</span>(v);<br>        f[u].mul *= f[v].mul;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> ind[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span> </span>&#123;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m + <span class="hljs-number">1</span>; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (ind[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        Z now = <span class="hljs-number">1</span>;<br>        std::<span class="hljs-built_in">reverse</span>(to[u].<span class="hljs-built_in">begin</span>(), to[u].<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : to[u]) &#123;<br>            <span class="hljs-keyword">if</span> (-- ind[v] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(v);<br>            f[v].time += f[u].time * now;<br>            now *= f[v].mul;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        std::cin &gt;&gt; a[i];<br>    &#125;<br>    std::cin &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br>        <span class="hljs-type">int</span> op, x, y;<br>        std::cin &gt;&gt; op;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            std::cin &gt;&gt; x &gt;&gt; y;<br>            f[i] = &#123; y, <span class="hljs-number">1</span>, x, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>            std::cin &gt;&gt; x;<br>            f[i] = &#123; <span class="hljs-number">0</span>, x, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span> &#125;;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>) &#123;<br>            std::cin &gt;&gt; x;<br>            f[i] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span> &#125;;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= x; ++ j) &#123;<br>                std::cin &gt;&gt; y;<br>                to[i].<span class="hljs-built_in">emplace_back</span>(y);<br>                ++ ind[y];<br>            &#125;<br>        &#125;<br>    &#125;<br>    std::cin &gt;&gt; t;<br>    f[m + <span class="hljs-number">1</span>].mul = <span class="hljs-number">1</span>;<br>    f[m + <span class="hljs-number">1</span>].time = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= t; ++ i) &#123;<br>        std::cin &gt;&gt; x;<br>        to[m + <span class="hljs-number">1</span>].<span class="hljs-built_in">emplace_back</span>(x);<br>        ++ ind[x];<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(m + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">toposort</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        a[i] *= f[m + <span class="hljs-number">1</span>].mul;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (f[i].add.x) &#123;<br>            a[f[i].pos.x] += f[i].add * f[i].time;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        std::cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>逆元数列 解题报告</title>
    <link href="/%E9%80%86%E5%85%83%E6%95%B0%E5%88%97-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/%E9%80%86%E5%85%83%E6%95%B0%E5%88%97-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><h3 id="题目描述">题目描述</h3><p>给定质数 <span class="math inline">\(p\)</span> ，你需要维护一个长为<span class="math inline">\(n\)</span> 的数列 <spanclass="math inline">\(\{a_n\}\)</span> ，有如下两种操作形式：</p><p><span class="math inline">\(1\ l\ r\ \)</span>，表示将 <spanclass="math inline">\(a_l…a_r\)</span> 的所有数变为其模 <spanclass="math inline">\(p\)</span> 的乘法逆元；</p><p><span class="math inline">\(2\ l\ r\ \)</span>，表示查询 <spanclass="math inline">\(a_l…a_r\)</span> 的和。</p><p>若整数 <span class="math inline">\(b,p\)</span> 互质，并且 <spanclass="math inline">\(b|a\)</span> ，则存在一个整数 <spanclass="math inline">\(x\)</span> ，使得 <spanclass="math inline">\(a/b≡a*x\ (mod\ p)\)</span>，我们称 <spanclass="math inline">\(x\)</span> 为 <spanclass="math inline">\(b\)</span> 的模 <spanclass="math inline">\(p\)</span> 的逆元。</p><h3 id="输入格式">输入格式</h3><p>第一行三个整数 <span class="math inline">\(n,m,p\)</span>。</p><p>第二行 <span class="math inline">\(n\)</span> 个数，表示初始的 <spanclass="math inline">\(\{a_n\}\)</span>。</p><p>接下来 <span class="math inline">\(m\)</span> 行，每行三个整数 <spanclass="math inline">\(opt,l,r\)</span> ,表示一次操作，含义如上。 <spanclass="math inline">\(opt∈\{1,2\}\ ,\ 1≤l≤r≤n\)</span>。</p><h3 id="输出格式">输出格式</h3><p>若干行，对于每一个操作 <spanclass="math inline">\(2\)</span>，输出查询的值。</p><h2 id="分析">分析</h2><p>因为不用考虑运算顺序，所以对每个区间维护区间和和区间逆元和，每次修改的时候把对应区间的区间和和区间逆序和调换一下就行了。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Seg</span> &#123;<br>    <span class="hljs-type">int</span> l, r;<br>    i64 sum, ins, cnt, flag, same;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> l(x) tree[x].l</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> r(x) tree[x].r</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> sum(x) tree[x].sum</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ins(x) tree[x].ins</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> cnt(x) tree[x].cnt</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> flag(x) tree[x].flag</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> len(x) (r(x) - l(x) + 1)</span><br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m;<br>i64 a[N];<br>Seg tree[<span class="hljs-number">4</span> * N];<br><br>i64 P;<br><br><span class="hljs-function">i64 <span class="hljs-title">power</span><span class="hljs-params">(i64 a, i64 b, i64 p)</span> </span>&#123;<br>    i64 ret = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (; b; b /= <span class="hljs-number">2</span>, a = a * a % p) <br>        <span class="hljs-keyword">if</span> (b % <span class="hljs-number">2</span>) ret = ret * a % p;<br>    <span class="hljs-keyword">return</span> ret % p;<br>&#125;<br><br><span class="hljs-function">i64 <span class="hljs-title">inv</span><span class="hljs-params">(i64 a, i64 p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">power</span>(a, p - <span class="hljs-number">2</span>, p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-built_in">l</span>(p) = l, <span class="hljs-built_in">r</span>(p) = r;<br>    <span class="hljs-keyword">if</span> (l == r) <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(p) = a[l], <span class="hljs-built_in">ins</span>(p) = <span class="hljs-built_in">inv</span>(a[l], P), <span class="hljs-built_in">cnt</span>(p) = <span class="hljs-number">1</span>, <span class="hljs-built_in">void</span>();<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p * <span class="hljs-number">2</span>, l, mid),<br>    <span class="hljs-built_in">build</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">sum</span>(p) = <span class="hljs-built_in">sum</span>(p * <span class="hljs-number">2</span>) + <span class="hljs-built_in">sum</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>); <br>    <span class="hljs-built_in">ins</span>(p) = <span class="hljs-built_in">ins</span>(p * <span class="hljs-number">2</span>) + <span class="hljs-built_in">ins</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spread</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">flag</span>(x)) &#123;<br>        std::<span class="hljs-built_in">swap</span>(<span class="hljs-built_in">sum</span>(x * <span class="hljs-number">2</span>), <span class="hljs-built_in">ins</span>(x * <span class="hljs-number">2</span>)), <span class="hljs-built_in">flag</span>(x * <span class="hljs-number">2</span>) ^= <span class="hljs-number">1</span>;<br>        std::<span class="hljs-built_in">swap</span>(<span class="hljs-built_in">sum</span>(x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>), <span class="hljs-built_in">ins</span>(x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)), <span class="hljs-built_in">flag</span>(x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) ^= <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">flag</span>(x) = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt;= <span class="hljs-built_in">l</span>(p) &amp;&amp; r &gt;= <span class="hljs-built_in">r</span>(p)) &#123;<br>        std::<span class="hljs-built_in">swap</span>(<span class="hljs-built_in">sum</span>(p), <span class="hljs-built_in">ins</span>(p)), <span class="hljs-built_in">flag</span>(p) ^= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-built_in">l</span>(p) || l &gt; <span class="hljs-built_in">r</span>(p)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">spread</span>(p);<br>    <span class="hljs-built_in">change</span>(p * <span class="hljs-number">2</span>, l, r), <span class="hljs-built_in">change</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-built_in">sum</span>(p) = <span class="hljs-built_in">sum</span>(p * <span class="hljs-number">2</span>) + <span class="hljs-built_in">sum</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">ins</span>(p) = <span class="hljs-built_in">ins</span>(p * <span class="hljs-number">2</span>) + <span class="hljs-built_in">ins</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function">i64 <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt;= <span class="hljs-built_in">l</span>(p) &amp;&amp; r &gt;= <span class="hljs-built_in">r</span>(p)) <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(p);<br>    <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-built_in">l</span>(p) || l &gt; <span class="hljs-built_in">r</span>(p)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">spread</span>(p);<br>    i64 res = <span class="hljs-built_in">ask</span>(p * <span class="hljs-number">2</span>, l, r) + <span class="hljs-built_in">ask</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; P;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <br>        std::cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br>        <span class="hljs-type">int</span> op, l, r;<br>        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">change</span>(<span class="hljs-number">1</span>, l, r);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::cout &lt;&lt; <span class="hljs-built_in">ask</span>(<span class="hljs-number">1</span>, l, r) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ZQC 的拼图 解题报告</title>
    <link href="/ZQC-%E7%9A%84%E6%8B%BC%E5%9B%BE-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/ZQC-%E7%9A%84%E6%8B%BC%E5%9B%BE-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><h3 id="题目描述">题目描述</h3><p><span class="math inline">\(ZQC\)</span> 和他的朋友在玩拼图。她们有<span class="math inline">\(n\)</span>块神奇的拼图，还有一块拼图板。</p><p>拼图板是一个 <span class="math inline">\(m * m\)</span>的正方形网格，每格边长为 <spanclass="math inline">\(1\)</span>，如图所示。</p><p>每块拼图都是直角三角形，正面为白色，反面为黑色，拼图放在拼图板上时，必须正面朝上，直角顶点必须与拼图板上的一个格点重合.</p><p>两条直角边分别向左和向下。拼图可以重叠在一起。拼图的左/下部分可以超过拼图板的边界，如图所示。</p><p>这些拼图有一个优点，就是能伸缩，当然，拼图伸缩是要按基本法来的，具体说来就是：你可以选择一个正整数<spanclass="math inline">\(k\)</span>，并使所有拼图的每条边长都变成原来的<span class="math inline">\(k\)</span> 倍。</p><p>朋友摆好拼图后，<span class="math inline">\(ZQC\)</span>需要控制一个玩具小人儿从拼图板的左下角跑到右上角，玩家小人儿路线上的任何一点（包括端点）都要在某块拼图板上（边界或顶点也可以），现在<span class="math inline">\(ZQC\)</span>想知道他的朋友最少要把拼图的边长扩大到原来的几倍才存在一种摆放方式使得他能找到这样一条路线。</p><p>为了区分不同的拼图板，图中给他们染了不同的颜色。右图中紫色的线表示小人的一条路线。</p><h3 id="输入格式">输入格式</h3><p>第一行两个正整数 <span class="math inline">\(n\)</span> 和 <spanclass="math inline">\(m\)</span> ,表示有 <spanclass="math inline">\(n\)</span> 块拼图，拼图板边长为 <spanclass="math inline">\(m\)</span>。</p><p>接下来 <span class="math inline">\(n\)</span> 行，每行包含两个正整数<span class="math inline">\(a_i,b_i\)</span>, 表示第 <spanclass="math inline">\(i\)</span> 块拼图初始时的水平直角边长为 <spanclass="math inline">\(\frac{1}{a_i}\)</span>，垂直直角边长为 <spanclass="math inline">\(\frac{1}{b_i}\)</span>。</p><h3 id="输出格式">输出格式</h3><p>输出一行一个整数 <span class="math inline">\(k\)</span>表示拼图的边长最少要扩大到原来的 <span class="math inline">\(k\)</span>倍。</p><h2 id="分析">分析</h2><p>（实际上是我比赛时的草稿，可能会有些跳跃，不过总体应该还算清晰）</p><p><span class="math inline">\(y\)</span> 表示扩大后的长减去 <spanclass="math inline">\(\Delta y\)</span>，<spanclass="math inline">\(x\)</span> 同理</p><p>下面是思路：</p><p>最小情况：所有三角形的斜边作为向量相加为对角线(斜边为路线)，则三角形最小时直角顶点为$ (x_i, y_i) $</p><p>相似 =&gt; $ = , = $ =&gt; $ $</p><p>故 k 的最小值大于等于左式</p><p><span class="math display">\[\displaystyle{ a_i \times (x_i - x_{i - 1}) + b_i \times (y_i - y_{i -1}) \leq k }\]</span></p><p>移项，得</p><p><span class="math display">\[\displaystyle{ y_i \le \frac{k - a_i \times (x_i - x_{i - 1})}{b_i} +y_{i - 1} }\]</span></p><p>观察三角形，易得（画出来的话可能会直观一点）</p><p><span class="math display">\[\displaystyle{ \frac{k}{a_i} \ge \Delta x = x_i - x_{i - 1} \\\text{于是有} \\ x_{i - 1} \ge x_i - \frac{k}{a_i} }\]</span></p><p>又</p><p><span class="math display">\[\displaystyle{ x_i - x_{i - 1} \ge 0 }\]</span></p><p>所以</p><p><span class="math display">\[\displaystyle{ x_i \ge x_{i - 1} \ge x_i - \frac{k}{a_i} }\]</span></p><p>接下来，由得到的这两组不等式就可以求得答案了，即枚举除定值外的 <spanclass="math inline">\(i, x_i, x_{i - 1}, k\)</span></p><p>如果因变量 <span class="math inline">\(y_i\)</span> 大于等于 <spanclass="math inline">\(m\)</span>，就满足题目要求。</p><p>具体来说，最外面枚举 <spanclass="math inline">\(k\)</span>，然后枚举积木，横坐标，得到 <spanclass="math inline">\(y_n\)</span> 的最大值，然后和 <spanclass="math inline">\(m\)</span> 比较，找到最小的 <spanclass="math inline">\(k\)</span>。</p><p>根据上面的描述，不难想到状态表示：<span class="math inline">\(f[i,j]\)</span> 表示枚举到第 <span class="math inline">\(i\)</span>个积木，横坐标枚举到 <span class="math inline">\(j\)</span>时纵坐标的最大值，最后和 <span class="math inline">\(m\)</span> 比较的是<span class="math inline">\(f[n, m]\)</span>。</p><p>最后，只是简单的枚举其实还不能通过这一题，因为我们并不知道答案的具体取值范围，如果是<span class="math inline">\(1 \times 10^9\)</span>的级别，枚举一万年也算不出来，因为我们是要找最小的满足条件的 <spanclass="math inline">\(k\)</span>（大于这个值的都满足条件），所以对于<span class="math inline">\(k\)</span>，我们用二分来找到答案。</p><p>最后的时间复杂度应该是 <span class="math inline">\(O(nm^2 \log r) \(r \text{ 取你取的二分边界})\)</span></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> a[N], b[N];<br><span class="hljs-comment">// f[i, j]: 第 i 个积木，枚举到横坐标 j 时 y_i 的最大值</span><br> <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; ++ j) &#123;<br>            f[i][j] = <span class="hljs-number">-1e9</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, j - x / a[i]); k &lt;= j; ++ k) <br>                f[i][j] = std::<span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][k] + (x - a[i] * (j - k)) / b[i]);<br>        &#125;<br>    <span class="hljs-keyword">return</span> f[n][m] &gt;= m;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        std::cin &gt;&gt; a[i] &gt;&gt; b[i];<br>    &#125;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1e7</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    std::cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>A Strip of Land 解题报告</title>
    <link href="/A-Strip-of-Land-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/A-Strip-of-Land-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><h3 id="题目描述">题目描述</h3><p><span class="math inline">\(Dingilville\)</span>的居民正设法找到一块地来修建机场。他们已经有了这片地区的地图。地图是一个由单位格组成的矩形网格，每个单位格由一个整数对<span class="math inline">\((x,y)\)</span> 确定，其中 <spanclass="math inline">\(x\)</span> 是横坐标（东到西），<spanclass="math inline">\(y\)</span>是纵坐标（南到北）,地图中标注了每格的海拔。</p><p>你的任务是找到一个由单位格组成的，面积最大（即包含最多单位格）的矩形地块，使得：</p><ul><li><p>地块中海拔 最高 和 最低 的单位格的 海拔之差 不超过给定的限制<span class="math inline">\(C\)</span>；</p></li><li><p>地块的宽度（即从西到东的距离）不超过 <spanclass="math inline">\(100\)</span>；</p></li></ul><p>你需要输出满足条件地块的最大面积。</p><h3 id="输入格式">输入格式</h3><p>输入文件的第一行有三个整数 <spanclass="math inline">\(M,N,C\)</span>，代表地图的大小和给定限制。</p><p>接下来的 <span class="math inline">\(N\)</span> 行，每行有 <spanclass="math inline">\(M\)</span> 个整数 <spanclass="math inline">\(H_{xy}\)</span>，给出了每格的海拔。</p><h3 id="输出格式">输出格式</h3><p>输出一行一个正整数，即最大面积。</p><h3 id="数据规模与约定">数据规模与约定</h3><p>对于 <span class="math inline">\(10\%\)</span> 的数据，<spanclass="math inline">\(1&lt;=N,M&lt;=20, C=0,0&lt;=H_{xy}&lt;=20000\)</span>;</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(1&lt;=N,M&lt;=700, 0&lt;=C&lt;=10,-30000&lt;=H_{xy}&lt;=30000\)</span>;</p><h2 id="分析">分析</h2><p>这个题只是暴力枚举会超时，考虑优化。</p><p>对于行（y 轴），我们用双指针暴力枚举，时间复杂度是 <spanclass="math inline">\(O(m)\)</span> 。</p><p>对于列（x轴），维护每一列（两个行指针间）的最值，然后用双指针枚举每一列，用单调队列维护两个列指针间的最值信息，求得矩形在x 轴上的最长长度，然后乘以暴力枚举的 y 轴长度，时间复杂度是 <spanclass="math inline">\(O(n)\)</span>。</p><p>最后，整体的时间复杂度是 <span class="math inline">\(O(mn) \ (T(m, n)= 100mn = O(mn))\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> PII = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">710</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n, m, c, ans;<br><span class="hljs-type">int</span> a[N][N], max[N], min[N];<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">deque</span> &#123;<br>    std::deque&lt;PII&gt; s;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &amp;&amp; s.<span class="hljs-built_in">front</span>().first == x)<br>            s.<span class="hljs-built_in">pop_front</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">front</span>().second;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">size</span>() &amp;&amp; s.<span class="hljs-built_in">back</span>().second &gt;= v)<br>            s.<span class="hljs-built_in">pop_back</span>();<br>        s.<span class="hljs-built_in">push_back</span>(&#123; x, v &#125;);<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxLen</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>    deque nmx, nmn;<br>    <span class="hljs-keyword">while</span> (r &lt;= n) &#123;<br>        nmn.<span class="hljs-built_in">push</span>(r, min[r]), nmx.<span class="hljs-built_in">push</span>(r, -max[r]);<br>        <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; -nmx.<span class="hljs-built_in">front</span>() - nmn.<span class="hljs-built_in">front</span>() &gt; c)<br>            nmn.<span class="hljs-built_in">pop</span>(l), nmx.<span class="hljs-built_in">pop</span>(l), ++ l;<br>        res = std::<span class="hljs-built_in">max</span>(res, r - l + <span class="hljs-number">1</span>), ++ r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin &gt;&gt; m &gt;&gt; n &gt;&gt; c;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++ j)<br>            std::cin &gt;&gt; a[i][j];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j) <br>            max[j] = -INF, min[j] = INF;<br>        <span class="hljs-type">int</span> t = m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; i + <span class="hljs-number">100</span> &amp;&amp; j &lt;= m; ++ j) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; ++ k) &#123;<br>                max[k] = std::<span class="hljs-built_in">max</span>(max[k], a[k][j]),<br>                min[k] = std::<span class="hljs-built_in">min</span>(min[k], a[k][j]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (t * (j - i + <span class="hljs-number">1</span>) &lt;= ans) <span class="hljs-keyword">continue</span>;<br>            t = <span class="hljs-built_in">maxLen</span>(), ans = std::<span class="hljs-built_in">max</span>(ans, t * (j - i + <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>棋盘问题 解题报告</title>
    <link href="/%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<p>切一道简单dfs找一找自信 <span id="more"></span> ## 题目<strong>Description</strong><br />在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。</p><p><strong>Input</strong><br />输入含有多组测试数据。 每组数据的第一行是两个正整数，nk，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。n &lt;= 8 , k &lt;= n 当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， .表示空白区域（数据保证不出现多余的空白行或者空白列）。</p><p><strong>Output</strong><br />对于每一组数据，给出一行输出，输出摆放的方案数目C（数据保证C&lt;2^31）。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10</span>;<br><span class="hljs-type">char</span> x;<br><span class="hljs-type">int</span> n, m, ans;<br><span class="hljs-type">bool</span> r[N], c[N];<br><span class="hljs-type">bool</span> g[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> cnt)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cnt + n - now + <span class="hljs-number">1</span> &lt; m) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (now == n + <span class="hljs-number">1</span>) <br>        <span class="hljs-keyword">if</span> (cnt == m) <span class="hljs-keyword">return</span> <span class="hljs-built_in">void</span>(++ ans);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>        <span class="hljs-keyword">if</span> (!c[now] &amp;&amp; !r[i] &amp;&amp; g[now][i]) <br>            c[now] = r[i] = <span class="hljs-literal">true</span>,<br>            <span class="hljs-built_in">dfs</span>(now + <span class="hljs-number">1</span>, cnt + <span class="hljs-number">1</span>),<br>            c[now] = r[i] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">dfs</span>(now + <span class="hljs-number">1</span>, cnt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (std::cin &gt;&gt; n &gt;&gt; m, n != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> g),<br>        <span class="hljs-built_in">memset</span>(c, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> c),<br>        <span class="hljs-built_in">memset</span>(r, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> r);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j)<br>                std::cin &gt;&gt; x, g[i][j] = x == <span class="hljs-string">&#x27;#&#x27;</span>;<br>        ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Atlantis 解题报告</title>
    <link href="/Atlantis-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/Atlantis-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<p>学习扫描线算法 <span id="more"></span></p><h2 id="题目">题目</h2><p><strong>题目描述</strong><br />有几个古希腊书籍中包含了对传说中的亚特兰蒂斯岛的描述。<br />其中一些甚至包括岛屿部分地图。<br />但不幸的是，这些地图描述了亚特兰蒂斯的不同区域。<br />您的朋友 Bill 必须知道地图的总面积。<br />你自告奋勇写了一个计算这个总面积的程序。</p><p><strong>输入格式</strong><br />输入包含多组测试用例。<br />对于每组测试用例，第一行包含整数 <spanclass="math inline">\(n\)</span>，表示总的地图数量。<br />接下来 <span class="math inline">\(n\)</span>行，描绘了每张地图，每行包含四个数字 <spanclass="math inline">\(x_1\)</span>,<spanclass="math inline">\(y_1\)</span>,<spanclass="math inline">\(x_2\)</span>,<spanclass="math inline">\(y_2\)</span>（不一定是整数）,<spanclass="math inline">\((x_1,y_1)\)</span>和<spanclass="math inline">\((x_2,y_2)\)</span>分别是地图的左上角位置和右下角位置。<br />注意，坐标轴 <span class="math inline">\(x\)</span>轴从上向下延伸，<span class="math inline">\(y\)</span>轴从左向右延伸。<br />当输入用例 <span class="math inline">\(n=0\)</span>时，表示输入终止，该用例无需处理。</p><p><strong>输出格式</strong><br />每组测试用例输出两行。<br />第一行输出"Test case #k"，其中 <span class="math inline">\(k\)</span>是测试用例的编号，从 <span class="math inline">\(1\)</span> 开始。<br />第二行输出"Total explored area: a"，其中 <spanclass="math inline">\(a\)</span>是总地图面积（即此测试用例中所有矩形的面积并，注意如果一片区域被多个地图包含，则在计算总面积时只计算一次），精确到小数点后两位数。<br />在每个测试用例后输出一个空行。</p><h2 id="分析">分析</h2><p><img src="https://oi-wiki.org/geometry/images/scanning.svg" style="zoom:50%;" />图片来自OIWIKI</p><p>具体算法就是用线段树给每个矩形的上下边进行标记，下面标记为 <spanclass="math inline">\(1\)</span>，上面标记为 <spanclass="math inline">\(-1\)</span>，然后从下往上不断统计答案，然后更新线段树。</p><p>需要注意的是，每个线我们保存的是一个区间的信息，所以需要注意 <spanclass="math inline">\(r + 1\)</span> 或 <span class="math inline">\(r -1\)</span>。</p><p>因为每个节点坐标的取值区间太大，所以我们要离散化，然后二分找值。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Seg</span> &#123;<br>    <span class="hljs-type">int</span> f;<br>    <span class="hljs-type">double</span> l, r, h;<br>    <span class="hljs-built_in">Seg</span> () &#123; &#125;<br>    <span class="hljs-built_in">Seg</span> (<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r, <span class="hljs-type">double</span> h, <span class="hljs-type">int</span> f) : <span class="hljs-built_in">l</span>(l), <span class="hljs-built_in">r</span>(r), <span class="hljs-built_in">h</span>(h), <span class="hljs-built_in">f</span>(f) &#123; &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (Seg&amp; rst) &#123; <span class="hljs-keyword">return</span> h &lt; rst.h; &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">P</span> &#123;<br>    <span class="hljs-type">int</span> cnt; <span class="hljs-type">double</span> len;<br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20010</span>;<br>Seg e[N];<br>P t[N * <span class="hljs-number">4</span>];<br><span class="hljs-type">double</span> X[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (t[root].cnt)<br>        t[root].len = X[r + <span class="hljs-number">1</span>] - X[l];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l == r)<br>        t[root].len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <br>        t[root].len = t[root * <span class="hljs-number">2</span>].len + t[root * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;<br>        t[root].cnt += val;<br>        <span class="hljs-built_in">pushdown</span>(l, r, root);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (L &lt;= mid) <span class="hljs-built_in">update</span>(L, R, l, mid, root * <span class="hljs-number">2</span>, val);<br>    <span class="hljs-keyword">if</span> (R &gt; mid) <span class="hljs-built_in">update</span>(L, R, mid + <span class="hljs-number">1</span>, r, root * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, val);<br>    <span class="hljs-built_in">pushdown</span>(l, r, root);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, q = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">double</span> a, b, c, d;<br>    <span class="hljs-keyword">while</span> (std::cin &gt;&gt; n, n) &#123;<br>        <span class="hljs-built_in">memset</span>(t, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> t);<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;<br>            X[cnt] = a, e[cnt ++] = <span class="hljs-built_in">Seg</span> (a, c, b, <span class="hljs-number">1</span>);<br>            X[cnt] = c, e[cnt ++] = <span class="hljs-built_in">Seg</span> (a, c, d, <span class="hljs-number">-1</span>);<br>        &#125;<br>        std::<span class="hljs-built_in">sort</span>(X, X + cnt),<br>        std::<span class="hljs-built_in">sort</span>(e, e + cnt);<br>        <span class="hljs-type">int</span> all = std::<span class="hljs-built_in">unique</span>(X, X + cnt) - X;<br>        <span class="hljs-type">double</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; ++ i) &#123;<br>            <span class="hljs-type">int</span> l = std::<span class="hljs-built_in">lower_bound</span>(X, X + all, e[i].l) - X;<br>            <span class="hljs-type">int</span> r = std::<span class="hljs-built_in">lower_bound</span>(X, X + all, e[i].r) - X - <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">update</span>(l, r, <span class="hljs-number">0</span>, all, <span class="hljs-number">1</span>, e[i].f);<br>            ans += t[<span class="hljs-number">1</span>].len * (e[i + <span class="hljs-number">1</span>].h - e[i].h);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test case #%d\nTotal explored area: %.2lf\n\n&quot;</span>, q ++, ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>扫描线</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 135 (Rated for Div. 2)  A-D 解题报告</title>
    <link href="/Educational-Codeforces-Round-135-Rated-for-Div-2-A-C-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/Educational-Codeforces-Round-135-Rated-for-Div-2-A-C-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="a.-colored-balls-revisited">A. Colored Balls: Revisited</h2><p><strong>大致题意</strong></p><p>一个袋子里装有 <span class="math inline">\(n\)</span>种颜色的球，各有 <span class="math inline">\(cnt_1, cnt_2, \dots,cnt_n\)</span>个。每次拿两个不同颜色的球，最后剩下的球可能是哪个颜色？</p><p><strong>分析</strong></p><p>易知最后剩下的球一定是最大的。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>std::cin &gt;&gt; n;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>    std::cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">if</span> (a[i] &gt;= res) <br>        res = a[i], ans = i;<br>&#125;<br>std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="b.-best-permutation">B. Best Permutation</h2><p><strong>大致题意</strong></p><p>给定一个 <span class="math inline">\(n\)</span> 排列 <spanclass="math inline">\(p\)</span>，现有一初值为 <spanclass="math inline">\(0\)</span> 的整数 <spanclass="math inline">\(x\)</span>。依次经过排列中的数，对于每个数，<spanclass="math inline">\(x\)</span> 的值的变化为： <spanclass="math display">\[x \gets\begin{cases}0  &amp; \text{if } x \ge p_i \\x + p_i &amp; \text{otherwise}\end{cases}\notag\]</span> 求得一个排列，使得 <span class="math inline">\(x\)</span>最大。</p><p><strong>分析</strong></p><p>为了使 <span class="math inline">\(x\)</span> 最大，最后在 <spanclass="math inline">\(p_n\)</span> 的时候我们必须使得 <spanclass="math inline">\(x_n \gets x_{n - 1} + p_n\)</span>，一定比 <spanclass="math inline">\(x_n \gets 0\)</span> 要大，所以 <spanclass="math inline">\(x_{n - 1}\)</span> 必须要小于 <spanclass="math inline">\(p_{n}\)</span>，也就是说 <spanclass="math inline">\(x\)</span> 的最大值是 <spanclass="math inline">\(2n - 1\)</span>。</p><p>为了构造出一个这样的排列，我们使用以下方案：</p><ol type="1"><li><p>对于 <span class="math inline">\(n - 2\)</span> 是偶数，我们构造<span class="math inline">\(2, 1, 4, 3, \dots, n - 1,n\)</span></p></li><li><p>对于 <span class="math inline">\(n - 2\)</span> 是奇数，我们构造<span class="math inline">\(1, 3, 2, 5, 4 \dots, n - 1,n\)</span></p></li></ol><p>这样就能使得 <span class="math inline">\(x_{n - 2}\)</span> 一定为<span class="math inline">\(0\)</span>，最终的 <spanclass="math inline">\(x\)</span> 的值也就是最大值 <spanclass="math inline">\(2n - 1\)</span>。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n; <br>std::cin &gt;&gt; n;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) a[i] = i + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n &amp; <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">2</span>; i += <span class="hljs-number">2</span>) <br>    std::<span class="hljs-built_in">swap</span>(a[i], a[i + <span class="hljs-number">1</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i)<br>    std::cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="c.-digital-logarithm">C. Digital Logarithm</h2><p><strong>大致题意</strong></p><p>给定两个数列 <span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span>，每个数列包括 <spanclass="math inline">\(n\)</span> 个正整数。函数 <spanclass="math inline">\(f(x)\)</span> 表示 <spanclass="math inline">\(x\)</span>的十进制位数，对于每次操作，你可以选择一个数列，使得 <spanclass="math inline">\(a_i \gets f(a_i)\)</span> 或 <spanclass="math inline">\(b_i \getsf(b_i)\)</span>。当两个数列排序后相等，我们称两个数列相似，输出最小的操作次数，使得<span class="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 相似。</p><p><strong>分析</strong></p><p>注意到，每次将位数赋值给该数都会使该数变小，最坏情况下，我们可以使每个数都赋值为<span class="math inline">\(1\)</span>，使得两个数列相似。</p><p>于是，对于每个数，为了使数列相似，可以采取两种操作：</p><ol type="1"><li>将位数赋值给该数，使得这个数等于另一个数列中更小的一个数</li><li>将另一个数列中更大的数赋值位数，使得更大的数赋值后等于该数</li></ol><p>对于两个数列中最大的数，若不存在一个数与其相等，那么这个数一定要进行赋值位数，如果存在一个数与其相等，直接跳过即可。</p><p>为了实现上述操作，我们可以使用 <strong>大根堆</strong>。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>std::cin &gt;&gt; n;<br>std::priority_queue&lt;<span class="hljs-type">int</span>&gt; a, b;    <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= n; ++ i)<br>    std::cin &gt;&gt; x, a.<span class="hljs-built_in">push</span>(x);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= n; ++ i)<br>    std::cin &gt;&gt; x, b.<span class="hljs-built_in">push</span>(x);<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (a.<span class="hljs-built_in">size</span>() || b.<span class="hljs-built_in">size</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">top</span>() == b.<span class="hljs-built_in">top</span>()) &#123;<br>        a.<span class="hljs-built_in">pop</span>(), b.<span class="hljs-built_in">pop</span>();<br>       <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">top</span>() &gt; b.<span class="hljs-built_in">top</span>())<br>        a.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">to_string</span>(a.<span class="hljs-built_in">top</span>()).<span class="hljs-built_in">size</span>()), a.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">else</span><br>        b.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">to_string</span>(b.<span class="hljs-built_in">top</span>()).<span class="hljs-built_in">size</span>()), b.<span class="hljs-built_in">pop</span>();<br>    ++ ans;<br>&#125;<br>std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="d.-letter-picking">D. Letter Picking</h2><p><strong>大致题意</strong></p><p>Alice 和 Bob 玩游戏，Alice 是先手，每次每人可以从一个字符串 <spanclass="math inline">\(s\)</span> (<span class="math inline">\(s.length\bmod 2 = 0\)</span>)的开头或结尾选择一个字符，放在自己的字符串的<strong>末尾处</strong>，最后字符串字典序更小的获胜，若字典序相同，则平局。</p><p><strong>分析</strong></p><p>区间dp，要考虑的情况较多。设 <span class="math inline">\(f_{l,r}\)</span> 表示对于子字符串 <span class="math inline">\(s[l \dotsr]\)</span> 时的游戏状态，用值 <span class="math inline">\(1\)</span>表示 <strong>Alice</strong> 获胜，<span class="math inline">\(0\)</span>表示 <strong>平局</strong> ，<span class="math inline">\(-1\)</span>表示 <strong>Bob</strong> 获胜。</p><p>首先考虑 <span class="math inline">\(l\)</span> 与 <spanclass="math inline">\(r\)</span> 相邻，此时若 <spanclass="math inline">\(s_l = s_r\)</span> ，则 <strong>平局</strong>，否则 <strong>Alice</strong> 获胜。</p><p>然后考虑之前已经获胜或失败的情况，因为字符是倒序排列的，所以如果之前已经获胜就必定获胜。</p><p>具体来说，分三种情况：</p><ol type="1"><li><p><strong>Alice</strong> 选 <spanclass="math inline">\(s_l\)</span></p><p>若 <strong>Bob</strong> 不管选 <span class="math inline">\(s_{l +1}\)</span> 还是 <span class="math inline">\(s_r\)</span>都已经获胜，那么一定获胜</p><p>即 <span class="math inline">\(f_{l, r} \gets [f[l + 1, r - 1] = f[l+ 2, r] = 1]\)</span></p></li><li><p><strong>Alice</strong> 选 <spanclass="math inline">\(s_r\)</span></p><p>若 <strong>Bob</strong> 不管选 <spanclass="math inline">\(s_{l}\)</span> 还是 <spanclass="math inline">\(s_{r - 1}\)</span> 都已经获胜，那么一定获胜</p><p>即 <span class="math inline">\(f_{l, r} \gets [f[l + 1, r - 1] = f[l,r - 2] = 1]\)</span></p></li><li><p>不管 <strong>Alice</strong> 选 <spanclass="math inline">\(s_l\)</span> 还是 <spanclass="math inline">\(s_r\)</span> 都已经失败，那么一定失败</p><p>即 <span class="math inline">\(f[l + 1, r - 1] = f[l + 2, r] = -1 \\text{and} \ f[l + 1, r - 1] = f[l, r - 2] = -1\)</span> 时，<spanclass="math inline">\(f_{l, r} \gets -1\)</span></p></li></ol><p>接下来，考虑之前已经平局的情况，同样是分 <strong>Alice</strong> 选<span class="math inline">\(s_l\)</span> 和 <spanclass="math inline">\(s_r\)</span>，这里讨论选 <spanclass="math inline">\(s_l\)</span>：</p><p>若 <strong>Bob</strong> 不能够获胜，则至少是平局，若不是平局则<strong>Alice</strong> 获胜。</p><p>即 <span class="math inline">\(\text{not } ((s_r &lt; s_l \text{ and} f[l + 1, r - 1] = 0) \text{ or } (s_{l + 1} &lt; s_l \ \text{ and } \f[l + 1, r - 1] = 0))\)</span> 时，若字典序不相同，则<strong>Alice</strong> 获胜，否则 <strong>平局</strong>。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string s;<br>std::cin &gt;&gt; s;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-function">std::vector <span class="hljs-title">f</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;(s.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k &lt;= s.<span class="hljs-built_in">size</span>(); k += <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt;= s.<span class="hljs-built_in">size</span>() - k; ++ l) &#123;<br>        <span class="hljs-type">int</span> r = l + k - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (s[l] != s[r]) f[l][r] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">min</span>(f[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>], f[l + <span class="hljs-number">2</span>][r]) == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// choose s[l], already win</span><br>                f[l][r] = <span class="hljs-number">1</span>; <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">min</span>(f[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>], f[l][r - <span class="hljs-number">2</span>]) == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// choose s[r], already win</span><br>                f[l][r] = <span class="hljs-number">1</span>; <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">min</span>(f[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>], f[l + <span class="hljs-number">2</span>][r]) == <span class="hljs-number">-1</span> &amp;&amp; std::<span class="hljs-built_in">min</span>(f[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>], f[l][r - <span class="hljs-number">2</span>]) == <span class="hljs-number">-1</span>) &#123;  <span class="hljs-comment">// whatever, already defeated</span><br>                f[l][r] = <span class="hljs-number">-1</span>; <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            f[l][r] = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">min</span>(f[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>], f[l + <span class="hljs-number">2</span>][r]) == <span class="hljs-number">0</span>)  <span class="hljs-comment">// choose s[l], draw before</span><br>                <span class="hljs-keyword">if</span> (!(s[r] &lt; s[l] &amp;&amp; f[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &amp;&amp; !(s[l + <span class="hljs-number">1</span>] &lt; s[l] &amp;&amp; f[l + <span class="hljs-number">2</span>][r] == <span class="hljs-number">0</span>)) &#123;  <span class="hljs-comment">// not defeated, at least draw</span><br>                    f[l][r] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">if</span> (!(s[r] == s[l] &amp;&amp; f[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &amp;&amp; !(s[l + <span class="hljs-number">1</span>] == s[l] &amp;&amp; f[l + <span class="hljs-number">2</span>][r] == <span class="hljs-number">0</span>)) <span class="hljs-comment">// not draw, win</span><br>                        f[l][r] = <span class="hljs-number">1</span>;<br>                &#125;<br>            <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">min</span>(f[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>], f[l][r - <span class="hljs-number">2</span>]) == <span class="hljs-number">0</span>)  <span class="hljs-comment">// choose s[r], draw before</span><br>                <span class="hljs-keyword">if</span> (!(s[l] &lt; s[r] &amp;&amp; f[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &amp;&amp; !(s[r - <span class="hljs-number">1</span>] &lt; s[r] &amp;&amp; f[l][r - <span class="hljs-number">2</span>] == <span class="hljs-number">0</span>)) &#123; <span class="hljs-comment">// not defeated, at least draw</span><br>                    f[l][r] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">if</span> (!(s[l] == s[r] &amp;&amp; f[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &amp;&amp; !(s[r - <span class="hljs-number">1</span>] == s[r] &amp;&amp; f[l][r - <span class="hljs-number">2</span>] == <span class="hljs-number">0</span>)) <span class="hljs-comment">// not draw, win</span><br>                        f[l][r] = <span class="hljs-number">1</span>;<br>                &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">if</span> (f[<span class="hljs-number">0</span>][s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] ==  <span class="hljs-number">1</span>) std::cout &lt;&lt; <span class="hljs-string">&quot;Alice&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">if</span> (f[<span class="hljs-number">0</span>][s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] ==  <span class="hljs-number">0</span>) std::cout &lt;&lt; <span class="hljs-string">&quot;Draw&quot;</span>  &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">if</span> (f[<span class="hljs-number">0</span>][s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>) std::cout &lt;&lt; <span class="hljs-string">&quot;Bob&quot;</span>   &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区间dp</tag>
      
      <tag>思维</tag>
      
      <tag>构造</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回文 解题报告</title>
    <link href="/%E5%9B%9E%E6%96%87-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/%E5%9B%9E%E6%96%87-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><h3 id="题目描述">题目描述</h3><p>给定正整数 <span class="math inline">\(n\)</span> 和整数序列 <spanclass="math inline">\(a_1,a_2,\cdots,a_{2n}\)</span> ，在这 <spanclass="math inline">\(2n\)</span> 个数中，<spanclass="math inline">\(1,2,\cdots,n\)</span> 分别各出现恰好 <spanclass="math inline">\(2\)</span> 次。现在进行 <spanclass="math inline">\(2n\)</span> 次操作，目标是创建一个长度同样为 <spanclass="math inline">\(2n\)</span> 的序列 <spanclass="math inline">\(b_1,b_2,\cdots,b_{2n}\)</span> ，初始时 <spanclass="math inline">\(b\)</span>为空序列，每次可以进行以下两种操作之一：</p><ol type="1"><li>将序列 <span class="math inline">\(a\)</span> 的开头元素加到 <spanclass="math inline">\(b\)</span> 的末尾，并从 <spanclass="math inline">\(a\)</span> 中移除<br /></li><li>将序列 <span class="math inline">\(a\)</span> 的末尾元素加到 <spanclass="math inline">\(b\)</span> 的末尾，并从 <spanclass="math inline">\(a\)</span> 中移除</li></ol><p>我们的目的是让 <span class="math inline">\(b\)</span>成为一个<strong>回文数列</strong>，即令其满足对所有 <spanclass="math inline">\(1\leq i\leq n\)</span>，有 <spanclass="math inline">\(b_i=b_{2n+1-i}\)</span>。请你判断该目的是否能达成，如果可以，请输出字典序最小的操作方案。</p><h3 id="输入格式">输入格式</h3><p>每个测试点包含多组测试数据。 输入的第一行包含一个整数 <spanclass="math inline">\(T\)</span>，表示测试数据的组数。每组测试数据的第一行包含一个正整数 <spanclass="math inline">\(n\)</span>，第二行包含 <spanclass="math inline">\(2n\)</span> 个用空格隔开的整数 <spanclass="math inline">\(a_1,a_2,\cdots,a_{2n}\)</span>。</p><h3 id="输出格式">输出格式</h3><p>对每个测试数据输出一行答案。 如果无法生成出回文数列，输出一行 <spanclass="math inline">\(-1\)</span>，否则输出一行一个长度为 <spanclass="math inline">\(2n\)</span> 的、由字符 <strong>L</strong> 或<strong>R</strong> 构成的字符串（不含空格），其中 <strong>L</strong>表示移除开头元素的操作1，<strong>R</strong> 表示操作2。你需要输出所有方案对应的字符串中字典序最小的一个。</p><h2 id="分析">分析</h2><p>选择了第一个选左边或者右边之后，不难想到第一个选到的数所对应的另一个数一定要最后一个输出，为了达到最后一个输出，这个两边的数要分开处理，左边的数对应的都是<strong>L</strong>，右边的数对应的都是 <strong>R</strong>。</p><p>将这两边看做两个队列 <span class="math inline">\(L\)</span> 和 <spanclass="math inline">\(R\)</span>，首先我们感性地考虑：两边队头对应的另一个数一定比较“远”，猜测可能是两边队列的队尾。接下来我们证明一定是队尾：</p><p>假设接下来要确定的回文子串的长度是 <spanclass="math inline">\(l\)</span>（先前确定在答案序列中的数已在队列中删除），那么<span class="math inline">\(|L| + |R| - 2 = l -2\)</span>，就是说除了这两个数之外的 <span class="math inline">\(l -2\)</span>个数都要先弹出队列，如果对应的这个数不在队尾，那么除非包括这个数弹出，弹出队列的数量达不到<span class="math inline">\(l -2\)</span>，就是说这个数把队列卡住了。由此，证明了对头对应的数一定是队尾，如果两个队列的队尾都没有对应的数，就说明无解。</p><p>确定队头对应的数一定是其中一个队列的队尾之后，把这个两个数从队列中删除也就不难了，只需实现两个双端队列，弹出一个队头之后把这个队尾也弹出就行了，假设队头的答案序列位置是<span class="math inline">\(k\)</span>，那么对应的队尾的位置就是 <spanclass="math inline">\(n - k + 1\)</span>。</p><p>考虑字典序，我们优先把第一个数选为<strong>L</strong>，并且队头也要优先考虑 <strong>L</strong> 。</p><h2 id="代码">代码</h2><p>因为不熟悉 <strong>STL</strong>所以写了数组模拟队列，看不懂的话很抱歉。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">char</span> res[N];<br><span class="hljs-type">int</span> n, cnt, a[N];<br><span class="hljs-type">int</span> q1[N], q2[N], h1, h2, t1, t2;<br> <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">char</span> fst)</span> </span>&#123;<br>    h1 = h2 = <span class="hljs-number">0</span>, t1 = t2 = <span class="hljs-number">1</span>, cnt = <span class="hljs-number">2</span>, res[<span class="hljs-number">1</span>] = fst, res[n] = <span class="hljs-string">&#x27;L&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <br>        <span class="hljs-keyword">if</span> ((fst == <span class="hljs-string">&#x27;L&#x27;</span> &amp;&amp; a[i] == a[<span class="hljs-number">1</span>] &amp;&amp; i != <span class="hljs-number">1</span>) || (fst == <span class="hljs-string">&#x27;R&#x27;</span> &amp;&amp; a[i] == a[n] &amp;&amp; i != n)) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">1</span> || (j == <span class="hljs-number">1</span> &amp;&amp; fst == <span class="hljs-string">&#x27;R&#x27;</span>); -- j) <br>                q1[++ h1] = a[j];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n || (j == n &amp;&amp; fst == <span class="hljs-string">&#x27;L&#x27;</span>); ++ j) <br>                q2[++ h2] = a[j];<br>        &#125;<br>    <span class="hljs-keyword">while</span> (h1 &gt;= t1 || h2 &gt;= t2) &#123;<br>        <span class="hljs-keyword">if</span> (h1 == t1 &amp;&amp; h2 == t2 &amp;&amp; q1[h1] == q2[h2]) &#123;<br>            res[cnt] = <span class="hljs-string">&#x27;L&#x27;</span>, res[cnt + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;R&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((h1 &gt; t1 &amp;&amp; (q1[h1] == q1[t1] || (h2 &gt;= t2 &amp;&amp; q1[h1] == q2[t2]))) || (h1 == t1 &amp;&amp; q1[h1] == q2[t2])) &#123;<br>            <span class="hljs-keyword">if</span> (h1 &gt; t1 &amp;&amp; q1[h1] == q1[t1]) res[n - cnt + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;L&#x27;</span>, ++ t1;<br>            <span class="hljs-keyword">else</span> res[n - cnt + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;R&#x27;</span>, ++ t2;<br>            -- h1, res[cnt ++] = <span class="hljs-string">&#x27;L&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((h2 &gt; t2 &amp;&amp; (q2[h2] == q2[t2] || (h1 &gt;= t1 &amp;&amp; q2[h2] == q1[t1]))) || (h2 == t2 &amp;&amp; q2[h2] == q1[t1])) &#123;<br>            <span class="hljs-keyword">if</span> (h2 &gt; t2 &amp;&amp; q2[h2] == q2[t2]) res[n - cnt + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;R&#x27;</span>, ++ t2;<br>            <span class="hljs-keyword">else</span> res[n - cnt + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;L&#x27;</span>, ++ t1;<br>            -- h2, res[cnt ++] = <span class="hljs-string">&#x27;R&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <br>        std::cout &lt;&lt; res[i];<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t; std::cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t --) &#123;<br>        std::cin &gt;&gt; n, n += n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>            std::cin &gt;&gt; a[i];<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">solve</span>(<span class="hljs-string">&#x27;L&#x27;</span>) &amp;&amp; !<span class="hljs-built_in">solve</span>(<span class="hljs-string">&#x27;R&#x27;</span>)) <br>            std::cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些模板总结</title>
    <link href="/%E4%B8%80%E4%BA%9B%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/"/>
    <url>/%E4%B8%80%E4%BA%9B%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>打算把一些模板放在博客里备用（因为有些东西太难调了），个人觉得自己的码风还算简洁，可以参考下。</p><h2 id="扫描线算法">扫描线算法</h2><p>模板题 <a href="https://acm.hdu.edu.cn/showproblem.php?pid=1542">HDU1542</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Seg</span> &#123;<br>    <span class="hljs-type">int</span> f;<br>    <span class="hljs-type">double</span> l, r, h;<br>    <span class="hljs-built_in">Seg</span> () &#123; &#125;<br>    <span class="hljs-built_in">Seg</span> (<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r, <span class="hljs-type">double</span> h, <span class="hljs-type">int</span> f) : <span class="hljs-built_in">l</span>(l), <span class="hljs-built_in">r</span>(r), <span class="hljs-built_in">h</span>(h), <span class="hljs-built_in">f</span>(f) &#123; &#125;<br> <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (Seg&amp; rst) &#123; <span class="hljs-keyword">return</span> h &lt; rst.h; &#125;<br>&#125;;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">P</span> &#123;<br>    <span class="hljs-type">int</span> cnt; <span class="hljs-type">double</span> len;<br>&#125;;<br> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20010</span>;<br>Seg e[N];<br>P t[N * <span class="hljs-number">4</span>];<br><span class="hljs-type">double</span> X[N];<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (t[root].cnt)<br>        t[root].len = X[r + <span class="hljs-number">1</span>] - X[l];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l == r)<br>        t[root].len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <br>        t[root].len = t[root * <span class="hljs-number">2</span>].len + t[root * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].len;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;<br>        t[root].cnt += val;<br>        <span class="hljs-built_in">pushdown</span>(l, r, root);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (L &lt;= mid) <span class="hljs-built_in">update</span>(L, R, l, mid, root * <span class="hljs-number">2</span>, val);<br>    <span class="hljs-keyword">if</span> (R &gt; mid) <span class="hljs-built_in">update</span>(L, R, mid + <span class="hljs-number">1</span>, r, root * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, val);<br>    <span class="hljs-built_in">pushdown</span>(l, r, root);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, q = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">double</span> a, b, c, d;<br>    <span class="hljs-keyword">while</span> (std::cin &gt;&gt; n, n) &#123;<br>        <span class="hljs-built_in">memset</span>(t, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> t);<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;<br>            X[cnt] = a, e[cnt ++] = <span class="hljs-built_in">Seg</span> (a, c, b, <span class="hljs-number">1</span>);<br>            X[cnt] = c, e[cnt ++] = <span class="hljs-built_in">Seg</span> (a, c, d, <span class="hljs-number">-1</span>);<br>        &#125;<br>        std::<span class="hljs-built_in">sort</span>(X, X + cnt),<br>        std::<span class="hljs-built_in">sort</span>(e, e + cnt);<br>        <span class="hljs-type">int</span> all = std::<span class="hljs-built_in">unique</span>(X, X + cnt) - X;<br>        <span class="hljs-type">double</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; ++ i) &#123;<br>            <span class="hljs-type">int</span> l = std::<span class="hljs-built_in">lower_bound</span>(X, X + all, e[i].l) - X;<br>            <span class="hljs-type">int</span> r = std::<span class="hljs-built_in">lower_bound</span>(X, X + all, e[i].r) - X - <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">update</span>(l, r, <span class="hljs-number">0</span>, all, <span class="hljs-number">1</span>, e[i].f);<br>            ans += t[<span class="hljs-number">1</span>].len * (e[i + <span class="hljs-number">1</span>].h - e[i].h);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test case #%d\nTotal explored area: %.2lf\n\n&quot;</span>, q ++, ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="treap">Treap</h2><p><strong>带旋</strong><br />这里写的是指针版，因为感觉指针更简洁易懂一点，不过实际调的时候发现好像难调得多。。。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">item</span> &#123;<br><span class="hljs-type">int</span> key, prior, cnt, size;<br>item *l, *r;<br><span class="hljs-built_in">item</span> () &#123; &#125;<br><span class="hljs-built_in">item</span> (<span class="hljs-type">int</span> key) : <span class="hljs-built_in">key</span>(key), <span class="hljs-built_in">prior</span>(std::<span class="hljs-built_in">rand</span>()), <span class="hljs-built_in">l</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">r</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">cnt</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">size</span>(<span class="hljs-number">1</span>) &#123; &#125;<br>&#125;;<br><br><span class="hljs-keyword">using</span> pitem = item*;<br><br>pitem root = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(pitem&amp; x)</span> </span>&#123;<br>x-&gt;size = x-&gt;cnt + (x-&gt;l ? x-&gt;l-&gt;size : <span class="hljs-number">0</span>) + (x-&gt;r ? x-&gt;r-&gt;size : <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zig</span><span class="hljs-params">(pitem&amp; x)</span> </span>&#123;<br>pitem y = x-&gt;l;<br>x-&gt;l = y-&gt;r, y-&gt;r = x, x = y;<br><span class="hljs-built_in">update</span>(x), <span class="hljs-built_in">update</span>(x-&gt;r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zag</span><span class="hljs-params">(pitem&amp; x)</span> </span>&#123;<br>pitem y = x-&gt;r;<br>x-&gt;r = y-&gt;l, y-&gt;l = x, x = y;<br><span class="hljs-built_in">update</span>(x), <span class="hljs-built_in">update</span>(x-&gt;l);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(pitem&amp; x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!x) <br><span class="hljs-keyword">return</span> x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">item</span>(y), <span class="hljs-built_in">void</span>();<br><span class="hljs-keyword">if</span> (x-&gt;key == y) <br><span class="hljs-keyword">return</span> ++ x-&gt;cnt, <span class="hljs-built_in">update</span>(x), <span class="hljs-built_in">void</span>();<br><span class="hljs-keyword">if</span> (y &lt; x-&gt;key) &#123;<br><span class="hljs-built_in">insert</span>(x-&gt;l, y);<br><span class="hljs-keyword">if</span> (x-&gt;l-&gt;prior &gt; x-&gt;prior) <span class="hljs-built_in">zig</span>(x);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">insert</span>(x-&gt;r, y);<br><span class="hljs-keyword">if</span> (x-&gt;r-&gt;prior &gt; x-&gt;prior) <span class="hljs-built_in">zag</span>(x);<br>&#125;<br><span class="hljs-built_in">update</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(pitem&amp; x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (y &lt; x-&gt;key) <span class="hljs-built_in">remove</span>(x-&gt;l, y);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y &gt; x-&gt;key) <span class="hljs-built_in">remove</span>(x-&gt;r, y);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (x-&gt;cnt &gt; <span class="hljs-number">1</span>) -- x-&gt;cnt;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!x-&gt;l) x = x-&gt;r;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!x-&gt;r) x = x-&gt;l;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">zag</span>(x);<br><span class="hljs-built_in">remove</span>(x-&gt;l, y);<br><span class="hljs-keyword">if</span> (x-&gt;l &amp;&amp; x-&gt;l-&gt;prior &gt; x-&gt;prior)<br><span class="hljs-built_in">zig</span>(x);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (x) <span class="hljs-built_in">update</span>(x);<br>&#125;<br><br><span class="hljs-function">pitem <span class="hljs-title">getPre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>pitem x = root, ans = <span class="hljs-keyword">new</span> <span class="hljs-built_in">item</span>(<span class="hljs-number">-1e9</span>);<br><span class="hljs-keyword">while</span> (x) &#123;<br><span class="hljs-keyword">if</span> (v == x-&gt;key) <br><span class="hljs-keyword">if</span> (x-&gt;l) &#123;<br>x = x-&gt;l;<br><span class="hljs-keyword">while</span> (x-&gt;r) x = x-&gt;r;<br>ans = x;<br>&#125;<br><span class="hljs-keyword">if</span> (x-&gt;key &lt; v &amp;&amp; x-&gt;key &gt; ans-&gt;key) <br>ans = x;<br>x = v &lt; x-&gt;key ? x-&gt;l : x-&gt;r;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">pitem <span class="hljs-title">getNxt</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>pitem x = root, ans = <span class="hljs-keyword">new</span> <span class="hljs-built_in">item</span>(<span class="hljs-number">1e9</span>);<br><span class="hljs-keyword">while</span> (x) &#123;<br><span class="hljs-keyword">if</span> (v == x-&gt;key) <br><span class="hljs-keyword">if</span> (x-&gt;r) &#123;<br>x = x-&gt;r;<br><span class="hljs-keyword">while</span> (x-&gt;l) x = x-&gt;l;<br>&#125;<br><span class="hljs-keyword">if</span> (x-&gt;key &gt; v &amp;&amp; x-&gt;key &lt; ans-&gt;key)<br>ans = x;<br>x = v &gt; x-&gt;key ? x-&gt;r : x-&gt;l;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValByRank</span><span class="hljs-params">(pitem&amp; x, <span class="hljs-type">int</span> rank)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!x) <span class="hljs-keyword">return</span> <span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">if</span> ((x-&gt;l ? x-&gt;l-&gt;size : <span class="hljs-number">0</span>) &gt;= rank)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">getValByRank</span>(x-&gt;l, rank);<br><span class="hljs-keyword">if</span> ((x-&gt;l ? x-&gt;l-&gt;size : <span class="hljs-number">0</span>) + x-&gt;cnt &gt;= rank) <br><span class="hljs-keyword">return</span> x-&gt;key;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">getValByRank</span>(x-&gt;r, rank - (x-&gt;l ? x-&gt;l-&gt;size : <span class="hljs-number">0</span>) - x-&gt;cnt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRankByVal</span><span class="hljs-params">(pitem&amp; x, <span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!x) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (v == x-&gt;key) <span class="hljs-keyword">return</span> (x-&gt;l ? x-&gt;l-&gt;size : <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (v &lt; x-&gt;key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">getRankByVal</span>(x-&gt;l, v);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">getRankByVal</span>(x-&gt;r, v) + (x-&gt;l ? x-&gt;l-&gt;size : <span class="hljs-number">0</span>) + x-&gt;cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">item</span>(<span class="hljs-number">1e9</span>), root-&gt;r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">item</span>(<span class="hljs-number">-1e9</span>);<br><span class="hljs-type">int</span> n; std::cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n --) &#123;<br><span class="hljs-type">int</span> op, x;<br>std::cin &gt;&gt; op &gt;&gt; x;<br><span class="hljs-keyword">switch</span> (op) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-built_in">insert</span>(root, x);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-built_in">remove</span>(root, x);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>std::cout &lt;&lt; <span class="hljs-built_in">getRankByVal</span>(root, x) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>std::cout &lt;&lt; <span class="hljs-built_in">getValByRank</span>(root, x) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>std::cout &lt;&lt; <span class="hljs-built_in">getPre</span>(x)-&gt;key &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>std::cout &lt;&lt; <span class="hljs-built_in">getNxt</span>(x)-&gt;key &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>双倍腹肌量 解题报告</title>
    <link href="/COGS-%E5%8F%8C%E5%80%8D%E8%85%B9%E8%82%8C%E9%87%8F-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/COGS-%E5%8F%8C%E5%80%8D%E8%85%B9%E8%82%8C%E9%87%8F-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<p>比赛时竟然调试了半天的分块，到最后都没做对，属实是丢大人了。在比赛的过程中见识到了很多大佬的牛逼算法，这里做一个总结。</p><span id="more"></span><h3 id="分块-做法">分块 做法</h3><p>这一题跟磁力块那一题有些相像，可以用分块做，一开始觉得用分块时间复杂度可能比较高（当时还准备放弃写树套树，幸亏我太蒻了没学过树套树，要不然掉进坑里了），但是实际好像相当快？<br />对于每个块用 <span class="math inline">\(y\)</span> 值排序，内部用 <spanclass="math inline">\(x\)</span>值排序，对于每一个点，二分找到满足条件（即 <spanclass="math inline">\(y\)</span> 坐标和该点的 <spanclass="math inline">\(y\)</span> 坐标的差 <spanclass="math inline">\(\ge m\)</span>）的最小的块（预先保存每个块的最小<span class="math inline">\(y\)</span>值），由于预先排序保证了这个块之后的块也都满足条件，然后再在这些块内部二分找到<span class="math inline">\(x\)</span>坐标的前驱和后继，更新答案，然后对于最左的块的左边一个块，朴素枚举，更新答案。</p><p>对于每一个点的查询操作，时间复杂度为 <spanclass="math inline">\(O(\sqrt n \log n)\)</span><br />故总时间复杂度为 <span class="math inline">\(O(n \sqrt n \logn)\)</span><br />当然，这样的时间复杂度还是很高，但是还有很多优秀的算法：</p><h3 id="rmq-做法">RMQ 做法</h3><p>譬如 skylake 大佬的算法：通过维护 <spanclass="math inline">\(y\)</span>坐标的区间最值，然后用尺取法，保证两个最值的差 <spanclass="math inline">\(\gem\)</span>，然后更新答案。这个算法实在是太优秀了，并且代码写出来即为简洁，好像是大佬开始比赛十分钟秒掉的？简直叹为观止orzorz%%%%%%%%，我还没有学过RMQ，可能不是很了解，不过据推测这个时间复杂度是 <spanclass="math inline">\(O(n \log n +n)\)</span>？果然犇人写犇算法，直接比我的算法快一个数量级（虽然可能这一题数据太水，我的代码反而快了大雾）。</p><h3 id="二叉堆-做法">二叉堆 做法</h3><p>再譬如 关神犇 提出的算法：维护两个二叉堆，堆内以 <spanclass="math inline">\(y\)</span> 坐标为关键字，并且在堆外以 <spanclass="math inline">\(x\)</span>为关键字排序。每次枚举一个点就取出两个堆中满足条件的点，更新答案，然后弹出这些数（因为已经以<span class="math inline">\(x\)</span>为关键字排序，所以在当前点之后的点不会离这些点更近，即这些点对于答案已经没有贡献了），之后把该点存入堆内。这个算法实在是太神了（关神犇您是我的神orzorzorz%%%%%%%%%%%%%%%），因为只进行了<span class="math inline">\(2n\)</span> 次插入和 <spanclass="math inline">\(n\)</span> 次删除操作，每个操作的时间复杂度是<span class="math inline">\(\log n\)</span>，所以总时间复杂度为 <spanclass="math inline">\(O(n \logn)\)</span>。看这道题的标签里有优先队列，也许正解就是这个，为此再次膜拜神犇叹为观止的做题直觉orzorz。</p><p>当然，除此之外，还有用线段树维护区间最值的神犇的方法，具体思路和skylake 大佬的大同小异，不过线段树实现代码更加冗长，这里不再赘述。</p><h3 id="代码实现">代码实现</h3><p>俗话说 <em>Talk is cheap, show me thecode</em>，这里就不再多说废话，直接给出上述各类算法的代码实现</p><h4 id="分块-实现">分块 实现</h4><p>需要注意的是，这一题的分块算法虽然并不难，代码实现也不是很长，但是听懂了不等于能做出来，一些代码实现上的细节需要注意<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> PII = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(PII a, PII b)</span> </span>&#123; <span class="hljs-keyword">return</span> a.x &lt; b.x; &#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, T = <span class="hljs-number">320</span>;<br><span class="hljs-type">int</span> n, m, t, ans = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> pos[N], L[T], R[T], M[T];<br>PII a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin &gt;&gt; n &gt;&gt; m, t = std::<span class="hljs-built_in">sqrt</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-type">int</span> x, y; std::cin &gt;&gt; x &gt;&gt; y;<br>        a[i] = &#123;x, y&#125;;<br>    &#125;<br>    std::<span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n, [](PII a, PII b) &#123;<br>        <span class="hljs-keyword">return</span> a.y &lt; b.y;<br>    &#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= t; ++ i) <br>        L[i] = (i - <span class="hljs-number">1</span>) * t + <span class="hljs-number">1</span>, R[i] = i * t,<br>        std::<span class="hljs-built_in">sort</span>(a + L[i], a + R[i] + <span class="hljs-number">1</span>, cmp);<br>    <span class="hljs-keyword">if</span> (R[t] &lt; n) <br>        L[t + <span class="hljs-number">1</span>] = R[t] + <span class="hljs-number">1</span>, R[++ t] = n,<br>        std::<span class="hljs-built_in">sort</span>(a + L[t], a + R[t] + <span class="hljs-number">1</span>, cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= t; ++ i) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = L[i]; j &lt;= R[i]; ++ j) <br>            pos[j] = i,<br>            M[i] = (M[i] == <span class="hljs-number">0</span>) ? a[j].y : std::<span class="hljs-built_in">min</span>(M[i], a[j].y);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-type">int</span> k = std::<span class="hljs-built_in">upper_bound</span>(M + <span class="hljs-number">1</span>, M + <span class="hljs-number">1</span> + t, a[i].y + m) - M;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = k; j &lt;= t; ++ j) &#123;<br>            <span class="hljs-type">int</span> x = std::<span class="hljs-built_in">upper_bound</span>(a + L[j], a + R[j], a[i]) - a;<br>            <span class="hljs-type">int</span> y = std::<span class="hljs-built_in">lower_bound</span>(a + L[j], a + R[j], a[i]) - a;<br>            x = std::<span class="hljs-built_in">abs</span>(a[x].x - a[i].x);<br>            y = std::<span class="hljs-built_in">abs</span>(a[y].x - a[i].x);<br>            ans = std::<span class="hljs-built_in">min</span>(&#123;ans, x, y&#125;);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = L[k - <span class="hljs-number">1</span>]; j &lt;= R[k - <span class="hljs-number">1</span>]; ++ j)<br>            <span class="hljs-keyword">if</span> (a[i].y + m &lt; a[j].y)<br>                ans = std::<span class="hljs-built_in">min</span>(ans, std::<span class="hljs-built_in">abs</span>(a[i].x - a[j].x));<br>    &#125;<br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure></p><h4 id="rmq-实现">RMQ 实现</h4><p>我本人对于 RMQ 的理解并不深，这里主要参考 skylake 神犇的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> PII = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, m, l = <span class="hljs-number">1</span>, ans = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">20</span>], g[N][<span class="hljs-number">20</span>], lg[N];<br>PII a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> k = lg[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">max</span>(f[l][k], f[r - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Min</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> k = lg[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">min</span>(g[l][k], g[r - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <br>        std::cin &gt;&gt; a[i].x &gt;&gt; a[i].y;<br>    std::<span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>        f[i][<span class="hljs-number">0</span>] = g[i][<span class="hljs-number">0</span>] = a[i].y;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) lg[i] = lg[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; k) &lt;= n; ++ k) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; k) - <span class="hljs-number">1</span> &lt;= n; ++ i)<br>            f[i][k] = std::<span class="hljs-built_in">max</span>(f[i][k - <span class="hljs-number">1</span>], f[i + (<span class="hljs-number">1</span> &lt;&lt; k - <span class="hljs-number">1</span>)][k - <span class="hljs-number">1</span>]),<br>            g[i][k] = std::<span class="hljs-built_in">min</span>(g[i][k - <span class="hljs-number">1</span>], g[i + (<span class="hljs-number">1</span> &lt;&lt; k - <span class="hljs-number">1</span>)][k - <span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">while</span> (l &lt; i &amp;&amp; <span class="hljs-built_in">Max</span>(l + <span class="hljs-number">1</span>, i) - <span class="hljs-built_in">Min</span>(l + <span class="hljs-number">1</span>, i) &gt;= m) ++ l;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Max</span>(l, i) - <span class="hljs-built_in">Min</span>(l, i) &gt;= m) ans = std::<span class="hljs-built_in">min</span>(ans, a[i].x - a[l].x);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ans &gt; <span class="hljs-number">1e9</span> / <span class="hljs-number">2</span>) ans = <span class="hljs-number">-1</span>;<br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉堆-实现">二叉堆 实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> PII = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, m, ans = <span class="hljs-number">1e9</span>;<br>PII a[N];<br>std::priority_queue&lt;PII&gt; f, g;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <br>        std::cin &gt;&gt; a[i].x &gt;&gt; a[i].y;<br>    std::<span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">while</span> (f.<span class="hljs-built_in">size</span>() &amp;&amp; f.<span class="hljs-built_in">top</span>().x - a[i].y &gt;= m) <br>            ans = std::<span class="hljs-built_in">min</span>(ans, a[i].x - f.<span class="hljs-built_in">top</span>().y), f.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">while</span> (g.<span class="hljs-built_in">size</span>() &amp;&amp; g.<span class="hljs-built_in">top</span>().x + a[i].y &gt;= m) <br>            ans = std::<span class="hljs-built_in">min</span>(ans, a[i].x - g.<span class="hljs-built_in">top</span>().y), g.<span class="hljs-built_in">pop</span>();<br>        f.<span class="hljs-built_in">push</span>(&#123;  a[i].y, a[i].x &#125;);<br>        g.<span class="hljs-built_in">push</span>(&#123; -a[i].y, a[i].x &#125;);<br>    &#125;<br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>分块</tag>
      
      <tag>RMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>括号序列 解题报告</title>
    <link href="/COGS-%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/COGS-%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<p>临近CSP才发现暑假已经过去有一段时间了，方才发觉整个暑假都在摆烂。。。甚至这道去年的CSP题，暑假集训也出了这题，到现在才做真题也是惭愧。<span id="more"></span></p><p>这一题从思维难度上来说并不难，各种方面来说说是区间dp模板题好像也不为过。我觉得难度比较高的部分在于细节上，要把所有的情况考虑到，代码细节上的一些问题也比较麻烦。</p><h4 id="分析">分析</h4><p>考虑一个合法的括号序列长什么样子：<code>(...)</code>，即由外面的括号和里面的部分组成，有用的信息来自于内部，于是我们关注内部可以由什么组成：</p><p>根据定义，一个合法的括号序列，内部可以是：<code>S</code>、<code>AA</code>、<code>ASA</code>、<code>A</code>、<code>AS</code>、<code>SA</code>，其中，<code>AA</code>和 <code>ASA</code> 比较特殊，因为它们本身就是一个<code>A</code>，信息被包含在 <code>A</code> 中。于是得到一个公式： <spanclass="math display">\[A_{i, j} = A_{i + 1, j - 1} + S_{i + 1, j - 1} + AS_{i + 1, j - 1} +SA_{i + 1, j - 1} \notag\]</span></p><p>接下来，我们考虑这些部分的信息如何维护：</p><ol type="1"><li>对于<code>A</code>：我们若将这个递推公式深究到底，会得到什么？什么情况下就递归不下去了？也许最后的<code>A</code> 是一个<code>()</code>，这当然合法，并且这个信息无法从别处递推来，于是，对于这个，我们在遇到的时候需要统计一下。或者，<code>(S)</code>也是一个合法的括号序列，再往下深究，就是一个 <code>S</code>，就是说，如果 <code>(S)</code> 放到上面的公式中，最后会得到一个<code>S</code> 的值，显然这个值得是 <spanclass="math inline">\(1\)</span>。</li><li>对于 <code>S</code>：经过上面的讨论，<spanclass="math inline">\(\forall i, j \in \mathbb{N^+}, S_{i, j} =1\)</span> 而这个等式成立的前提是 <span class="math inline">\(i,j\)</span> 中间的部分完全由 <code>'*'</code> 组成</li></ol><p>对于<code>AS</code>，<code>SA</code>，<code>ASA</code>，<code>AA</code>这些由 <code>A</code> 和 <code>S</code>这两个比较基本的部分组成的部分，我们用乘法原理，可以求出它们的值。即：<br /><span class="math display">\[AS_{i, j} = \sum_{i \le k \le j}A_{i, k} \times S_{k + 1, j} \notag\]</span></p><p><span class="math display">\[SA_{i, j} = \sum_{i \le k \le j}S_{i, k} \times A_{k + 1, j} \notag\]</span></p><p><span class="math display">\[ASA_{i, j} = \sum_{i \le k \le j}A_{i, k} \times SA_{k + 1, j} \notag\]</span></p><p><span class="math display">\[AA_{i, j} = \sum_{i \le k \le j}A_{i, k} \times A_{k + 1, j} \notag\]</span></p><p>需要注意的是，如果我们将 <code>AA</code> 和 <code>ASA</code>的信息累加到 <code>A</code>中，会导致原来的信息被覆盖掉，导致出错，所以在程序实现中我们需要用一个数组来备份合并操作之前的信息。</p><p>到这里，这道题就算是解决了。</p><h4 id="实现代码">实现代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span> </span><br> <br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">5</span>, MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> c[N];<br>i64 a[M][N][N];<br><span class="hljs-comment">// 0:a  1:s  2:as  3:sa  4:bak</span><br> <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">eq</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">char</span> ch)</span> </span>&#123; <span class="hljs-keyword">return</span> c[idx] == ch || c[idx] == <span class="hljs-string">&#x27;?&#x27;</span>; &#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; c + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n &amp;&amp; j - i + <span class="hljs-number">1</span> &lt;= m; ++ j) <br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">eq</span>(j, <span class="hljs-string">&#x27;*&#x27;</span>)) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> a[<span class="hljs-number">1</span>][i][j] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; ++ len) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - len + <span class="hljs-number">1</span>; ++ i) &#123;<br>            <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">eq</span>(i, <span class="hljs-string">&#x27;(&#x27;</span>) &amp;&amp; <span class="hljs-built_in">eq</span>(j, <span class="hljs-string">&#x27;)&#x27;</span>)) &#123; <span class="hljs-comment">// (...)</span><br>                <span class="hljs-keyword">if</span> (len == <span class="hljs-number">2</span>) a[<span class="hljs-number">0</span>][i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> a[<span class="hljs-number">0</span>][i][j] = (a[<span class="hljs-number">0</span>][i][j] + a[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % MOD,<br>                     a[<span class="hljs-number">0</span>][i][j] = (a[<span class="hljs-number">0</span>][i][j] + a[<span class="hljs-number">1</span>][i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % MOD,<br>                     a[<span class="hljs-number">0</span>][i][j] = (a[<span class="hljs-number">0</span>][i][j] + a[<span class="hljs-number">2</span>][i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % MOD,<br>                     a[<span class="hljs-number">0</span>][i][j] = (a[<span class="hljs-number">0</span>][i][j] + a[<span class="hljs-number">3</span>][i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % MOD;<br>            &#125;<br>            a[<span class="hljs-number">4</span>][i][j] = a[<span class="hljs-number">0</span>][i][j];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt;= j; ++ k) <span class="hljs-comment">// merge</span><br>                a[<span class="hljs-number">0</span>][i][j] = (a[<span class="hljs-number">0</span>][i][j] + a[<span class="hljs-number">4</span>][i][k] * a[<span class="hljs-number">0</span>][k + <span class="hljs-number">1</span>][j]) % MOD, <span class="hljs-comment">// aa</span><br>                a[<span class="hljs-number">2</span>][i][j] = (a[<span class="hljs-number">2</span>][i][j] + a[<span class="hljs-number">0</span>][i][k] * a[<span class="hljs-number">1</span>][k + <span class="hljs-number">1</span>][j]) % MOD, <span class="hljs-comment">// as</span><br>                a[<span class="hljs-number">3</span>][i][j] = (a[<span class="hljs-number">3</span>][i][j] + a[<span class="hljs-number">1</span>][i][k] * a[<span class="hljs-number">0</span>][k + <span class="hljs-number">1</span>][j]) % MOD, <span class="hljs-comment">// sa</span><br>                a[<span class="hljs-number">0</span>][i][j] = (a[<span class="hljs-number">0</span>][i][j] + a[<span class="hljs-number">4</span>][i][k] * a[<span class="hljs-number">3</span>][k + <span class="hljs-number">1</span>][j]) % MOD; <span class="hljs-comment">// asa</span><br>        &#125;<br>    std::cout &lt;&lt; a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>区间dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round #813 (Div. 2) A-D 解题报告</title>
    <link href="/Codeforces-Round-813-Div-2-A-D-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/Codeforces-Round-813-Div-2-A-D-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<p>决定vp一场cf后都写一篇题解（不敢打比赛）。</p><h2 id="a.-wonderful-permutation">A. Wonderful Permutation</h2><p><strong>大致题意</strong>：给定一个 <strong>1~n</strong> 的排列 <spanclass="math inline">\(p_1, p_2, \dots, p_n\)</span> ，求出最小的整数<span class="math inline">\(t\)</span> ，使得通过 <spanclass="math inline">\(t\)</span> 次交换操作，使得 <spanclass="math inline">\(p_1 + p_2 + \dots + p_k\)</span> 最小。</p><p><strong>分析</strong>：前 <span class="math inline">\(k\)</span>个数的和最小，那么这 <span class="math inline">\(k\)</span> 个数一定就是<strong>1~k</strong> 的这几个数，所以，把原来在前 <spanclass="math inline">\(k\)</span> 个数中 <strong>大于 <spanclass="math inline">\(k\)</span> 的数</strong> 移出去，把<strong>1~k</strong> 的数移进来，顺序不重要，所以只需要统计前 <spanclass="math inline">\(k\)</span> 个数中大于 <spanclass="math inline">\(k\)</span> 的数就行了。</p><p><strong>代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, k, ans = <span class="hljs-number">0</span>;<br>std::cin &gt;&gt; n &gt;&gt; k;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) std::cin &gt;&gt; a[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++ i) ans += a[i] &gt; k;<br>std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="b.-woeful-permutation">B. Woeful Permutation</h2><p><strong>大致题意</strong>：找到一个 <strong>1~n</strong> 的排列 <spanclass="math inline">\(p_1, p_2, \dots, p_n\)</span> ，使得 <spanclass="math inline">\(\operatorname{lcm}(1, p_1) + \operatorname{lcm}(2,p_2) + \dots + \operatorname{lcm}(n, p_n)\)</span> 最大。</p><p><strong>分析</strong>：注意到，<spanclass="math inline">\(\operatorname{lcm}(a, b) = \frac{ab}{\gcd(a,b)}\)</span>，由于相邻两个自然数的最大公因数是 <spanclass="math inline">\(1\)</span>，最小公倍数为这两个自然数的乘积，因此构造一个排列使 <spanclass="math inline">\(\mid p_k - k \mid =1\)</span>，就可以使公倍数和最大。</p><p><strong>代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>std::cin &gt;&gt; n;<br><span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>    std::cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i += <span class="hljs-number">2</span>) <br>        std::cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i += <span class="hljs-number">2</span>) <br>        std::cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br>std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="c.-sort-zero">C. Sort Zero</h2><p><strong>大致题意</strong>：给定一个序列 <spanclass="math inline">\(a_1, a_2, \dots,a_n\)</span>，通过最少的操作次数，使得序列非单调递减。对于每一次操作，你可以选择一个整数<span class="math inline">\(x\)</span> ，使得序列中所有值为 <spanclass="math inline">\(x\)</span> 的数为 <spanclass="math inline">\(0\)</span>。</p><p><strong>分析</strong>：将序列最后的单调递增序列(该序列中的数在之前未出现)之前的数删完，用一个set 统计前面删的数的个数就行。</p><p><strong>代码</strong>：</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>std::cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) mx[i] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) std::cin &gt;&gt; a[i], mx[a[i]] = i;<br>sorted[n] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i; -- i) <br>    sorted[i] = sorted[i + <span class="hljs-number">1</span>] &amp;&amp; a[i] &lt;= a[i + <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, mxp = <span class="hljs-number">0</span>;<br>std::set&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(a[i])) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (mxp &lt; i &amp;&amp; sorted[i]) <span class="hljs-keyword">break</span>;<br>    s.<span class="hljs-built_in">insert</span>(a[i]);<br>    ++ res;<br>    mxp = std::<span class="hljs-built_in">max</span>(mxp, mx[a[i]]);<br>&#125;<br>std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure></p><h2 id="d.-empty-graph">D. Empty Graph</h2><p><strong>大致题意</strong>：给定一个序列 <spanclass="math inline">\(a_1, a_2, \dots, a_n\)</span> ，进行最多 <spanclass="math inline">\(k\)</span>次赋值操作，然后构造一个无向带权完全图，任意一对节点 <spanclass="math inline">\((l, r)\)</span> 的边权为 <spanclass="math inline">\(\displaystyle \min_{l \le i \le r}(a_i)\)</span>，求出最小直径。</p><p><strong>分析</strong>：</p><p>首先，容易想到两点间最短路径一定是 <span class="math inline">\(w(l,r)\)</span> 或 <span class="math inline">\(2 \cdot \displaystyle \min_{1\le i \le n}(a_i)\)</span> ，不难证明：</p><p>若存在第三点，如果它在两点之间，那么这条路径的长度一定 <spanclass="math inline">\(\ge 2w(l, r)\)</span>，因为 <spanclass="math inline">\(w(l, r) = \displaystyle \min_{l \le i \le r}(a_i)\)</span>，所以在这种情况下两点间最短路径一定只包含一条这两点夹边。而如果它在两点之外，那么最短的路径莫过于经过一个点<span class="math inline">\(\displaystyle \min_{1 \le i \len}(a_i)\)</span> 了，在这种情况下，最短路径为 <spanclass="math inline">\(2 \cdot \displaystyle \min_{1 \le i \len}(a_i)\)</span>。</p><p>因此，<span class="math inline">\(\displaystyle d(l, r) = \min(w(l,r), 2 \cdot \min_{l \le i \le r}(a_i))\)</span>。</p><p>于是，图的直径就等于 <span class="math inline">\(\displaystyle\max(\max_{0 &lt; i &lt; n}\min(a_i, a_{i + 1}), 2 \cdot \min_{l \le i\le r}(a_i))\)</span>，这个结论很容易得到，证明就略过了。</p><p>我们二分答案查找最大直径，假设当前的答案为 <spanclass="math inline">\(ans\)</span>，我们维护一个前缀数组和一个后缀数组，保存有多少个值<span class="math inline">\(&lt; \lfloor \frac{ans + 1}{2}\rfloor\)</span>，然后枚举序列，看是否存在前缀和后缀不满足答案的数的个数加上 <span class="math inline">\((a_i,a_{i + 1})\)</span> 中不满足答案的个数 <span class="math inline">\(&lt;k\)</span>。</p><p><strong>代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, k;<br>std::cin &gt;&gt; n &gt;&gt; k;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <br>    std::cin &gt;&gt; a[i];<br><span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> ans) &#123;<br>    <span class="hljs-type">int</span> t = (ans + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s1</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span>, <span class="hljs-title">s2</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>        s1[i] = s1[i - <span class="hljs-number">1</span>] + (a[i] &lt; t);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; -- i)<br>        s2[i] = s2[i + <span class="hljs-number">1</span>] + (a[i] &lt; t);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i) <br>        <span class="hljs-keyword">if</span> (s1[i - <span class="hljs-number">1</span>] + s2[i + <span class="hljs-number">2</span>] + (a[i] &lt; ans) + (a[i + <span class="hljs-number">1</span>] &lt; ans) &lt;= k)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br><span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>    <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br>std::cout &lt;&lt; r &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>二分答案</tag>
      
      <tag>思维</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小Z的袜子 解题报告</title>
    <link href="/%E5%B0%8Fz%E7%9A%84%E8%A2%9C%E5%AD%90-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/%E5%B0%8Fz%E7%9A%84%E8%A2%9C%E5%AD%90-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<p>学习一下莫队算法。<br /><span id="more"></span> <span class="math display">\[\begin{aligned}ans &amp;= \frac{\binom{num_l}{2} + \binom{num_{l + 1}}{2} + \dots +\binom{num_r}{2}}{\binom{r - l + 1}{2}} \\\\&amp;= \frac{num_l(num_l - 1) + num_{l + 1}(num_{l + 1} - 1) + \dots +num_r(num_r - 1)}{(r - l + 1)(r - l)} \\\\&amp;= \frac{(num_l^2 + num_{l + 1}^2 + \dots + num_r^2) - (num_l +num_{l + 1} + \dots + num_r)}{(r - l + 1)(r - l)} \\\\&amp;= \frac{(num_l^2 + num_{l + 1}^2 + \dots + num_r^2) - (r - l +1)}{(r - l + 1)(r - l)}\end{aligned}\]</span></p><p>而</p><p>$ (n + 1)^2 = n^2 + 1 + 2n \ (n - 1)^2 = n^2 + 1 - 2n $</p><p>所以对于每一个询问 <span class="math inline">\([l,r]\)</span>，我们只需要将当前询问的分子加上 <spanclass="math inline">\(2n + 1\)</span> 即可 <spanclass="math inline">\(O(1)\)</span> 地将答案扩展至 <spanclass="math inline">\([l, r + 1]\)</span> 或 <spanclass="math inline">\([l - 1,r]\)</span>，而对于缩小区间的操作，同理。</p><p>于是，我们可以用 <span class="math inline">\(\mid l&#39; - l \mid +\mid r&#39; - r \mid\)</span> 次操作转移至下一询问区间。</p><p>而利用分块，将所处分块作为第一关键字，将右区间作为第二关键字，可以实现<span class="math inline">\(O(n \sqrt n)\)</span> 的时间复杂度。</p><p><strong>实现代码</strong><br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-type">int</span> l, r, idx;<br>i64 p, q;<br>&#125;;<br> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50010</span>;<br><span class="hljs-type">int</span> a[N], b[N], cnt[N];<br>i64 ans;<br>Node query[N];<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n, m, t;<br>std::cin &gt;&gt; n &gt;&gt; m;<br>t = std::<span class="hljs-built_in">sqrt</span>(n);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>std::cin &gt;&gt; a[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br><span class="hljs-keyword">auto</span>&amp; [l, r, idx, p, q] = query[i];<br>std::cin &gt;&gt; l &gt;&gt; r, idx = i;<br>b[i] = (i - <span class="hljs-number">1</span>) / t + <span class="hljs-number">1</span>;<br>&#125;<br>std::<span class="hljs-built_in">sort</span>(query + <span class="hljs-number">1</span>, query + <span class="hljs-number">1</span> + m, [](Node x, Node y) &#123;<br><span class="hljs-keyword">return</span> b[x.l] == b[y.l] ? x.r &lt; y.r : x.l &lt; y.l;<br>&#125;);<br><span class="hljs-type">int</span> ll = <span class="hljs-number">1</span>, rr = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br><span class="hljs-keyword">auto</span>&amp; [l, r, idx, p, q] = query[i];<br><span class="hljs-keyword">auto</span> del = [&amp;](<span class="hljs-type">int</span> x) &#123; ans += <span class="hljs-number">1</span> - cnt[x] * <span class="hljs-number">2</span>, -- cnt[x]; &#125;;<br><span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> x) &#123; ans += <span class="hljs-number">1</span> + cnt[x] * <span class="hljs-number">2</span>, ++ cnt[x]; &#125;;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br>p = <span class="hljs-number">0</span>, q = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">while</span> (ll &lt; l) <span class="hljs-built_in">del</span>(a[ll ++]);<br><span class="hljs-keyword">while</span> (ll &gt; l) <span class="hljs-built_in">add</span>(a[-- ll]);<br><span class="hljs-keyword">while</span> (rr &lt; r) <span class="hljs-built_in">add</span>(a[++ rr]);<br><span class="hljs-keyword">while</span> (rr &gt; r) <span class="hljs-built_in">del</span>(a[rr --]);<br>p = ans - (r - l + <span class="hljs-number">1</span>), q = <span class="hljs-number">1LL</span> * (r - l + <span class="hljs-number">1</span>) * (r - l);<br><span class="hljs-type">int</span> d = std::__gcd(p, q);<br>p /= d, q /= d;<br>&#125;<br>&#125;<br>std::<span class="hljs-built_in">sort</span>(query + <span class="hljs-number">1</span>, query + <span class="hljs-number">1</span> + m, [](Node a, Node b) &#123;<br><span class="hljs-keyword">return</span> a.idx &lt; b.idx;<br>&#125;);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i)<br>std::cout &lt;&lt; query[i].p &lt;&lt; <span class="hljs-string">&#x27;/&#x27;</span> &lt;&lt; query[i].q &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>分块</tag>
      
      <tag>莫队</tag>
      
      <tag>数据结构</tag>
      
      <tag>区间算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 PasteMe 部署一个属于你自己的云剪贴板！</title>
    <link href="/PasteMe/"/>
    <url>/PasteMe/</url>
    
    <content type="html"><![CDATA[<p>前不久买了一个 vps用来搭建各种奇奇怪怪的服务，发现和神犇们交流的时候不可避免地会需要发送代码片段，但是直接用QQ把文本发出去的话会被自动转义成表情，洛谷的云剪贴板又需要登录，所以我突发奇想，打算搭建一个自己的云剪贴板服务。</p><span id="more"></span><h2 id="介绍">介绍</h2><p>发送文本片段的服务有很多：<ahref="https://pastebin.ubuntu.com/">Ubuntu Pastebin</a>，<ahref="https://www.luogu.com.cn/">Luogu</a>，<ahref="https://airportal.cn/">Airportal</a>，<ahref="https://privatebin.net/">PrivateBin</a>，<ahref="https://pasteme.cn/#/">PasteMe</a> ......</p><p>其中开源的有 <strong>PrivateBin</strong> 和<strong>PasteMe</strong>，其中我觉得 <strong>PasteMe</strong>的界面更为美观，功能相比来说也多一点。</p><p><img src="https://cdn.jsdelivr.net/gh/lihaoze123/pic/image-20220731152616082.png" alt="image-20220731152616082" style="zoom: 33%;" /></p><p>它是一个前后端分离的项目，所以纯手动安装可能有一点麻烦，如果想方便一点的话可以直接<a href="https://docs.pasteme.cn/#/deploy/docker">用<strong>docker</strong>一键部署</a>，不过最新版不能永久保存文本，底下影响美观的推广也不能去掉，所以想自定义的话可以选择手动安装。</p><p><img src="https://cdn.jsdelivr.net/gh/lihaoze123/pic/image-20220731154104373.png" alt="image-20220731154104373" style="zoom: 50%;" /></p><h2 id="部署">部署</h2><p>手动部署需要用到 <strong>Nginx</strong> 和<strong>MySQL</strong>，配置起来对新手可能不是很友好，可以选择<strong><a href="https://www.bt.cn/new/index.html">宝塔面板</a></strong>来一键安装 <strong>LNMP</strong>。</p><p>由于新版本的程序不一定向后兼容，版本选择上我踩了很多坑，目测前端和后端选择v3.2.1 能够完全兼容。</p><h3 id="部署前端">部署前端</h3><p>熟悉前端的大佬可以直接根据 <ahref="https://github.com/PasteUs/PasteMeFrontend/tree/release-v3.2.1">源码</a>自定义，也可以选择我去掉了推广之后编译好的 <ahref="https://github.com/lihaoze123/PasteMeFrontend/releases/tag/v3.2.1-modify">版本</a>。</p><p>用 <strong>宝塔面板</strong> 安装过 <strong>LNMP</strong>之后，就可以部署站点了。</p><p>首先，用 <strong>ssh</strong>工具连接到我们的服务器，然后依次运行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /www/wwwroot<br>$ wget https://github.com/lihaoze123/PasteMeFrontend/releases/download/v3.2.1-modify/pasteme.tar.gz<br>$ tar -xvzf pasteme.tar.gz<br></code></pre></td></tr></table></figure><p>然后进入 <code>pasteme</code> 文件夹，将 <code>usr</code> 文件夹下的<code>config.example.json</code> 文件重命名为<code>config.json</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /www/wwwroot/pasteme/usr<br>$ <span class="hljs-built_in">mv</span> config.example.json config.json<br></code></pre></td></tr></table></figure><p>想要自定义底部显示文本的可以修改 <code>config.json</code>文件，以添加一个我的个人网站为例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;api&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/api/&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;adminApi&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;footer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://www.chumeng.me&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Chumeng&#x27;s Blog&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后，我们用 <strong>宝塔面板</strong> 添加站点：</p><p><img src="https://cdn.jsdelivr.net/gh/lihaoze123/pic/image-20220731160651272.png" alt="image-20220731160651272" style="zoom:50%;" /></p><p>记住数据库账号和密码，之后部署后端的时候会用到。</p><p>之后，点击 <strong>设置 - 配置文件</strong>，在适当位置添加以下代码：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> REMOTE-HOST <span class="hljs-variable">$remote_addr</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>    <span class="hljs-attribute">proxy_pass</span> http://localhost:8000/;  <span class="hljs-comment"># 端口号可以自定义</span><br>&#125;<br><br><span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，前端部分就部署完了（其实也没有多难嘛，大雾</p><h3 id="部署后端">部署后端</h3><p>首先，下载编译好的二进制文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /usr/local<br>$ wget https://github.com/PasteUs/PasteMeGoBackend/releases/download/release-v3.2.1/pastemed-linux-amd64.tar.gz<br>$ tar -xvzf pastemed-linux-amd64.tar.gz<br>$ <span class="hljs-built_in">cd</span> pastemed-linux-amd64<br></code></pre></td></tr></table></figure><p>然后，将 <code>config.example.json</code> 文件重命名为<code>config.json</code> 并修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;port&quot;</span>: 8000,<br>  <span class="hljs-string">&quot;database&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;mysql&quot;</span>,<br>    <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;username&quot;</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;password&quot;</span>,<br>    <span class="hljs-string">&quot;server&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>    <span class="hljs-string">&quot;port&quot;</span>: 3306,<br>    <span class="hljs-string">&quot;database&quot;</span>: <span class="hljs-string">&quot;pasteme&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>database</code>，<code>username</code>，<code>password</code>修改为刚才增加站点时的数据库名，用户名和密码</p><p>接下来，在 <code>/etc/systemd/system</code> 目录下创建<code>pastemed.service</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /etc/systemd/system<br>$ <span class="hljs-built_in">touch</span> pastemed.service<br></code></pre></td></tr></table></figure><p>将 <code>pastemed.service</code> 修改为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=PasteMe API Server Service<br><span class="hljs-attr">After</span>=network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=simple<br><span class="hljs-attr">User</span>=nobody<br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<br><span class="hljs-attr">RestartSec</span>=<span class="hljs-number">5</span>s<br><span class="hljs-attr">ExecStart</span>=/usr/local/pastemed-linux-amd64/pastemed -c /usr/local/pastemed-linux-amd64/config.json<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><p>然后，将 <code>pastemed</code> 设置为开机自启并开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ systemctl <span class="hljs-built_in">enable</span> pastemed --now<br></code></pre></td></tr></table></figure><p>输入 <code>systemctl status pastemed</code>，若显示<code>running</code>，则表示配置完毕。</p><p>接下来，在 <strong>宝塔面板</strong>将上面涉及到的端口放行，并且设置好<strong>DNS解析</strong>，输入你的域名，就可以正常使用了！</p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
      <category>网站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级二维树状数组 总结</title>
    <link href="/%E9%AB%98%E7%BA%A7%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E6%80%BB%E7%BB%93/"/>
    <url>/%E9%AB%98%E7%BA%A7%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>做 <strong>移动电话</strong>这题的时候发现二维相关的数据结构不是很擅长，所以学习一下二维树状数组。</p><span id="more"></span><p><ahref="http://172.30.1.3/cogs/problem/problem.php?pid=vzQxNkgjV">COGS1532 移动电话</a></p><p>这一题其实就是 <strong>二维树状数组</strong>的模板题，需要实现一个支持 <strong>单点修改 &amp; 区间查询</strong>的树状数组。实现代码和普通的 <strong>一维树状数组</strong>相似，在这里不再放出具体解题代码，可以在 <ahref="http://www.luogu.com.cn/paste/2fno6xgm">这里</a> 查看。</p><p>以下是一些常见类型的 <strong>二维树状数组</strong> 实现。</p><ol type="1"><li><p><strong>单点修改 &amp; 区间查询</strong> 的二维树状数组</p><p>这种类型的二维树状数组是最简单的类型，这里假设已经掌握一维树状数组，一些基本的概念这里不再探讨，以下是实现代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 注意循环中创建一个临时变量来代替 y，因为 y 不能被修改。这种错误往往难以发现。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= s; i += <span class="hljs-built_in">lowbit</span>(i)) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = y; j &lt;= s; j += <span class="hljs-built_in">lowbit</span>(j)) <br>            c[i][j] += v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i)) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = y; j; j -= <span class="hljs-built_in">lowbit</span>(j)) <br>            t += c[i][j]; <br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于查询操作，可以使用 <strong>容斥原理</strong>来查询。关于容斥原理，可以参考 <ahref="http://zh.wikipedia.org/wiki/%E6%8E%92%E5%AE%B9%E5%8E%9F%E7%90%86">这里</a>。</p><p>具体可以参考上文的解题代码。</p></li><li><p><strong>区间修改 &amp; 单点查询</strong> 的二维树状数组</p><p>对于这种树状数组，我们不妨先思考 <strong>一维树状数组</strong>的做法：我们假设要使在数列 <span class="math inline">\(c\)</span> 内区间<span class="math inline">\([l, r]\)</span> 的所有数都加 <spanclass="math inline">\(v\)</span>，那么我们先创建一个差分数列 <spanclass="math inline">\(d\)</span>（差分序列的前缀和就是数列 <spanclass="math inline">\(c\)</span> 中单点的值）把 <spanclass="math inline">\(d_l\)</span> 加上 <spanclass="math inline">\(v\)</span>，然后使 <spanclass="math inline">\(d_{r + 1}\)</span> 减去 <spanclass="math inline">\(v\)</span>，用来抵消 <spanclass="math inline">\(d_l\)</span> 对 <spanclass="math inline">\(d_r\)</span>以后的数的影响。这样，每次修改的影响在 <spanclass="math inline">\(d_l\)</span> 处产生，然后在 <spanclass="math inline">\(d_{r + 1}\)</span>处消除，当我们要查询单点的值得时候，就可以直接用树状数组来求数列 <spanclass="math inline">\(d\)</span> 的前缀和。</p><p>对于 <strong>二维树状数组</strong>，也可以使用类似的方法，同样使用容斥原理，假设我们要修改的区间是二维数列<span class="math inline">\(c\)</span> 内区间 <spanclass="math inline">\((x_1, y_1) \ \text{to} \ (x_2, y_2) \quad x_2 \geqx_1, \ y_2 \geq y_1\)</span>，那么我们就可以同样创建一个二维的差分数列<span class="math inline">\(d\)</span>，在 <spanclass="math inline">\(d(x_1, y_1)\)</span> 处加上 <spanclass="math inline">\(v\)</span> ，然后在 <spanclass="math inline">\(d(x_1, y_2 + 1)\)</span> 和 <spanclass="math inline">\(d(x_2 + 1, y_1)\)</span>处抵消影响，最后把重复减去的部分 <span class="math inline">\(d(x_2 + 1,y_2 + 1)\)</span> 处加上 <spanclass="math inline">\(v\)</span>，这样，就实现了支持 区间修改 和单点查询 的二维树状数组。</p></li></ol><p>  关于这个形式的二维树状数组，在 <strong>POJ</strong> 上面有一道 <ahref="http://vjudge.net/problem/POJ-2155">不错的题</a>（或者做我在COGS上面<ahref="http://cogs.pro:8081/cogs/problem/problem.php?pid=vmNzzjePk">翻译的题</a>），可以来做一下。</p><p>关于这一题的解题代码，可以看 <ahref="http://www.luogu.com.cn/paste/7qqafzlc">这里</a>。</p><ol start="3" type="1"><li><p><strong>区间修改 &amp; 区间查询</strong> 的二维树状数组</p><p>在上一种二维树状数组中，我们维护了一个差分数列 <spanclass="math inline">\(d\)</span>，这个数列的前缀和 <spanclass="math inline">\(\displaystyle\sum_{i = 1}^x\sum_{j = 1}^yd(i,j)\)</span> 就是经过若干区间修改后 <span class="math inline">\(c(x,y)\)</span> 的值。那么我们求数列 <span class="math inline">\(c\)</span>的前缀和的公式就是 <span class="math display">\[\sum_{x = 1}^{x_1}\sum_{y = 1}^{y_1}\sum_{i = 1}^x\sum_{j = 1}^yd(i, j)\notag\]</span> 在这个公式中，<span class="math inline">\(d(1, ?)\)</span>被加了 <span class="math inline">\(x_1\)</span> 次，<spanclass="math inline">\(d(2, ?)\)</span> 被加了 <spanclass="math inline">\(x_1 - 1\)</span> 次，<spanclass="math inline">\(d(?, 1)\)</span> 被加了 <spanclass="math inline">\(y_1\)</span> 次， <span class="math inline">\(d(?,2)\)</span> 被加了 <span class="math inline">\(y_1 - 1\)</span> 次，于是<span class="math inline">\(d(x, y)\)</span> 被加了 <spanclass="math inline">\((x_1 - x + 1) \cdot (y_1 - y + 1)\)</span>次。因此上式可以改写为 <span class="math display">\[\begin{aligned}\sum_{x = 1}^{x_1}\sum_{y = 1}^{y_1}\sum_{i = 1}^x\sum_{j = 1}^yd(i, j)&amp;= \sum_{x = 1}^{x_1}\sum_{y = 1}^{y_1}(x_1 - x + 1) \cdot (y_1 - y+ 1) \cdot d(x, y) \\\\&amp;= (x_1 + 1)\sum_{x = 1}^{x_1}\sum_{y = 1}^{y_1}(y_1 - y + 1) \cdotd(x, y) - \sum_{x = 1}^{x_1}\sum_{y = 1}^{y_1}x \cdot (y_1 - y + 1)\cdot d(x, y) \\\\&amp;= (x_1 + 1) \cdot (y_1 + 1) \sum_{x = 1}^{x_1}\sum_{y =1}^{y_1}d(x, y) - (x_1 + 1)\sum_{x = 1}^{x_1}\sum_{y =1}^{y_1} y \cdotd(x, y) - \\\\&amp; \quad \ (y_1 + 1)\sum_{x = 1}^{x_1}\sum_{y = 1}^{y_1}x \cdot d(x,y) + \sum_{x = 1}^{x_1}\sum_{y = 1}^{y_1}x \cdot y \cdot d(x, y)\end{aligned} \notag\]</span> 然后，我们增加三个树状数组，分别维护 <spanclass="math inline">\(\displaystyle \sum_{x = 1}^{x_1}\sum_{y =1}^{y_1}x \cdot d(x, y)\)</span>，<spanclass="math inline">\(\displaystyle \sum_{x = 1}^{x_1}\sum_{y =1}^{y_1}y \cdot d(x, y)\)</span>，<spanclass="math inline">\(\displaystyle \sum_{x = 1}^{x_1}\sum_{y =1}^{y_1}x \cdot y \cdot d(x, y)\)</span> 。</p><p>至于查询操作，我们同样可以通过容斥原理来查询。</p><p>具体的实现代码可以看 <a href="http://loj.ac/s/1495473">这里</a>。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最优分解方案 解题报告</title>
    <link href="/cogs-%E6%9C%80%E4%BC%98%E5%88%86%E8%A7%A3%E6%96%B9%E6%A1%88-%E9%A2%98%E8%A7%A3/"/>
    <url>/cogs-%E6%9C%80%E4%BC%98%E5%88%86%E8%A7%A3%E6%96%B9%E6%A1%88-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>看到 skylake大佬的题解，发现这一题挺有意思，就做了做。这一题本来想了个挺麻烦的 <spanclass="math inline">\(O(n^3)\)</span>的算法，但是后来莫名其妙用滚动数组优化等步骤优化出来一个巨简单的 <spanclass="math inline">\(O(n^2)\)</span>算法(真的巨简单，不算高精的话只需要三行，简直比01背包还简单)，虽然不知道怎么解释，但是我这里可以把推导出来的过程给列出来。</p><span id="more"></span><h4 id="搜索做法">搜索做法</h4><p>首先，不难想出一个 <strong>dfs</strong> 的方案:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; chosen;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> last)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (now == n) &#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : chosen) res *= i;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">void</span>(mx = std::<span class="hljs-built_in">max</span>(mx, res));<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = last + <span class="hljs-number">1</span>; i &lt;= n - now; ++ i) &#123;<br>chosen.<span class="hljs-built_in">emplace_back</span>(i);<br><span class="hljs-built_in">dfs</span>(now + i, i);<br>chosen.<span class="hljs-built_in">pop_back</span>();<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="朴素-dp-做法">朴素 dp 做法</h4><p>时间复杂度过大，考虑使用动态规划，基于搜索算法，不难想出递推式: <spanclass="math display">\[f_{i, j} = \max_{k = 1}^{j - 1}(f_{i - j, k}) \times j\]</span> 其中 <span class="math inline">\(f_{i, j}\)</span>的值默认初始化为 <span class="math inline">\(j\)</span> 。</p><p><span class="math inline">\(f_{i, j}\)</span> 表示正整数为 <spanclass="math inline">\(i\)</span> 时, 选择的最后一个数是 <spanclass="math inline">\(j\)</span> 的方案的最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; ++ j) &#123;<br>        f[i][j] = j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt; j; ++ k) <br>            f[i][j] = std::<span class="hljs-built_in">max</span>(f[i][j], f[i - j][k] * j);<br>    &#125; <br></code></pre></td></tr></table></figure><h4 id="优化-dp-做法">优化 dp 做法</h4><p>注意到，第三层循环寻找最大值的过程，其实可以在 <spanclass="math inline">\(i - j\)</span>的那一层维护一个前缀最大值，用来代替循环，这里我们用 <spanclass="math inline">\(S_{i, j}\)</span> 维护前缀最大值的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; ++ j) &#123;<br>        f[i][j] = std::<span class="hljs-built_in">max</span>(j, s[i - j][j - <span class="hljs-number">1</span>] * j);<br>        s[i][j] = std::<span class="hljs-built_in">max</span>(s[i][j - <span class="hljs-number">1</span>], f[i][j]);<br>    &#125; <br></code></pre></td></tr></table></figure><p>然后发现，<span class="math inline">\(f_{i, j}\)</span>在这里没有用到任何之前保存的信息！只用一个 <spanclass="math inline">\(S\)</span> 数组就可以求出来解。我们用 <spanclass="math inline">\(f\)</span> 代替 <spanclass="math inline">\(S\)</span>，把原来的数组 <spanclass="math inline">\(f\)</span> 用一个变量来代替:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; ++ j) &#123;<br>        <span class="hljs-keyword">auto</span> res = std::<span class="hljs-built_in">max</span>(j, f[i - j][j - <span class="hljs-number">1</span>] * j);<br>        f[i][j] = std::<span class="hljs-built_in">max</span>(f[i][j - <span class="hljs-number">1</span>], res);<br>    &#125; <br></code></pre></td></tr></table></figure><p>调换一下变量名:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n; ++ j)<br>        f[i][j] = std::<span class="hljs-built_in">max</span>(&#123;i, f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j - i] * i&#125;);<br></code></pre></td></tr></table></figure><p>像极了01背包问题！我们用滚动数组优化一下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= i; -- j)<br>        f[j] = std::<span class="hljs-built_in">max</span>(&#123;i, f[j], f[j - i] * i&#125;);<br></code></pre></td></tr></table></figure><p>于是，最终的算法就出来了。</p><h4 id="完整代码">完整代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bigint</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        std::vector&lt;<span class="hljs-type">int</span>&gt; num;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Bigint</span> () &#123;&#125;<br>        <span class="hljs-built_in">Bigint</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* rst) &#123;<br>            <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(rst);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; -- i) num.<span class="hljs-built_in">emplace_back</span>(rst[i] - <span class="hljs-number">48</span>);<br>        &#125;<br>        <span class="hljs-built_in">Bigint</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> rst) &#123;<br>            <span class="hljs-type">char</span> tmp[<span class="hljs-number">100</span>];<br>            <span class="hljs-built_in">sprintf</span>(tmp, <span class="hljs-string">&quot;%d&quot;</span>, rst);<br>            *<span class="hljs-keyword">this</span> = tmp;<br>        &#125;<br>        Bigint <span class="hljs-keyword">operator</span> + (Bigint rst) &#123;<br>            Bigint ret;<br>            <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>) num.<span class="hljs-built_in">size</span>() || i &lt; (<span class="hljs-type">int</span>) rst.num.<span class="hljs-built_in">size</span>() || t; ++ i) &#123;<br>                <span class="hljs-keyword">if</span>(i &lt; (<span class="hljs-type">int</span>) num.<span class="hljs-built_in">size</span>()) t += num[i];<br>                <span class="hljs-keyword">if</span>(i &lt; (<span class="hljs-type">int</span>) rst.num.<span class="hljs-built_in">size</span>()) t += rst.num[i];<br>                ret.num.<span class="hljs-built_in">emplace_back</span>(t % <span class="hljs-number">10</span>);<br>                t /= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        Bigint <span class="hljs-keyword">operator</span> * (<span class="hljs-type">int</span> rst) &#123;<br>            Bigint ret;<br>            <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>) num.<span class="hljs-built_in">size</span>() || t; ++ i) &#123;<br>                <span class="hljs-keyword">if</span>(i &lt; (<span class="hljs-type">int</span>) num.<span class="hljs-built_in">size</span>()) t += num[i] * rst; <br>                ret.num.<span class="hljs-built_in">emplace_back</span>(t % <span class="hljs-number">10</span>);<br>                t /= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(ret.num.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; !ret.num.<span class="hljs-built_in">back</span>()) ret.num.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        Bigint <span class="hljs-keyword">operator</span> * (Bigint rst) &#123;<br>            Bigint ret;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = rst.num.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; -- i)<br>                ret = ret * <span class="hljs-number">10</span> + *<span class="hljs-keyword">this</span> * rst.num[i];<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (Bigint lst, Bigint rst) &#123;<br>            <span class="hljs-keyword">if</span>(lst.num.<span class="hljs-built_in">size</span>() &gt; rst.num.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(lst.num.<span class="hljs-built_in">size</span>() &lt; rst.num.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = lst.num.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; -- i) &#123;<br>                <span class="hljs-keyword">if</span>(lst.num[i] &lt; rst.num[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(lst.num[i] &gt; rst.num[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (std::ostream&amp; os, Bigint rst) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = rst.num.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; -- i) os &lt;&lt; rst.num[i];<br>            <span class="hljs-keyword">return</span> os;<br>        &#125;<br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n;<br>Bigint f[N];<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= i; -- j)<br>            f[j] = std::<span class="hljs-built_in">max</span>(&#123;<span class="hljs-built_in">Bigint</span>(i), f[j], f[j - i] * i&#125;);<br>    std::cout &lt;&lt; f[n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扩展欧几里得 &amp; 中国剩余定理 学习笔记</title>
    <link href="/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这部分的内容本来几个月前是已经学过了的，但是最近做这部分的题的时候发现有些知识点已经忘记了，所以决定复习一下，顺便写一下学习笔记。</p><span id="more"></span><p>​ 下文中 <span class="math inline">\((a, b)\)</span> 表示 <spanclass="math inline">\(\operatorname{gcd}(a, b)\)</span></p><h3 id="扩展欧几里得">扩展欧几里得</h3><h4 id="bézout-定理">Bézout 定理</h4><blockquote><p>设 <span class="math inline">\(a, b\)</span> 为不全为 <spanclass="math inline">\(0\)</span> 的整数，则存在整数 <spanclass="math inline">\(x, y\)</span>，使得 <span class="math inline">\(ax+ by = \gcd(a, b)\)</span>.</p></blockquote><h5 id="证明">证明</h5><ol type="1"><li>若 <span class="math inline">\(b = 0\)</span>，显然，有一对整数<span class="math inline">\(x = 1, y = 0\)</span>，使得 <spanclass="math inline">\(a \cdot 1 + 0 = (a, 0)\)</span>。<br /></li><li>若 <span class="math inline">\(b &gt; 0\)</span>，则由欧几里得算法，<span class="math inline">\((a, b) = (b, a \bmodb)\)</span>。<ol type="1"><li>假设存在一对整数 <span class="math inline">\(x&#39;,y&#39;\)</span>，使得 <span class="math inline">\(x&#39;b + y&#39;(a\bmod b) = (b, a \bmod b)\)</span>。<br /></li><li>由模运算的性质， <span class="math inline">\(a \bmod b = a - b\lfloor \frac{a}{b} \rfloor\)</span>，代入后整理上式，可得 <spanclass="math inline">\(y&#39;a + (x&#39; - y&#39; \lfloor \frac{a}{b}\rfloor)b = (b, a \bmod b) = (a, b)\)</span>。<br /></li><li>令 <span class="math inline">\(x = y&#39;, y = x&#39; - y&#39;\lfloor \frac{a}{b} \rfloor\)</span>，就有 <spanclass="math inline">\(ax + by = (a, b)\)</span>。</li></ol></li></ol><p>对于更一般的情况 <span class="math inline">\(ax + by =c\)</span>，该方程有解当且仅当 <span class="math inline">\((a, b) \midc\)</span>，当我们套用上面的方法求出一组特解 <spanclass="math inline">\(x&#39;, y&#39;\)</span> 之后，令 <spanclass="math inline">\(x&#39;, y&#39;\)</span> 同时乘以 <spanclass="math inline">\(\frac{c}{(a, b)}\)</span>后，就可以求出该方程的解了。</p><h4 id="实现">实现</h4><p>经过上面的证明，我们实际上找到了一种 <spanclass="math inline">\(O(log n)\)</span>的求解二元一次方程的算法，具体代码实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123; x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a; &#125;<br>    <span class="hljs-built_in">exgcd</span>(b, a % b, y, x); <span class="hljs-comment">//// 经过这一步后，y 就是上文中的 x&#x27;，x 就是上文中的 y&#x27;</span><br>    y -= x * (a / b);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="应用">应用</h4><p><strong>洛谷 P1516 <ahref="http://www.luogu.com.cn/problem/P1516">青蛙的约会</a></strong></p><blockquote><p>给定非负整数 <span class="math inline">\(x, y, m, n, L\)</span>。</p><p>求最小的非负整数 <span class="math inline">\(t\)</span>，使得 <spanclass="math inline">\(x + tm \equiv y + tn \pmod L\)</span></p></blockquote><p>首先，将题目中同余式化为 <span class="math inline">\(ax + by =c\)</span> 的形式：</p><ol type="1"><li><p>移项，得 <span class="math inline">\((x - y) + t(m - n) \equiv 0\pmod L\)</span>，即 <span class="math inline">\(L \mid (x - y) + t(m -n)\)</span></p></li><li><p>设 <span class="math inline">\(pL = (x - y) + t(m -n)\)</span>，整理，得 <span class="math inline">\(pL + t(n - m) = (x -y)\)</span></p></li></ol><p>该方程有解当且仅当 <span class="math inline">\((L, n - m) \mid (x -y)\)</span></p><p>就求出了方程 <span class="math inline">\(pL + t(n - m) = (L, n -m)\)</span> 的特解 <span class="math inline">\(p_0, t_0\)</span>。</p><p>得到该方程的通解为 <span class="math inline">\(p = \frac{x - y}{d}p_0+ k\frac{n - m}{d}, \quad t = \frac{x - y}{d}t_0 - k\frac{L}{d} \enspace(k \in \mathbb{Z}, \enspace d = (L, n - m))\)</span></p><p>最后，对通解进行一些调整，就得到了最小整数解</p><p><strong><ahref="http://www.luogu.com.cn/record/75156395">某谷提交记录</a></strong></p><h3 id="中国剩余定理">中国剩余定理</h3><blockquote><p>孙子定理，又称中国剩余定理或中国余数定理，是数论中的一个关于一元线性同余方程组的定理，说明了一元线性同余方程组有解的准则以及求解方法。——维基百科</p></blockquote><h4 id="定义">定义</h4><p><strong>中国剩余定理</strong>(Chinese remainder theorem, 简称 CRT)可用来求解一元线性同余方程组，形如 <span class="math display">\[\begin{cases}x \equiv a_1 \pmod{m_1}\\\\x \equiv a_2 \pmod{m_2}\\\\\quad\vdots\\\\x \equiv a_n \pmod{m_n}\\\\\end{cases}\]</span> 它的结论是，如果所有 <span class="math inline">\(m_i\)</span>两两互质，则对任意的整数 <spanclass="math inline">\(a_i\)</span>，方程组有解。</p><h4 id="算法流程">算法流程</h4><ol type="1"><li><p>设 <span class="math inline">\(M = \displaystyle{\prod_{1 \le i\le n}m_i}\)</span> 是整数 <span class="math inline">\(m_1, m_2, \dots,m_n\)</span> 的乘积，并设 <span class="math inline">\(M_i =\frac{M}{m_i}\)</span>。</p></li><li><p>设 <span class="math inline">\(t_i\)</span> 是线性同余方程 <spanclass="math inline">\(M_i t_i \equiv 1 \pmod{m_i}\)</span> 的一个解，即<span class="math inline">\(t_i\)</span> 为 <spanclass="math inline">\(M_i\)</span> 模 <spanclass="math inline">\(m_i\)</span> 的数论倒数。</p></li><li><p>该方程组有一个特解 <span class="math inline">\(x =\displaystyle{\sum_{1 \le i \le n}a_iM_it_i}\)</span>，该方程组的通解为<span class="math inline">\(x + kM \enspace (k \in\mathbb{Z})\)</span>。</p></li></ol><h4 id="证明-1">证明</h4><p>因为 <span class="math inline">\(M_i = \frac{M}{m_i}\)</span> 是除<span class="math inline">\(m_i\)</span> 外所有模数的倍数，所以 <spanclass="math inline">\(\forall k \neq i, \enspace a_i M_i t_i \equiv 0\pmod{m_k}\)</span>，又因为 <span class="math inline">\(M_i t_i \equiv 0\pmod{m_i}\)</span>，所以 <span class="math inline">\(a_i M_i t_i \equiva_i \pmod{m_i}\)</span>，所以对所有 <span class="math inline">\(a_i M_it_i\)</span> 求和，<span class="math inline">\(x = \displaystyle{\sum_{1\le i \le n}a_iM_it_i}\)</span> 即为线性同余方程组的解。</p><h4 id="实现-1">实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">i64 <span class="hljs-title">crt</span><span class="hljs-params">(<span class="hljs-type">int</span> n, i64* a, i64* m)</span> </span>&#123;<br>    i64 M = <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) M *= m[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        i64 M_i = M / m[i], t_i, tmp;<br>        <span class="hljs-built_in">exgcd</span>(M_i, m[i], t_i, tmp);<br>        res = (res + a[i] * M_i * t_i % M) % M; <br>    &#125;<br>    <span class="hljs-keyword">return</span> (res % M + M) % M;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="扩展中国剩余定理">扩展中国剩余定理</h4><p>中国剩余定理只能用来求解模数 <span class="math inline">\(m_i\)</span>两两互质的线性同余方程组，具有局限性。</p><p><strong>扩展中国剩余定理</strong>(exCRT)，就是通过 <spanclass="math inline">\(n\)</span> 次扩展欧几里得算法求出方程组的解。</p><h5 id="求解过程">求解过程</h5><ol type="1"><li>假设已经求出了前 <span class="math inline">\(k - 1\)</span>个线性同余方程的特解 <span class="math inline">\(x\)</span>，记 <spanclass="math inline">\(m = \operatorname{lcm}(m_1, m_2, \dots,m_{k-1})\)</span>，则前 <span class="math inline">\(k - 1\)</span>个线性同余方程的通解为 <span class="math inline">\(x + i \cdot m\enspace (i \in (0, k))\)</span>。</li><li>对于第 <span class="math inline">\(k\)</span> 个方程 <spanclass="math inline">\(x + t \cdot m \equiv a_k \pmod{m_k}\)</span>，其中<span class="math inline">\(t\)</span> 为未知量，移项后得到 <spanclass="math inline">\(t \cdot m \equiv a_k - x\pmod{m_k}\)</span>，该线性同余方程可以用扩展欧几里得算法求解，求解方法参见上文<strong>青蛙的约会</strong> 解题报告。</li><li>若该线性同余方程无解，那么该线性同余方程组就无解。若有解，那么 <spanclass="math inline">\(x&#39; = x + t \cdot m\)</span> 就是前 <spanclass="math inline">\(k\)</span> 个线性同余方程的一个特解。</li></ol><h3 id="参考资料与注释">参考资料与注释</h3><ol type="1"><li><a href="http://oi-wiki.org/math/number-theory/bezouts/">裴蜀定理 -OI WIKI</a></li><li><a href="http://zh.wikipedia.org/wiki/中国剩余定理">中国剩余定理 -维基百科</a></li><li>李煜东《算法竞赛进阶指南》</li><li>《算法导论》</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>派对灯 解题报告</title>
    <link href="/cogs-USACO-training-%E6%B4%BE%E5%AF%B9%E7%81%AF-%E9%A2%98%E8%A7%A3/"/>
    <url>/cogs-USACO-training-%E6%B4%BE%E5%AF%B9%E7%81%AF-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>总共只有八种情况：</p><ol type="1"><li><p>不按</p></li><li><p>四个按钮分别按</p></li><li><p>按1+4， 2+4 或 3+4</p></li></ol><span id="more"></span><p>容易发现，前三个按钮任意两个同时按等价于按另外的第三个按钮，三个都按相当于没按</p><p>因此，只需要特判 <span class="math inline">\(C \le 2\)</span>的情况就行了，其中 <span class="math inline">\(C = 2\)</span>的情况比较特殊，因为第四个按钮不能被两个按钮转化而成</p><p>而对于 <span class="math inline">\(C &gt; 2\)</span>的情况，因为总有两个按钮可以转化成另外一个按钮，最后还是会回到这八种情况，所以枚举所有情况，判断与情况符合不符合就可以了</p><p>（其实就是打表）</p><h3 id="程序代码">程序代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OPEN(_x) freopen(#_x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#_x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(_a, _b) [&amp;](int __a, int __b) &#123; return __a &lt; __b ? __b : __a; &#125;((_a), (_b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MIN(_a, _b) [&amp;](int __a, int __b) &#123; return __a &gt; __b ? __b : __a; &#125;((_a), (_b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS(_x) [&amp;](int __x) &#123; return __x &lt; 0 ? -__x : __x; &#125;(_x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second </span><br> <br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br> <br><span class="hljs-keyword">namespace</span> IO &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>        T ret = <span class="hljs-number">0</span>, sig = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123; <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) sig = <span class="hljs-number">-1</span>; ch = <span class="hljs-built_in">getchar</span>(); &#125;<br>        <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) ret *= <span class="hljs-number">10</span>, ret += ch - <span class="hljs-number">48</span>, ch = <span class="hljs-built_in">getchar</span>();<br>        <span class="hljs-keyword">return</span> ret * sig;<br>    &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(T out)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!out) &#123; <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>), <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-keyword">return</span>; &#125;<br>        <span class="hljs-type">int</span> stk[<span class="hljs-number">100</span>], tt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(out &lt; <span class="hljs-number">0</span>) out = -out, <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        <span class="hljs-keyword">while</span>(out) stk[tt++] = out % <span class="hljs-number">10</span>, out /= <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = --tt; i&gt;=<span class="hljs-number">0</span>; --i) <span class="hljs-built_in">putchar</span>(stk[i] + <span class="hljs-number">48</span>);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T&amp; ret)</span> </span>&#123; ret = IO::<span class="hljs-built_in">read</span>&lt;T&gt;(); &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x, Args&amp;... args)</span> </span>&#123; IO::<span class="hljs-built_in">read</span>(x), IO::<span class="hljs-built_in">read</span>(args...); &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(T x, Args... args)</span>  </span>&#123; IO::<span class="hljs-built_in">write</span>(x), IO::<span class="hljs-built_in">write</span>(args...); &#125;<br>&#125;;<br> <br> <br><span class="hljs-type">int</span> n, c, a[<span class="hljs-number">10</span>];<br><span class="hljs-type">bool</span> flag;<br> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> g[<span class="hljs-number">8</span>][<span class="hljs-number">7</span>] = &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <br>    <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>    <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>    <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>    <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">6</span>; ++i) <br>        <span class="hljs-keyword">if</span>(a[i] != <span class="hljs-number">-1</span> &amp;&amp; g[x][i] != a[i]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; ++i) <span class="hljs-built_in">putchar</span>(g[x][(i<span class="hljs-number">-1</span>) % <span class="hljs-number">6</span> + <span class="hljs-number">1</span>] + <span class="hljs-number">48</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    flag = <span class="hljs-literal">true</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    IO::<span class="hljs-built_in">read</span>(n, c);<br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> a);<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x), x != <span class="hljs-number">-1</span>) a[(x<span class="hljs-number">-1</span>) % <span class="hljs-number">6</span> + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x), x != <span class="hljs-number">-1</span>) a[(x<span class="hljs-number">-1</span>) % <span class="hljs-number">6</span> + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(!c) <span class="hljs-built_in">check</span>(<span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-number">1</span>) <span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">check</span>(<span class="hljs-number">2</span>), <span class="hljs-built_in">check</span>(<span class="hljs-number">3</span>), <span class="hljs-built_in">check</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; ++i) <span class="hljs-keyword">if</span>(c != <span class="hljs-number">2</span> || i != <span class="hljs-number">3</span>) <span class="hljs-built_in">check</span>(i);<br>    <span class="hljs-keyword">if</span>(!flag) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;IMPOSSIBLE&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零队列 解题报告</title>
    <link href="/cogs-USACO-training-%E9%9B%B6%E9%98%9F%E5%88%97-%E9%A2%98%E8%A7%A3/"/>
    <url>/cogs-USACO-training-%E9%9B%B6%E9%98%9F%E5%88%97-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>这一题一开始我是用dfs选数，但是调试起来太麻烦了，于是换了一个思路，每次选出来<span class="math inline">\(n-1\)</span> 个符号，最后check一下。</p><span id="more"></span><p>check 函数的策略是每遇到一个不为 <strong>空格</strong>的字符就把当前的数 <span class="math inline">\(now\)</span> 加进变量<span class="math inline">\(x\)</span> 中，然后 <spanclass="math inline">\(now\)</span> 初始化成当前字符的下一个数字（也就是<span class="math inline">\(i + 2\)</span>），接着把这个字符用 <spanclass="math inline">\(sig\)</span>存起来作为下一个数的符号，如果遇到的字符是 <strong>空格</strong> 就把<span class="math inline">\(now\)</span> 进一位加上 空格后面的数，最后如果 <span class="math inline">\(x\)</span> 的值为 <spanclass="math inline">\(0\)</span>，那么就符合要求。因为我的 <spanclass="math inline">\(chosen\)</span> 数组是从 <spanclass="math inline">\(0\)</span> 开始的，而 <spanclass="math inline">\(1\)</span> 一开始就加进了 <spanclass="math inline">\(now\)</span> 中，所以<strong>"字符后面的那个数字"</strong> 对应的下标就是 <spanclass="math inline">\(i +2\)</span>。这个下标的问题花了我半天时间调试。</p><p>答案的输出的话其实没有那么麻烦，只需要把答案的字符串存起来排一下序就可以了，因为<strong>std::string</strong> 本来就可以比较字典序的大小</p><h4 id="程序代码">程序代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OPEN(_x) freopen(#_x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#_x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(_a, _b) [&amp;](int __a, int __b) &#123; return __a &lt; __b ? __b : __a; &#125;((_a), (_b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MIN(_a, _b) [&amp;](int __a, int __b) &#123; return __a &gt; __b ? __b : __a; &#125;((_a), (_b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS(_x) [&amp;](int __x) &#123; return __x &lt; 0 ? -__x : __x; &#125;(_x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second </span><br> <br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br> <br><span class="hljs-keyword">namespace</span> IO &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>        T ret = <span class="hljs-number">0</span>, sig = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123; <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) sig = <span class="hljs-number">-1</span>; ch = <span class="hljs-built_in">getchar</span>(); &#125;<br>        <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) ret *= <span class="hljs-number">10</span>, ret += ch - <span class="hljs-number">48</span>, ch = <span class="hljs-built_in">getchar</span>();<br>        <span class="hljs-keyword">return</span> ret * sig;<br>    &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(T out)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!out) &#123; <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>), <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-keyword">return</span>; &#125;<br>        <span class="hljs-type">int</span> stk[<span class="hljs-number">100</span>], tt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(out &lt; <span class="hljs-number">0</span>) out = -out, <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        <span class="hljs-keyword">while</span>(out) stk[tt++] = out % <span class="hljs-number">10</span>, out /= <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = --tt; i&gt;=<span class="hljs-number">0</span>; --i) <span class="hljs-built_in">putchar</span>(stk[i] + <span class="hljs-number">48</span>);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T&amp; ret)</span> </span>&#123; ret = IO::<span class="hljs-built_in">read</span>&lt;T&gt;(); &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x, Args&amp;... args)</span> </span>&#123; IO::<span class="hljs-built_in">read</span>(x), IO::<span class="hljs-built_in">read</span>(args...); &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(T x, Args... args)</span>  </span>&#123; IO::<span class="hljs-built_in">write</span>(x), IO::<span class="hljs-built_in">write</span>(args...); &#125;<br>&#125;;<br> <br> <br><span class="hljs-type">int</span> n;<br>std::vector&lt;<span class="hljs-type">char</span>&gt; chosen;<br>std::vector&lt;std::string&gt; ans;<br> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> now = <span class="hljs-number">1</span>, x = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> sig = <span class="hljs-string">&#x27;+&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(chosen[i] != <span class="hljs-string">&#x27; &#x27;</span>) x += now * (sig == <span class="hljs-string">&#x27;+&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>), now = i + <span class="hljs-number">2</span>, sig = chosen[i];<br>        <span class="hljs-keyword">else</span> now = now * <span class="hljs-number">10</span> + i + <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> !x;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(a == n) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>()) &#123;<br>            std::string str;<br>            str += <span class="hljs-number">49</span>;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : chosen) &#123;<br>                str += i, str += (cnt ++) + <span class="hljs-number">48</span>;<br>            &#125;<br>            ans.<span class="hljs-built_in">emplace_back</span>(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br> <br>    chosen.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&#x27;+&#x27;</span>);<br>    <span class="hljs-built_in">dfs</span>(a + <span class="hljs-number">1</span>);<br>    chosen.<span class="hljs-built_in">pop_back</span>();<br> <br>    chosen.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-built_in">dfs</span>(a + <span class="hljs-number">1</span>);<br>    chosen.<span class="hljs-built_in">pop_back</span>();<br> <br>    chosen.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    <span class="hljs-built_in">dfs</span>(a + <span class="hljs-number">1</span>);<br>    chosen.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    IO::<span class="hljs-built_in">read</span>(n);<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    std::<span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : ans) <span class="hljs-built_in">puts</span>(i.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>丑数 解题报告</title>
    <link href="/cogs-%E4%B8%91%E6%95%B0-%E9%A2%98%E8%A7%A3/"/>
    <url>/cogs-%E4%B8%91%E6%95%B0-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>令 <span class="math inline">\(A\)</span>是所有丑数构成的集合，容易想到，一个丑数是由小于该丑数的一个丑数乘以一个数<span class="math inline">\(S_i(1 \le i \le K)\)</span> 得来的。</p><span id="more"></span><p>所以，对于一个丑数 <span class="math inline">\(A_i\)</span>，枚举集合 <span class="math inline">\(S\)</span> 和 集合 <spanclass="math inline">\(A\)</span>（也可以二分，不过速度本来就够快了），找到两个数 <spanclass="math inline">\(S_i(1 \le i \le K)\)</span> 和 <spanclass="math inline">\(A_j(1 \le j \le i-1)\)</span>，使得 <spanclass="math inline">\(S_i \cdot A_j &gt; A_{i-1}\)</span>，对所有大于<span class="math inline">\(A_{i-1}\)</span> 的数 <spanclass="math inline">\(S_i(1 \le i \le K) \cdot A_j(1 \le j \lei-1)\)</span>，找到一个最小的数，赋值于 <spanclass="math inline">\(A_i\)</span>。</p><p>即 <span class="math inline">\(A_i \gets \min(S_i \cdotA_j)\)</span>，其中,<span class="math inline">\(1 \le i \le K,1 \le j\le i-1\)</span></p><p>最后，第 <span class="math inline">\(N\)</span> 个丑数就是 <spanclass="math inline">\(A_N\)</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二进制01串 解题报告</title>
    <link href="/cogs-USACO-training-%E4%BA%8C%E8%BF%9B%E5%88%B601%E4%B8%B2-%E9%A2%98%E8%A7%A3/"/>
    <url>/cogs-USACO-training-%E4%BA%8C%E8%BF%9B%E5%88%B601%E4%B8%B2-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>刚开始写博客时候还想着要一天写一篇呢，结果一直没有时间写，今天突然想起来这个博客，于是把之前写的一些题解搬过来</p><p>我们用 <span class="math inline">\(f_{i,j}\)</span> 表示 满足“前<span class="math inline">\(i\)</span> 个含 <spanclass="math inline">\(1\)</span> 的数量不大于 <spanclass="math inline">\(j\)</span> ”的数的个数，相当于求组合数 <spanclass="math inline">\({i \choose j}\)</span>，</p><p>即 $ f_{i, j} = f_{i-1, j} + f_{i-1, j-1} $</p><span id="more"></span><p>处理完动态规划的计算之后，我们从第 <spanclass="math inline">\(n\)</span> 位(即从右开始数第 <spanclass="math inline">\(n\)</span> 位)开始，如果 “前 <spanclass="math inline">\(i-1\)</span> 个含 <spanclass="math inline">\(1\)</span> 的数量不大于 <spanclass="math inline">\(L\)</span>”的数的个数” 大于序数 <spanclass="math inline">\(I\)</span> (即 <span class="math inline">\(f_{i-1,L} \ge I\)</span>)，那么我们输出 <spanclass="math inline">\(0\)</span>，否则输出 <spanclass="math inline">\(1\)</span> (想一想，为什么)</p><p>不难理解，如果一个数的位数大于另一个数的位数，那么这个数一定大于另一个数(废话)。</p><p>那么前 <span class="math inline">\(i-1\)</span> 既然已经大于序数<span class="math inline">\(I\)</span>了，那么答案对应的数一定小于当前位取 <spanclass="math inline">\(1\)</span> 时候的数，所以当前位取 <spanclass="math inline">\(0\)</span>。反过来同理。</p><p>输出完一位之后序数 <span class="math inline">\(I\)</span>应减去对应的 <span class="math inline">\(f_{i-1,L}\)</span>，并且确定完一位是 <span class="math inline">\(1\)</span>之后，<span class="math inline">\(1\)</span> 的数量 <spanclass="math inline">\(L\)</span> 也应减一。即</p><p><span class="math inline">\(I \gets I - f_{i-1, L}\)</span>, <spanclass="math inline">\(L \gets L - 1\)</span></p><h3 id="程序代码">程序代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OPEN(_x) freopen(#_x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#_x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(_a, _b) [&amp;](int __a, int __b) &#123; return __a &lt; __b ? __b : __a; &#125;((_a), (_b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MIN(_a, _b) [&amp;](int __a, int __b) &#123; return __a &gt; __b ? __b : __a; &#125;((_a), (_b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ABS(_x) [&amp;](int __x) &#123; return __x &lt; 0 ? -__x : __x; &#125;(_x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second </span><br> <br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br> <br><span class="hljs-keyword">namespace</span> IO &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>        T ret = <span class="hljs-number">0</span>, sig = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123; <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) sig = <span class="hljs-number">-1</span>; ch = <span class="hljs-built_in">getchar</span>(); &#125;<br>        <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) ret *= <span class="hljs-number">10</span>, ret += ch - <span class="hljs-number">48</span>, ch = <span class="hljs-built_in">getchar</span>();<br>        <span class="hljs-keyword">return</span> ret * sig;<br>    &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(T out)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!out) &#123; <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>), <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-keyword">return</span>; &#125;<br>        <span class="hljs-type">int</span> stk[<span class="hljs-number">100</span>], tt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(out &lt; <span class="hljs-number">0</span>) out = -out, <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        <span class="hljs-keyword">while</span>(out) stk[tt++] = out % <span class="hljs-number">10</span>, out /= <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = --tt; i&gt;=<span class="hljs-number">0</span>; --i) <span class="hljs-built_in">putchar</span>(stk[i] + <span class="hljs-number">48</span>);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T&amp; ret)</span> </span>&#123; ret = IO::<span class="hljs-built_in">read</span>&lt;T&gt;(); &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x, Args&amp;... args)</span> </span>&#123; IO::<span class="hljs-built_in">read</span>(x), IO::<span class="hljs-built_in">read</span>(args...); &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(T x, Args... args)</span>  </span>&#123; IO::<span class="hljs-built_in">write</span>(x), IO::<span class="hljs-built_in">write</span>(args...); &#125;<br>&#125;;<br> <br> <br><span class="hljs-type">int</span> n, c, a[<span class="hljs-number">10</span>];<br><span class="hljs-type">bool</span> flag;<br> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> g[<span class="hljs-number">8</span>][<span class="hljs-number">7</span>] = &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <br>    <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>    <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>    <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>    <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">6</span>; ++i) <br>        <span class="hljs-keyword">if</span>(a[i] != <span class="hljs-number">-1</span> &amp;&amp; g[x][i] != a[i]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; ++i) <span class="hljs-built_in">putchar</span>(g[x][(i<span class="hljs-number">-1</span>) % <span class="hljs-number">6</span> + <span class="hljs-number">1</span>] + <span class="hljs-number">48</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    flag = <span class="hljs-literal">true</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    IO::<span class="hljs-built_in">read</span>(n, c);<br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> a);<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x), x != <span class="hljs-number">-1</span>) a[(x<span class="hljs-number">-1</span>) % <span class="hljs-number">6</span> + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x), x != <span class="hljs-number">-1</span>) a[(x<span class="hljs-number">-1</span>) % <span class="hljs-number">6</span> + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(!c) <span class="hljs-built_in">check</span>(<span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-number">1</span>) <span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">check</span>(<span class="hljs-number">2</span>), <span class="hljs-built_in">check</span>(<span class="hljs-number">3</span>), <span class="hljs-built_in">check</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; ++i) <span class="hljs-keyword">if</span>(c != <span class="hljs-number">2</span> || i != <span class="hljs-number">3</span>) <span class="hljs-built_in">check</span>(i);<br>    <span class="hljs-keyword">if</span>(!flag) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;IMPOSSIBLE&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>USACO</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法 学习笔记</title>
    <link href="/KMP%E7%AE%97%E6%B3%95-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/KMP%E7%AE%97%E6%B3%95-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong><em><ahref="http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">KMP算法</a></em></strong>是常用的字符串匹配算法，可以在 <em>O(n+m)</em>的时间复杂度内实现两个字符串的匹配。</p><blockquote><p><strong><em>KMP算法</em></strong>（Knuth-Morris-Pratt字符串查找算法）可在一个字符串<code>S</code> 内查找一个词 <code>W</code>的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前配对的字符。</p><p>—— <em>维基百科</em></p></blockquote><span id="more"></span><h2 id="bf算法朴素做法">BF算法——朴素做法</h2><p>想要了解 <strong>KMP算法</strong> ，先要了解<strong>BF算法</strong>，即朴素算法。它的时间复杂度是 O(nm)</p><p><strong>BF算法</strong> 的代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BFmatch</span><span class="hljs-params">(string A, string B)</span> </span>&#123;<br>    <span class="hljs-comment">//// A为目标串，B为子串</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;(<span class="hljs-type">int</span>)A.<span class="hljs-built_in">size</span>() &amp;&amp; j&lt;(<span class="hljs-type">int</span>)B.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span>(A[i] == B[j]) i++, j++; <span class="hljs-comment">//// 如果匹配，指针向右移动</span><br>        <span class="hljs-keyword">else</span> i = i-j+<span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; <span class="hljs-comment">//// 如果不匹配，指针i向右移动，指针j清零</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(j == (<span class="hljs-type">int</span>)B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> i - B.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//// 成功匹配</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//// 匹配失败</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>BF算法</strong>很简单，且容易理解，但是因为效率极低，因为要有很多次重复的比较，那么，怎么减少重复的比较呢？答案是采用<strong>KMP算法</strong>。</p><p>俗话说，<em>“吃一堑，长一智 ”</em> ，<strong>KMP算法</strong>的思想，就是设法利用前面已知的失配信息，不把模式串移动到已经比较过的位置，从而大大提高了效率。</p><h2 id="kmp算法的原理">KMP算法的原理</h2><h3 id="实例">实例</h3><p>具体怎么利用失配信息呢？</p><p>设目标串为 <code>"abcabcaabbabcdab"</code>, 模式串为<code>"abcd"</code> ， <strong>BF算法</strong> 的过程为（<code>"-"</code> 表示匹配成功，<code>"|"</code>表示匹配失败的位置）：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">abcabcaabbabcdab<br>---<span class="hljs-string">|</span><br>abcd<br></code></pre></td></tr></table></figure><p>逐个字符比较，发现在第四个字符 <code>'a'</code>处失配，如果是朴素算法，需要把模式串向右移动一个字符，重新比较：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">abcabcaabbabcdab<br> <span class="hljs-string">|</span><br> abcd<br></code></pre></td></tr></table></figure><p>这样的话，从第一位就不是匹配的，再右移一位，会发现还不是匹配的，这样的话，就会浪费很多时间。</p><p>注意到，前面匹配过的部分有和目标串后面重合的部分，所以可以把模式串的开头直接对其目标串的<code>"abc"</code>处，这样，就直接跳过了几个字符，而且已经匹配过的部分不会再进行比较：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">abcabcaabbabcdab<br>   ---<span class="hljs-string">|</span><br>   abcd<br></code></pre></td></tr></table></figure><h3 id="部分匹配表-next数组的含义">部分匹配表 &amp; next数组的含义</h3><p>首先，要了解两个概念：<strong>"前缀"</strong> 和<strong>"后缀"</strong>。"前缀"指除了最后一个字符以外，一个字符串的全部头部组合；"后缀"指除了第一个字符以外，一个字符串的全部尾部组合。</p><p><strong>部分匹配值</strong> 就是前缀和后缀的最长的共有元素的长度。以<code>"ABCDABD"</code> 为例：</p><table><thead><tr class="header"><th style="text-align: left;"><strong>搜索词</strong></th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">D</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>部分匹配值</strong></td><td style="text-align: center;"><strong>0</strong></td><td style="text-align: center;"><strong>0</strong></td><td style="text-align: center;"><strong>0</strong></td><td style="text-align: center;"><strong>0</strong></td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;"><strong>2</strong></td><td style="text-align: center;"><strong>0</strong></td></tr></tbody></table><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs prolog">　　－　<span class="hljs-string">&quot;A&quot;</span>的前缀和后缀都为空集，共有元素的长度为<span class="hljs-number">0</span>；<br><br>　　－　<span class="hljs-string">&quot;AB&quot;</span>的前缀为[<span class="hljs-symbol">A</span>]，后缀为[<span class="hljs-symbol">B</span>]，共有元素的长度为<span class="hljs-number">0</span>；<br><br>　　－　<span class="hljs-string">&quot;ABC&quot;</span>的前缀为[<span class="hljs-symbol">A</span>, <span class="hljs-symbol">AB</span>]，后缀为[<span class="hljs-symbol">BC</span>, <span class="hljs-symbol">C</span>]，共有元素的长度<span class="hljs-number">0</span>；<br><br>　　－　<span class="hljs-string">&quot;ABCD&quot;</span>的前缀为[<span class="hljs-symbol">A</span>, <span class="hljs-symbol">AB</span>, <span class="hljs-symbol">ABC</span>]，后缀为[<span class="hljs-symbol">BCD</span>, <span class="hljs-symbol">CD</span>, <span class="hljs-symbol">D</span>]，共有元素的长度为<span class="hljs-number">0</span>；<br><br>　　－　<span class="hljs-string">&quot;ABCDA&quot;</span>的前缀为[<span class="hljs-symbol">A</span>, <span class="hljs-symbol">AB</span>, <span class="hljs-symbol">ABC</span>, <span class="hljs-symbol">ABCD</span>]，后缀为[<span class="hljs-symbol">BCDA</span>, <span class="hljs-symbol">CDA</span>, <span class="hljs-symbol">DA</span>, <span class="hljs-symbol">A</span>]，共有元素为<span class="hljs-string">&quot;A&quot;</span>，长度为<span class="hljs-number">1</span>；<br><br>　　－　<span class="hljs-string">&quot;ABCDAB&quot;</span>的前缀为[<span class="hljs-symbol">A</span>, <span class="hljs-symbol">AB</span>, <span class="hljs-symbol">ABC</span>, <span class="hljs-symbol">ABCD</span>, <span class="hljs-symbol">ABCDA</span>]，后缀为[<span class="hljs-symbol">BCDAB</span>, <span class="hljs-symbol">CDAB</span>, <span class="hljs-symbol">DAB</span>, <span class="hljs-symbol">AB</span>, <span class="hljs-symbol">B</span>]，共有元素为<span class="hljs-string">&quot;AB&quot;</span>，长度为<span class="hljs-number">2</span>；<br><br>　　－　<span class="hljs-string">&quot;ABCDABD&quot;</span>的前缀为[<span class="hljs-symbol">A</span>, <span class="hljs-symbol">AB</span>, <span class="hljs-symbol">ABC</span>, <span class="hljs-symbol">ABCD</span>, <span class="hljs-symbol">ABCDA</span>, <span class="hljs-symbol">ABCDAB</span>]，后缀为[<span class="hljs-symbol">BCDABD</span>, <span class="hljs-symbol">CDABD</span>, <span class="hljs-symbol">DABD</span>, <span class="hljs-symbol">ABD</span>, <span class="hljs-symbol">BD</span>, <span class="hljs-symbol">D</span>]，共有元素的长度为<span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p>算出上面的 部分匹配表之后，就可以使用部分匹配表加速字符串的查找了。注意到如果是在<code>j</code> 位 失配，那么影响 <code>j</code> 指针回溯的位置的其实是第<code>j − 1</code> 位的 部分匹配值，所以一般将部分匹配表整体先后偏移一位（即把部分匹配表整体右移，一般右移后第0位的值设为-1），得到的新数组就称为<code>next</code>数组，将部分匹配表右移只是为了编程方便，没有其他意义。</p><p>每当模式串跳转时，只需要将模式串索引为 <code>next[i]</code>的部分和失配处对齐就行了。又因为 <code>j</code>是每一次匹配时指向模式串开头的指针，所以把 <code>j</code> 赋值为<code>next[j]</code> 相当于对齐。</p><h3 id="利用next数组进行字符串匹配">利用next数组进行字符串匹配</h3><p>字符串匹配操作和朴素做法相似，但是模式串的移动方式不同：</p><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(string A, string B)</span> </span>&#123;<br>    <span class="hljs-comment">//// A为目标串，B为模式串</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;(<span class="hljs-type">int</span>)A.<span class="hljs-built_in">size</span>() &amp;&amp; j&lt;(<span class="hljs-type">int</span>)B.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span>(A[i] == B[j] || j == <span class="hljs-number">-1</span>) i++, j++; <span class="hljs-comment">//// 如果匹配，指针向右移动</span><br>        <span class="hljs-keyword">else</span> j = next[j]; <span class="hljs-comment">//// 如果不匹配，指针j和失配位置对齐</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(j == (<span class="hljs-type">int</span>)B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> i - B.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//// 成功匹配</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//// 匹配失败</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速求得next数组">快速求得next数组</h3><p>求得 <code>next</code>数组的过程相当于对模式串进行<strong>自我“匹配”</strong>，即以模式串本身为主串，以模式串的前缀为目标子串，如果匹配成功，那么当前的<code>next</code> 值就是匹配成功的字符串的长度。</p><p>具体来说，就是从模式串的第一位（不包括第0位）开始进行自我匹配。每次匹配到的最长长度就是当前的<code>next</code> 值，以 <code>"abababca"</code>为例，如图所示（图片转自知乎答主海纳）：</p><p><imgsrc="http://pic3.zhimg.com/50/v2-645f3ec49836d3c680869403e74f7934_720w.jpg?source=1940ef5c" /><imgsrc="http://pic1.zhimg.com/50/v2-06477b79eadce2d7d22b4410b0d49aba_720w.jpg?source=1940ef5c" /><imgsrc="http://pica.zhimg.com/50/v2-8a1a205df5cad7ab2f07498484a54a89_720w.jpg?source=1940ef5c" /><imgsrc="http://pic1.zhimg.com/50/v2-f2b50c15e7744a7b358154610204cc62_720w.jpg?source=1940ef5c" /><imgsrc="http://pic3.zhimg.com/50/v2-bd42e34a9266717b63706087a81092ac_720w.jpg?source=1940ef5c" /></p><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNext</span><span class="hljs-params">(string p, <span class="hljs-type">int</span> next[])</span> </span>&#123;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;(<span class="hljs-type">int</span>)p.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span>(p[i] == p[j] || j == <span class="hljs-number">-1</span>) i++, j++, next[i] = j;<br>        <span class="hljs-keyword">else</span> j = next[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整代码-acwing833">完整代码 (acwing833)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> next[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> n, m;<br>    std::string p, s;<br><br>    std::cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; s;<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || p[i] == p[j]) &#123;<br>            ++ i, ++ j;<br>            next[i] = j;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j = next[j];<br>        &#125;<br><br>    &#125;<br><br>    i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || s[i] == p[j]) &#123;<br>            ++ i, ++ j;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j = next[j];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (j == n) &#123;<br>            std::cout &lt;&lt; i - j &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            j = next[j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段覆盖 解题报告</title>
    <link href="/luogu1803-%E7%BA%BF%E6%AE%B5%E8%A6%86%E7%9B%96-%E9%A2%98%E8%A7%A3/"/>
    <url>/luogu1803-%E7%BA%BF%E6%AE%B5%E8%A6%86%E7%9B%96-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.luogu.com.cn/problem/P1803">原题链接</a></p><p>很显然，题目中出现 “最多”“最少”，大概率就是要用贪心解决，对于这一题，只需要把所有的线段按照结束时间排序，每次在能选的线段中选择结束时间最早的</p><span id="more"></span><p>为什么这个策略是正确的？可以用范围缩放来证明。</p><p>对于任意两个能选的线段 <strong>a</strong> 和<strong>b</strong>，<strong>a</strong> 的结束时间小于<strong>b</strong>，那么选择 <strong>a</strong> 对于整体问题的影响显然比<strong>b</strong> 要小。因为 对于后面的线段 ，只会出现 “开始时间早于 a的结束时间” “开始时间晚于 a ，小于 b” “开始时间晚于 b”这三种情况之一。因此，选择结束时间较早的 a去覆盖，对于整体问题的影响显然要比选择结束时间较晚的 b 去覆盖更好。</p><p>另外，每个线段对于答案的贡献最多是1。即使让当前的线段放弃覆盖，留下空间给后面的线段用，对于答案的贡献也不会更大。综上所述，在<strong>开始时间晚于当前最晚结束时间的线段</strong> 中选择<strong>结束时间较早的线段</strong> 去覆盖是一个正确的贪心策略。</p><p>AC代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(PII a, PII b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.second &lt; b.second;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n, ed = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>; <br>    cin&gt;&gt;n;<br>    vector&lt;PII&gt; lines;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        lines.<span class="hljs-built_in">push_back</span>(&#123;a, b&#125;);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(lines.<span class="hljs-built_in">begin</span>(), lines.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:lines) &#123;<br>        <span class="hljs-keyword">if</span>(item.first &gt;= ed) &#123;<br>            ed = item.second;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大子段和 解题报告</title>
    <link href="/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C-%E9%A2%98%E8%A7%A3/"/>
    <url>/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.luogu.com.cn/problem/P1115">原题链接</a></p><p>这是无长度限制的最大子段和问题，是一个经典问题，可以通过<strong>贪心</strong>解决</p><p>只需 O(n)扫描该数列，不断把新的数加入子段，当子段和变成负数时，把当前整个子段清空。扫描过程中出现过的最大子段和即为所求。</p><span id="more"></span><p>需要注意的是，当所有数都是负数时，清空整个子段的操作会使答案为0，就是说把所有数都舍弃掉了，解决方法是输入的时候做一个标记，碰到正数就做上标记，当有正数时的操作是把当前整个子段清空，没有正数时的操作是直接比较。</p><p>为什么这个策略是正确的？可以用范围缩放来证明，考虑这一步策略的作用范围扩展到后续其他数之后产生的影响。如果子段和为负，加上后面的数后的子段和会小于不带加上后面的数时的子段和。舍弃掉前面为负的子段和，对整体问题的影响显然比加上要好。如果都为负数，显然任意两个负数之和都小于其中的两个负数，所以只需要找出最大值就行。</p><p>AC代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">2e5</span>;<br>ll n, num[MAXN], maxn = <span class="hljs-number">-0x7fffffff</span>;<br><span class="hljs-type">bool</span> flag = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        cin&gt;&gt;num[i];<br>        <span class="hljs-keyword">if</span>(num[i]&gt;<span class="hljs-number">0</span>) flag = <span class="hljs-number">1</span>;<br>    &#125;<br>    ll sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>        sum += num[i];<br>        <span class="hljs-keyword">if</span>(flag) &#123;<br>            <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>) sum = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> sum = num[i];<br>        maxn = <span class="hljs-built_in">max</span>(maxn, sum);<br>    &#125;<br>    cout&lt;&lt;maxn&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组元素的目标和 解题报告</title>
    <link href="/acwing-800-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C-%E9%A2%98%E8%A7%A3/"/>
    <url>/acwing-800-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><ahref="http://www.acwing.com/problem/content/description/802/">原题链接</a></p><p>这是一道很简单(模板题)的题目，主要思路是利用<strong>双指针</strong>把程序从 <em>O(n^2)</em> 降到<em>O(n)</em></p><span id="more"></span><p>很显然这一题用暴力枚举是不能AC的，那么就需要优化，因为 A数组 和 B数组都是<strong>升序排序</strong>的，所以 j 从m-1处开始枚举，若 A[i] + B[j]&gt; x，那么对于任意A[i]后面的数, 都有 A[i]+B[j] &gt; x, 所以 i指针固定不动, j指针 向左移动, 直到 A[i] + B[j] &lt;= x, 若A[i] + B[j] == x,输出答案即可。若不存在A[i] + B[j] &gt;= x，则 j指针不论向左移动几步，都不能使 A[i] + B[j] &gt;= x, 所以 j指针 固定不动,i指针向右移动。</p><p>我愿称这类算法为 「双向奔赴」,可以减少很多次对 j 的循环。</p><p>完整AC代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, x;<br><span class="hljs-type">int</span> A[MAXN], B[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++) cin&gt;&gt;A[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++) cin&gt;&gt;B[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = m<span class="hljs-number">-1</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-keyword">while</span>(A[i] + B[j] &gt; x) j--;<br>        <span class="hljs-keyword">if</span>(A[i]+B[j] == x) &#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
